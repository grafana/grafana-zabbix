{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"lodash\"","webpack:///./datasource-zabbix/utils.ts","webpack:///./datasource-zabbix/constants.ts","webpack:///external \"@grafana/ui\"","webpack:///external \"emotion\"","webpack:///./datasource-zabbix/types.ts","webpack:///external \"moment\"","webpack:///external \"@grafana/runtime\"","webpack:///external \"@grafana/data\"","webpack:///../node_modules/semver/classes/semver.js","webpack:///./panel-triggers/utils.ts","webpack:///external \"app/core/utils/datemath\"","webpack:///external \"jquery\"","webpack:///../node_modules/semver/functions/compare.js","webpack:///../node_modules/semver/classes/range.js","webpack:///external \"app/plugins/sdk\"","webpack:///external \"app/core/utils/kbn\"","webpack:///./panel-triggers/migrations.ts","webpack:///../node_modules/semver/internal/re.js","webpack:///../node_modules/semver/functions/parse.js","webpack:///../node_modules/semver/internal/constants.js","webpack:///../node_modules/semver/internal/debug.js","webpack:///../node_modules/semver/functions/gt.js","webpack:///../node_modules/semver/classes/comparator.js","webpack:///../node_modules/semver/functions/satisfies.js","webpack:///external \"app/core/core_module\"","webpack:///../node_modules/semver/internal/identifiers.js","webpack:///../node_modules/semver/functions/eq.js","webpack:///../node_modules/semver/functions/compare-build.js","webpack:///../node_modules/semver/functions/lt.js","webpack:///../node_modules/semver/functions/gte.js","webpack:///../node_modules/semver/functions/lte.js","webpack:///../node_modules/semver/ranges/outside.js","webpack:///external \"app/core/core\"","webpack:///external \"app/core/table_model\"","webpack:///../node_modules/semver/functions/neq.js","webpack:///../node_modules/semver/functions/cmp.js","webpack:///external \"app/core/config\"","webpack:///../node_modules/semver/index.js","webpack:///external \"angular\"","webpack:///../node_modules/semver/functions/valid.js","webpack:///../node_modules/semver/functions/clean.js","webpack:///../node_modules/semver/functions/inc.js","webpack:///../node_modules/semver/functions/diff.js","webpack:///../node_modules/semver/functions/major.js","webpack:///../node_modules/semver/functions/minor.js","webpack:///../node_modules/semver/functions/patch.js","webpack:///../node_modules/semver/functions/prerelease.js","webpack:///../node_modules/semver/functions/rcompare.js","webpack:///../node_modules/semver/functions/compare-loose.js","webpack:///../node_modules/semver/functions/sort.js","webpack:///../node_modules/semver/functions/rsort.js","webpack:///../node_modules/semver/functions/coerce.js","webpack:///../node_modules/semver/ranges/to-comparators.js","webpack:///../node_modules/semver/ranges/max-satisfying.js","webpack:///../node_modules/semver/ranges/min-satisfying.js","webpack:///../node_modules/semver/ranges/min-version.js","webpack:///../node_modules/semver/ranges/valid.js","webpack:///../node_modules/semver/ranges/gtr.js","webpack:///../node_modules/semver/ranges/ltr.js","webpack:///../node_modules/semver/ranges/intersects.js","webpack:///../node_modules/semver/ranges/simplify.js","webpack:///../node_modules/semver/ranges/subset.js","webpack:///./datasource-zabbix/migrations.ts","webpack:///./datasource-zabbix/metricFunctions.ts","webpack:///./datasource-zabbix/timeseries.ts","webpack:///./datasource-zabbix/dataProcessor.ts","webpack:///./datasource-zabbix/responseHandler.ts","webpack:///./datasource-zabbix/problemsHandler.ts","webpack:///./datasource-zabbix/zabbix/proxy/cachingProxy.ts","webpack:///./datasource-zabbix/zabbix/connectors/dbConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPIConnector.ts","webpack:///./datasource-zabbix/zabbix/connectors/sql/mysql.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/postgres.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/sqlConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/influxdb/influxdbConnector.js","webpack:///./datasource-zabbix/zabbix/zabbix.ts","webpack:///./datasource-zabbix/datasource.ts","webpack:///./datasource-zabbix/components/ZabbixInput.tsx","webpack:///./datasource-zabbix/query.controller.ts","webpack:///./datasource-zabbix/components/VariableQueryEditor.tsx","webpack:///./datasource-zabbix/components/ConfigEditor.tsx","webpack:///./datasource-zabbix/add-metric-function.directive.js","webpack:///./datasource-zabbix/react2angular.ts","webpack:///./datasource-zabbix/components/FunctionEditorControls.tsx","webpack:///./datasource-zabbix/components/FunctionEditor.tsx","webpack:///./datasource-zabbix/metric-function-editor.directive.ts","webpack:///./datasource-zabbix/module.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","variableRegex","expandItemName","paramStr","params","quoted","in_array","param","key_params_str","substring","indexOf","lastIndexOf","key_params","forEach","symbol","push","length","replace","expandItems","items","item","key_","MACRO_PATTERN","containsMacro","itemName","test","replaceMacro","macros","isTriggerItem","url","item_macros","match","macro","host_macros","filter","hostid","hosts","h","macro_def","find","macro_value","macro_regex","RegExp","escapeMacro","parseLegacyVariableQuery","query","queryType","parts","each","split","isContainsBraces","result","map","part","trim","splitTemplateQuery","template","zipObject","app","Group","Host","Application","Item","group","host","application","regexPattern","isRegex","str","isTemplateVariable","templateVariables","variables","variable","includes","getRangeScopedVars","range","msRange","to","diff","from","sRange","Math","round","regularRange","secondsToHms","__range_ms","text","__range_s","__range","__range_series","buildRegex","matches","pattern","flags","undefined","escapeRegex","parseInterval","interval","momentInterval","exec","duration","Number","valueOf","parseTimeShiftInterval","formatAcknowledges","acknowledges","ack","unix","clock","format","alias","surname","message","concat","sequence","funcsArray","this","compactQuery","getArrayDepth","a","level","elem","isArray","isNumeric","isNaN","parseFloat","isFinite","parseTags","tagStr","tags","tag","tagParts","mustArray","ZABBIX_PROBLEMS_PANEL_ID","DATAPOINT_TS","MODE_METRICS","MODE_ITSERVICE","MODE_TEXT","MODE_ITEMID","MODE_TRIGGERS","MODE_PROBLEMS","ZBX_ACK_ACTION_NONE","ZBX_ACK_ACTION_CLOSE","ZBX_ACK_ACTION_ACK","ZBX_ACK_ACTION_ADD_MESSAGE","ZBX_ACK_ACTION_CHANGE_SEVERITY","TRIGGER_SEVERITY","val","MIN_SLA_INTERVAL","RANGE_VARIABLE_VALUE","DEFAULT_ZABBIX_PROBLEMS_LIMIT","__WEBPACK_EXTERNAL_MODULE__5__","__WEBPACK_EXTERNAL_MODULE__6__","VariableQueryTypes","ShowProblemTypes","__WEBPACK_EXTERNAL_MODULE__9__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__11__","debug","require","MAX_LENGTH","MAX_SAFE_INTEGER","re","compareIdentifiers","SemVer","version","options","loose","includePrerelease","TypeError","LOOSE","FULL","raw","major","minor","patch","prerelease","id","num","build","join","other","compareMain","comparePre","b","release","identifier","inc","Error","isNewProblem","problem","highlightNewerThan","highlightIntervalMs","Date","now","timestamp","e","formatLastChange","lastchangeUnix","customFormat","getNextRefIdChar","queries","refId","every","renderUrl","path","rbracket","add","buildParams","keys","obj","toString","k","v","encodeURIComponentAsAngularJS","prefix","len","String","pctEncodeSpaces","encodeURIComponent","__WEBPACK_EXTERNAL_MODULE__14__","__WEBPACK_EXTERNAL_MODULE__15__","compare","Range","Comparator","set","parseRange","comps","hr","HYPHENRANGELOOSE","HYPHENRANGE","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","compRe","COMPARATORLOOSE","COMPARATOR","comp","parseComparator","replaceGTE0","some","thisComparators","isSatisfiable","rangeComparators","thisComparator","rangeComparator","intersects","er","testSet","comparators","remainingComparators","slice","testComparator","pop","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","toLowerCase","replaceTilde","TILDELOOSE","TILDE","_","M","pr","ret","replaceCaret","CARETLOOSE","CARET","z","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","tb","semver","ANY","allowed","__WEBPACK_EXTERNAL_MODULE__18__","__WEBPACK_EXTERNAL_MODULE__20__","CURRENT_SCHEMA_VERSION","migratePanelSchema","panel","datasource","datasources","triggers","targets","isEmpty","isEmptyPanel","schemaVersion","getSchemaVersion","lastChangeField","infoField","scroll","hideHostsInMaintenance","target","defaultsDeep","trigger","proxy","showEvents","updatedTargets","targetKey","isEmptyTarget","isInvalidTarget","showProblems","migrateShowEvents","migrateOptions","defaults","hostsInMaintenance","sortProblems","sortTriggersBy","showTriggers","acknowledged","limit","minSeverity","Problems","History","MAX_SAFE_COMPONENT_LENGTH","src","R","createToken","isGlobal","index","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCE","LONETILDE","LONECARET","SEMVER_SPEC_VERSION","process","env","NODE_DEBUG","args","console","error","parse","operator","cmp","sameDirectionIncreasing","sameDirectionDecreasing","sameSemVer","differentDirectionsInclusive","oppositeDirectionsLessThan","oppositeDirectionsGreaterThan","__WEBPACK_EXTERNAL_MODULE__30__","numeric","anum","bnum","rcompareIdentifiers","versionA","versionB","compareBuild","satisfies","gt","lt","lte","gte","hilo","gtfn","ltefn","ltfn","ecomp","high","low","comparator","__WEBPACK_EXTERNAL_MODULE__38__","__WEBPACK_EXTERNAL_MODULE__39__","eq","neq","op","__WEBPACK_EXTERNAL_MODULE__43__","internalRe","tokens","valid","clean","rcompare","compareLoose","sort","rsort","coerce","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","__WEBPACK_EXTERNAL_MODULE__45__","version1","version2","v1","v2","hasPre","defaultResult","parsed","list","rtl","next","COERCERTL","lastIndex","versions","max","maxSV","rangeObj","min","minSV","minver","compver","r1","r2","prev","ranges","simplified","original","simpleSubset","sub","dom","gtltComp","eqSet","Set","higherGT","lowerLT","size","hasDomLT","hasDomGT","sawNonNull","OUTER","simpleSub","simpleDom","isSub","f","def","jsonData","dbConnection","funcDef","type","func","paramType","strValue","datapoints","point","ms_interval","series","left","right","time_to","timeWindow","groupBy","interpolated_timeseries","j","ema","values","values_non_null","partial","aggregateWrapper","setAlias","dp","itemid","scopedVars","extractedValue","addHostName","convertText","table","addColumn","triggerFilter","cacheOptions","self","cache","funcName","promises","promiseKeeper","hash","datasourceId","datasourceName","datasourceTypeId","datasourceTypeName","DBConnector","then","ds","meta","convertGrafanaTSResponse","history","methodName","code","grafanaSeries","compact","DEFAULT_QUERY_LIMIT","HISTORY_TO_TABLE_MAP","TREND_TO_TABLE_MAP","consolidateByFunc","consolidateByTrendColumns","requestOptions","getVersionPromise","action","applicationids","timeRange","historyQuery","trendsQuery","itemids","timeFrom","timeTill","intervalSec","testQuery","ITEMID_FORMAT","time_expression","mysql","sqlDialect","postgres","invokeSQLQuery","intervalMs","consolidateBy","numOfIntervals","grouped_items","value_type","results","valueColumn","dbConnector","rawSql","maxDataPoints","method","data","retentionPolicy","Promise","reject","buildHistoryQuery","invokeInfluxDBQuery","handleInfluxHistoryResponse","influxSeries","points","measurement","where_clause","itemidsWhere","cachingProxy","proxifyWithCache","initDBConnector","testDataSource","filters","apps","getAllHosts","groupFilter","getAllApps","getApps","appsResponse","hostids","getAllItems","getItemValues","getProblems","hostFilter","getProblemsHistory","getHistoryTS","getTrends","finded","instanceSettings","trends","bindFunctionDefs","functions","itservices","replaceTemplateVars","severities","problems","zabbix","annotation","annotationTags","metricObj","replacedTarget","getMetricNames","metrics","unshift","utils","move","aliasFunc","renderQueryOptionsText","optionsMap","optionValue","inputClass","styles","label","state","className","$compile","$scope","functionMenu","$button","submenu","click","$","buttonTemplate","appendTo","$input","attr","typeahead","minLength","updater","keyup","blur","setTimeout","show","removeClass","onClick","updatePopperPosition","$comma","$link","paramIndex","defParams","ctrl","moveFunction","secureJsonData"],"mappings":"gUACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,gBClFrDhC,EAAOD,QAAUkC,G,cCAjBjC,EAAOD,QAAUmC,G,8BCAjB,2uBAYaC,EAAgB,+EAStB,SAASC,EAAe5B,EAAcgB,GAQ3C,IAJA,IAmBsBa,EAChBC,EACFC,EACAC,EAEAC,EAxBEC,EAAiBlB,EAAImB,UAAUnB,EAAIoB,QAAQ,KAAO,EAAGpB,EAAIqB,YAAY,MACrEC,GAkBgBT,EAlBYK,EAmB5BJ,EAAS,GACXC,GAAS,EACTC,GAAW,EAEXC,EAAQ,GAEZ,IAAEM,QAAQV,GAAU,SAAAW,GACH,MAAXA,GAAkBR,EACpBC,GAASO,EACW,MAAXA,GAAkBT,EAC3BA,GAAS,EACW,MAAXS,GAAmBT,EAER,MAAXS,GAAmBT,EAER,MAAXS,GAAmBT,EAZX,MAcRS,GAA4BT,GAAWC,EAIhDC,GAASO,GAHTV,EAAOW,KAAKR,GACZA,EAAQ,IAHRD,GAAW,EAFXA,GAAY,EAFZD,GAAS,KAabD,EAAOW,KAAKR,GACLH,GA1CErC,EAAI6C,EAAWI,OAAQjD,GAAK,EAAGA,IACtCO,EAAOA,EAAK2C,QAAQ,IAAMlD,EAAG6C,EAAW7C,EAAI,IAE9C,OAAOO,EAGF,SAAS4C,EAAYC,GAM1B,OALA,IAAEN,QAAQM,GAAO,SAAAC,GAGf,OAFAA,EAAKA,KAAOA,EAAK9C,KACjB8C,EAAK9C,KAAO4B,EAAekB,EAAKA,KAAMA,EAAKC,MACpCD,KAEFD,EAiCT,IAAMG,EAAgB,oBAEf,SAASC,EAAcC,GAC5B,OAAOF,EAAcG,KAAKD,GAGrB,SAASE,EAAaN,EAAMO,EAAQC,GACzC,IAAIJ,EAAWI,EAAgBR,EAAKS,IAAMT,EAAK9C,KACzCwD,EAAcN,EAASO,MAAMT,GAgCnC,OA/BA,IAAET,QAAQiB,GAAa,SAAAE,GACrB,IAAMC,EAAc,IAAEC,OAAOP,GAAQ,SAAAxD,GACnC,GAAIA,EAAEgE,OAAQ,CACZ,GAAIP,EAAe,CAGjB,IAAI,GAAc,EAMlB,OALA,IAAEf,QAAQO,EAAKgB,OAAO,SAAAC,GAChBA,EAAEF,SAAWhE,EAAEgE,SACjB,GAAc,MAGX,EAGP,OAAOhE,EAAEgE,SAAWf,EAAKe,OAI3B,OAAO,KAILG,EAAY,IAAEC,KAAKN,EAAa,CAAED,MAAOA,IAC/C,GAAIM,GAAaA,EAAUtD,MAAO,CAChC,IAAMwD,EAAcF,EAAUtD,MACxByD,EAAc,IAAIC,OAQ9B,SAAqBV,GAEnB,OADAA,EAAQA,EAAMf,QAAQ,KAAM,OATO0B,CAAYX,IAC3CR,EAAWA,EAASP,QAAQwB,EAAaD,OAItChB,EAQF,SAASoB,EAAyBC,GACvC,IAAIC,EACEC,EAAQ,GAGd,IAAEC,KA6CG,SAA4BH,GACjC,IACII,EAEJ,GAYF,SAA0BJ,GAExB,MADsB,WACDpB,KAAKoB,GAdtBK,CAAiBL,GAAQ,CAC3B,IAAMM,EAASN,EAAMd,MAJF,4BAKnBkB,EAAQ,IAAEG,IAAID,GAAQ,SAAAE,GACpB,OAAO,IAAEC,KAAKD,EAAM,cAGtBJ,EAAQJ,EAAMI,MAAM,KAGtB,OAAOA,EA1DAM,CAAmBV,IAAQ,SAAAQ,GAEnB,MAATA,IACFA,EAAO,QAETN,EAAMhC,KAAKsC,MAEb,IAAMG,EAAW,IAAEC,UAAU,CAAC,QAAS,OAAQ,MAAO,QAASV,GAO/D,OALqB,IAAjBA,EAAM/B,QAAiC,SAAjBwC,EAASE,MAEjCF,EAASE,IAAM,IAGTX,EAAM/B,QACZ,KAAK,EACH8B,EAAY,IAAmBa,MAC/B,MACF,KAAK,EACHb,EAAY,IAAmBc,KAC/B,MACF,KAAK,EACHd,EAAY,IAAmBe,YAC/B,MACF,KAAK,EACHf,EAAY,IAAmBgB,KAYnC,MARqC,CACnChB,UAAS,EACTiB,MAAOP,EAASO,OAAS,GACzBC,KAAMR,EAASQ,MAAQ,GACvBC,YAAaT,EAASE,KAAO,GAC7BtC,KAAMoC,EAASpC,MAAQ,IAiCpB,IAAM8C,EAAe,sBAErB,SAASC,EAAQC,GACtB,OAAOF,EAAazC,KAAK2C,GAGpB,SAASC,EAAmBD,EAAKE,GAEtC,GADwB,SACJ7C,KAAK2C,GAAM,CAC7B,IAAMG,EAAY,IAAEnB,IAAIkB,GAAmB,SAAAE,GACzC,MAAO,IAAMA,EAASlG,QAExB,OAAO,IAAEmG,SAASF,EAAWH,GAE7B,OAAO,EAIJ,SAASM,EAAmBC,GACjC,IAAMC,EAAUD,EAAME,GAAGC,KAAKH,EAAMI,MAC9BC,EAASC,KAAKC,MAAMN,EAAU,KAC9BO,EAAe,IAAIC,aAAaR,EAAU,KAChD,MAAO,CACLS,WAAY,CAAEC,KAAMV,EAAS5F,MAAO4F,GACpCW,UAAW,CAAED,KAAMN,EAAQhG,MAAOgG,GAClCQ,QAAS,CAAEF,KAAMH,EAAcnG,MAAOmG,GACtCM,eAAgB,CAACH,KAAM,IAAwBtG,MAAO,MAInD,SAAS0G,EAAWtB,GACzB,IAAMuB,EAAUvB,EAAIrC,MAAMmC,GACpB0B,EAAUD,EAAQ,GAClBE,EAAuB,KAAfF,EAAQ,GAAYA,EAAQ,QAAKG,EAC/C,OAAO,IAAIpD,OAAOkD,EAASC,GAKtB,SAASE,EAAY/G,GAC1B,OAAOA,EAAMiC,QAAQ,wBAAyB,QAGzC,SAAS+E,EAAcC,GAC5B,IACMC,EADkB,2BACsBC,KAAKF,GAEnD,OADiB,IAAOG,SAASC,OAAOH,EAAe,IAAKA,EAAe,IAC1DI,UAGZ,SAASC,EAAuBN,GACrC,IACMC,EADkB,oCACsBC,KAAKF,GASnD,MAN0B,MAAtBC,EAAe,GACN,EAAK,IAAOE,SAASC,OAAOH,EAAe,IAAKA,EAAe,IAAII,UAEnE,IAAOF,SAASC,OAAOH,EAAe,IAAKA,EAAe,IAAII,UAYtE,SAASE,EAAmBC,GACjC,GAAIA,EAAazF,OAAQ,CACvB,IAAI,EAAyB,4GAU7B,OARA,IAAEgC,KAAK,IAAEI,IAAIqD,GAAc,SAAAC,GAEzB,MAAO,cADW,IAAOC,KAAKD,EAAIE,OACDC,OAAO,wBAA0B,gBAAkBH,EAAII,MACpF,KAAOJ,EAAIpI,KAAO,IAAMoI,EAAIK,QADzB,aACuDL,EAAIM,QAAU,iBAC1E,SAAAN,GACF,EAAyB,EAAuBO,OAAOP,MAEzD,EAAyB,EAAuBO,OAAO,YAGvD,MAAO,GAwCJ,SAASC,EAASC,GACvB,OAAO,SAAShE,GACd,IAAK,IAAIpF,EAAI,EAAGA,EAAIoJ,EAAWnG,OAAQjD,IACrCoF,EAASgE,EAAWpJ,GAAGG,KAAKkJ,KAAMjE,GAEpC,OAAOA,GAyBJ,SAASkE,EAAaxE,GAC3B,OAAOA,EAAM5B,QAAQ,OAAQ,KAAKqC,OAG7B,SAASgE,EAAcC,EAAGC,GAC/B,QAD+B,IAAAA,MAAA,GACd,IAAbD,EAAEvG,OACJ,OAAO,EAET,IAAMyG,EAAOF,EAAE,GACf,OAAI,IAAEG,QAAQD,GACLH,EAAcG,EAAMD,EAAQ,GAE9BA,EAAQ,EAMV,SAASG,EAAUnI,GACxB,OAAQoI,MAAMC,WAAWrI,KAAOsI,SAAStI,GAMpC,SAASuI,EAAUC,GACxB,IAAKA,EACH,MAAO,GAGT,IAAIC,EAAc,IAAE7E,IAAI4E,EAAO/E,MAAM,MAAM,SAACiF,GAAQ,OAAAA,EAAI5E,UAKxD,OAJA2E,EAAO,IAAE7E,IAAI6E,GAAM,SAACC,GAClB,IAAMC,EAAWD,EAAIjF,MAAM,KAC3B,MAAO,CAACiF,IAAKC,EAAS,GAAG7E,OAAQtE,MAAOmJ,EAAS,GAAG7E,WAKjD,SAAS8E,EAAUjF,GACxB,OAAOA,GAAU,K,6BCnYnB,kkBACO,IAAMkF,EAA2B,wCAK3BC,EAAe,EAGfC,EAAe,EACfC,EAAiB,EACjBC,EAAY,EACZC,EAAc,EACdC,EAAgB,EAChBC,EAAgB,EAehBC,EAAsB,EACtBC,EAAuB,EACvBC,EAAqB,EACrBC,EAA6B,EAC7BC,EAAiC,EAEjCC,EAAmB,CAC9B,CAACC,IAAK,EAAG7D,KAAM,kBACf,CAAC6D,IAAK,EAAG7D,KAAM,eACf,CAAC6D,IAAK,EAAG7D,KAAM,WACf,CAAC6D,IAAK,EAAG7D,KAAM,WACf,CAAC6D,IAAK,EAAG7D,KAAM,QACf,CAAC6D,IAAK,EAAG7D,KAAM,aAIJ8D,EAAmB,KAEnBC,EAAuB,eAEvBC,EAAgC,M,cCjD7CxL,EAAOD,QAAU0L,G,cCAjBzL,EAAOD,QAAU2L,G,6BCiIjB,IAAYC,EAQAC,EARZ,6EAAYD,GACV,gBACA,cACA,4BACA,cACA,0BALF,CAAYA,MAAkB,KAQ9B,SAAYC,GACV,sBACA,kBACA,oBAHF,CAAYA,MAAgB,M,eCzI5B5L,EAAOD,QAAU8L,G,cCAjB7L,EAAOD,QAAU+L,G,cCAjB9L,EAAOD,QAAUgM,G,2ZCAjB,IAAMC,EAAQC,EAAQ,I,EACmBA,EAAQ,IAAzCC,E,EAAAA,WAAYC,E,EAAAA,iB,EACFF,EAAQ,IAAlBG,E,EAAAA,GAAIjL,E,EAAAA,EAEJkL,EAAuBJ,EAAQ,IAA/BI,mBACFC,E,WACJ,WAAaC,EAASC,GAOpB,G,4FAP8B,CAAD,QACxBA,GAA8B,WAAnB,EAAOA,KACrBA,EAAU,CACRC,QAASD,EACTE,mBAAmB,IAGnBH,aAAmBD,EAAQ,CAC7B,GAAIC,EAAQE,UAAYD,EAAQC,OAC5BF,EAAQG,sBAAwBF,EAAQE,kBAC1C,OAAOH,EAEPA,EAAUA,EAAQA,aAEf,GAAuB,iBAAZA,EAChB,MAAM,IAAII,UAAJ,2BAAkCJ,IAG1C,GAAIA,EAAQrJ,OAASgJ,EACnB,MAAM,IAAIS,UAAJ,iCACsBT,EADtB,gBAKRF,EAAM,SAAUO,EAASC,GACzBlD,KAAKkD,QAAUA,EACflD,KAAKmD,QAAUD,EAAQC,MAGvBnD,KAAKoD,oBAAsBF,EAAQE,kBAEnC,IAAMrM,EAAIkM,EAAQ/G,OAAOvB,MAAMuI,EAAQC,MAAQL,EAAGjL,EAAEyL,OAASR,EAAGjL,EAAE0L,OAElE,IAAKxM,EACH,MAAM,IAAIsM,UAAJ,2BAAkCJ,IAU1C,GAPAjD,KAAKwD,IAAMP,EAGXjD,KAAKyD,OAAS1M,EAAE,GAChBiJ,KAAK0D,OAAS3M,EAAE,GAChBiJ,KAAK2D,OAAS5M,EAAE,GAEZiJ,KAAKyD,MAAQZ,GAAoB7C,KAAKyD,MAAQ,EAChD,MAAM,IAAIJ,UAAU,yBAGtB,GAAIrD,KAAK0D,MAAQb,GAAoB7C,KAAK0D,MAAQ,EAChD,MAAM,IAAIL,UAAU,yBAGtB,GAAIrD,KAAK2D,MAAQd,GAAoB7C,KAAK2D,MAAQ,EAChD,MAAM,IAAIN,UAAU,yBAIjBtM,EAAE,GAGLiJ,KAAK4D,WAAa7M,EAAE,GAAG8E,MAAM,KAAKG,KAAI,SAAC6H,GACrC,GAAI,WAAWxJ,KAAKwJ,GAAK,CACvB,IAAMC,GAAOD,EACb,GAAIC,GAAO,GAAKA,EAAMjB,EACpB,OAAOiB,EAGX,OAAOD,KATT7D,KAAK4D,WAAa,GAapB5D,KAAK+D,MAAQhN,EAAE,GAAKA,EAAE,GAAG8E,MAAM,KAAO,GACtCmE,KAAKP,S,wDAQL,OAJAO,KAAKiD,QAAL,UAAkBjD,KAAKyD,MAAvB,YAAgCzD,KAAK0D,MAArC,YAA8C1D,KAAK2D,OAC/C3D,KAAK4D,WAAWhK,SAClBoG,KAAKiD,SAAL,WAAoBjD,KAAK4D,WAAWI,KAAK,OAEpChE,KAAKiD,U,iCAIZ,OAAOjD,KAAKiD,U,8BAGLgB,GAEP,GADAvB,EAAM,iBAAkB1C,KAAKiD,QAASjD,KAAKkD,QAASe,KAC9CA,aAAiBjB,GAAS,CAC9B,GAAqB,iBAAViB,GAAsBA,IAAUjE,KAAKiD,QAC9C,OAAO,EAETgB,EAAQ,IAAIjB,EAAOiB,EAAOjE,KAAKkD,SAGjC,OAAIe,EAAMhB,UAAYjD,KAAKiD,QAClB,EAGFjD,KAAKkE,YAAYD,IAAUjE,KAAKmE,WAAWF,K,kCAGvCA,GAKX,OAJMA,aAAiBjB,IACrBiB,EAAQ,IAAIjB,EAAOiB,EAAOjE,KAAKkD,UAI/BH,EAAmB/C,KAAKyD,MAAOQ,EAAMR,QACrCV,EAAmB/C,KAAK0D,MAAOO,EAAMP,QACrCX,EAAmB/C,KAAK2D,MAAOM,EAAMN,S,iCAI7BM,GAMV,GALMA,aAAiBjB,IACrBiB,EAAQ,IAAIjB,EAAOiB,EAAOjE,KAAKkD,UAI7BlD,KAAK4D,WAAWhK,SAAWqK,EAAML,WAAWhK,OAC9C,OAAQ,EACH,IAAKoG,KAAK4D,WAAWhK,QAAUqK,EAAML,WAAWhK,OACrD,OAAO,EACF,IAAKoG,KAAK4D,WAAWhK,SAAWqK,EAAML,WAAWhK,OACtD,OAAO,EAGT,IAAIjD,EAAI,EACR,EAAG,CACD,IAAMwJ,EAAIH,KAAK4D,WAAWjN,GACpByN,EAAIH,EAAML,WAAWjN,GAE3B,GADA+L,EAAM,qBAAsB/L,EAAGwJ,EAAGiE,QACxB1F,IAANyB,QAAyBzB,IAAN0F,EACrB,OAAO,EACF,QAAU1F,IAAN0F,EACT,OAAO,EACF,QAAU1F,IAANyB,EACT,OAAQ,EACH,GAAIA,IAAMiE,EAGf,OAAOrB,EAAmB5C,EAAGiE,WAEtBzN,K,mCAGCsN,GACNA,aAAiBjB,IACrBiB,EAAQ,IAAIjB,EAAOiB,EAAOjE,KAAKkD,UAGjC,IAAIvM,EAAI,EACR,EAAG,CACD,IAAMwJ,EAAIH,KAAK+D,MAAMpN,GACfyN,EAAIH,EAAMF,MAAMpN,GAEtB,GADA+L,EAAM,qBAAsB/L,EAAGwJ,EAAGiE,QACxB1F,IAANyB,QAAyBzB,IAAN0F,EACrB,OAAO,EACF,QAAU1F,IAAN0F,EACT,OAAO,EACF,QAAU1F,IAANyB,EACT,OAAQ,EACH,GAAIA,IAAMiE,EAGf,OAAOrB,EAAmB5C,EAAGiE,WAEtBzN,K,0BAKR0N,EAASC,GACZ,OAAQD,GACN,IAAK,WACHrE,KAAK4D,WAAWhK,OAAS,EACzBoG,KAAK2D,MAAQ,EACb3D,KAAK0D,MAAQ,EACb1D,KAAKyD,QACLzD,KAAKuE,IAAI,MAAOD,GAChB,MACF,IAAK,WACHtE,KAAK4D,WAAWhK,OAAS,EACzBoG,KAAK2D,MAAQ,EACb3D,KAAK0D,QACL1D,KAAKuE,IAAI,MAAOD,GAChB,MACF,IAAK,WAIHtE,KAAK4D,WAAWhK,OAAS,EACzBoG,KAAKuE,IAAI,QAASD,GAClBtE,KAAKuE,IAAI,MAAOD,GAChB,MAGF,IAAK,aAC4B,IAA3BtE,KAAK4D,WAAWhK,QAClBoG,KAAKuE,IAAI,QAASD,GAEpBtE,KAAKuE,IAAI,MAAOD,GAChB,MAEF,IAAK,QAMc,IAAftE,KAAK0D,OACU,IAAf1D,KAAK2D,OACsB,IAA3B3D,KAAK4D,WAAWhK,QAEhBoG,KAAKyD,QAEPzD,KAAK0D,MAAQ,EACb1D,KAAK2D,MAAQ,EACb3D,KAAK4D,WAAa,GAClB,MACF,IAAK,QAKgB,IAAf5D,KAAK2D,OAA0C,IAA3B3D,KAAK4D,WAAWhK,QACtCoG,KAAK0D,QAEP1D,KAAK2D,MAAQ,EACb3D,KAAK4D,WAAa,GAClB,MACF,IAAK,QAK4B,IAA3B5D,KAAK4D,WAAWhK,QAClBoG,KAAK2D,QAEP3D,KAAK4D,WAAa,GAClB,MAGF,IAAK,MACH,GAA+B,IAA3B5D,KAAK4D,WAAWhK,OAClBoG,KAAK4D,WAAa,CAAC,OACd,CAEL,IADA,IAAIjN,EAAIqJ,KAAK4D,WAAWhK,SACfjD,GAAK,GACsB,iBAAvBqJ,KAAK4D,WAAWjN,KACzBqJ,KAAK4D,WAAWjN,KAChBA,GAAK,IAGE,IAAPA,GAEFqJ,KAAK4D,WAAWjK,KAAK,GAGrB2K,IAGEtE,KAAK4D,WAAW,KAAOU,EACrB9D,MAAMR,KAAK4D,WAAW,MACxB5D,KAAK4D,WAAa,CAACU,EAAY,IAGjCtE,KAAK4D,WAAa,CAACU,EAAY,IAGnC,MAEF,QACE,MAAM,IAAIE,MAAJ,sCAAyCH,IAInD,OAFArE,KAAKP,SACLO,KAAKwD,IAAMxD,KAAKiD,QACTjD,U,gCAIXtJ,EAAOD,QAAUuM,G,6BCjSjB,mLAMO,SAASyB,EAAaC,EAAqBC,GAChD,IACE,IAAMC,EAAsB,IAAoBD,GAEhD,OADqBE,KAAKC,MAA4B,IAApBJ,EAAQK,UACrBH,EACrB,MAAOI,GACP,OAAO,GAMJ,SAASC,EAAiBC,EAAwBC,GACvD,IACM1F,EAAS0F,GAJW,uBAM1B,OAHkB,IAAO5F,KAAK2F,GAEDzF,OAAOA,GAI/B,IAAM2F,EAAmB,SAACC,GAG/B,OAAO,IAAElK,KAFO,8BAEO,SAAAmK,GACrB,OAAO,IAAEC,MAAMF,GAAS,SAAApB,GACtB,OAAOA,EAAMqB,QAAUA,SAOtB,SAASE,EAAUC,EAAchK,GAkBxC,IACQ/C,EACAgN,EAEApF,EAIAqF,EASAC,EA/BN,OAHInK,GAASpE,OAAOwO,KAAKpK,GAAO7B,OAAS,IACvC6L,GAAQ,KAiBJ/M,EAAW,GACXgN,EAAW,QAEXpF,EAAU,SAACwF,GACf,MAA+C,mBAAxCzO,OAAOkB,UAAUwN,SAASjP,KAAKgP,IAGlCH,EAAM,SAACK,EAAWC,GACtBA,EAAiB,mBAANA,EAAmBA,IAAMA,QAAa,GAA4BA,EAE3EvN,EAAEA,EAAEkB,QADW,kBAANqM,EACKC,EAA8BF,GAAG,GAAQ,IAAME,EAA8BD,GAAG,GAEhFC,EAA8BF,GAAG,KAI7CJ,EAAc,SAACO,EAAgBL,GACnC,IAAInP,EAAGyP,EAAKlO,EAEZ,GAAIiO,EACF,GAAI7F,EAAQwF,GACV,IAAKnP,EAAI,EAAGyP,EAAMN,EAAIlM,OAAQjD,EAAIyP,EAAKzP,IACjC+O,EAASrL,KAAK8L,GAChBR,EAAIQ,EAAQL,EAAInP,IAEhBiP,EAAYO,EAAQL,EAAInP,SAGvB,GAAImP,GAAuB,oBAAhBO,OAAOP,GACvB,IAAK5N,KAAO4N,EACVF,EAAYO,EAAS,IAAMjO,EAAM,IAAK4N,EAAI5N,SAG5CyN,EAAIQ,EAAQL,QAET,GAAIxF,EAAQwF,GACjB,IAAKnP,EAAI,EAAGyP,EAAMN,EAAIlM,OAAQjD,EAAIyP,EAAKzP,IACrCgP,EAAIG,EAAInP,GAAGO,KAAM4O,EAAInP,GAAGiB,YAG1B,IAAKM,KAAO4N,EACVF,EAAY1N,EAAK4N,EAAI5N,IAGzB,OAAOQ,IAGU,GAhES+C,GAgEFuI,KAAK,OA9DxByB,EAGT,SAASS,EAA8BnE,EAAauE,GAClD,OAAOC,mBAAmBxE,GACvBlI,QAAQ,QAAS,SACjBA,QAAQ,QAAS,KACjBA,QAAQ,QAAS,KACjBA,QAAQ,OAAQ,KAChBA,QAAQ,QAAS,KACjBA,QAAQ,QAAS,KACjBA,QAAQ,OAAQyM,EAAkB,MAAQ,O,cCpD/C5P,EAAOD,QAAU+P,G,cCAjB9P,EAAOD,QAAUgQ,G,gBCAjB,IAAMzD,EAASL,EAAQ,IAIvBjM,EAAOD,QAHS,SAAC0J,EAAGiE,EAAGjB,GAAP,OACd,IAAIH,EAAO7C,EAAGgD,GAAOuD,QAAQ,IAAI1D,EAAOoB,EAAGjB,M,+ZCDvCwD,E,WACJ,WAAapJ,EAAO2F,GAAU,IAAD,OAQ3B,G,4FAR2B,SACtBA,GAA8B,WAAnB,EAAOA,KACrBA,EAAU,CACRC,QAASD,EACTE,mBAAmB,IAInB7F,aAAiBoJ,EACnB,OACEpJ,EAAM4F,UAAYD,EAAQC,OAC1B5F,EAAM6F,sBAAwBF,EAAQE,kBAE/B7F,EAEA,IAAIoJ,EAAMpJ,EAAMiG,IAAKN,GAIhC,GAAI3F,aAAiBqJ,EAKnB,OAHA5G,KAAKwD,IAAMjG,EAAM3F,MACjBoI,KAAK6G,IAAM,CAAC,CAACtJ,IACbyC,KAAKP,SACEO,KAkBT,GAfAA,KAAKkD,QAAUA,EACflD,KAAKmD,QAAUD,EAAQC,MACvBnD,KAAKoD,oBAAsBF,EAAQE,kBAGnCpD,KAAKwD,IAAMjG,EACXyC,KAAK6G,IAAMtJ,EACR1B,MAAM,cAENG,KAAI,SAAAuB,GAAK,OAAI,EAAKuJ,WAAWvJ,EAAMrB,WAInCpB,QAAO,SAAA9D,GAAC,OAAIA,EAAE4C,WAEZoG,KAAK6G,IAAIjN,OACZ,MAAM,IAAIyJ,UAAJ,gCAAuC9F,IAG/CyC,KAAKP,S,wDAUL,OANAO,KAAKzC,MAAQyC,KAAK6G,IACf7K,KAAI,SAAC+K,GACJ,OAAOA,EAAM/C,KAAK,KAAK9H,UAExB8H,KAAK,MACL9H,OACI8D,KAAKzC,Q,iCAIZ,OAAOyC,KAAKzC,Q,iCAGFA,GAAQ,IAAD,OACX4F,EAAQnD,KAAKkD,QAAQC,MAC3B5F,EAAQA,EAAMrB,OAEd,IAAM8K,EAAK7D,EAAQL,EAAGjL,EAAEoP,kBAAoBnE,EAAGjL,EAAEqP,aACjD3J,EAAQA,EAAM1D,QAAQmN,EAAIG,EAAcnH,KAAKkD,QAAQE,oBACrDV,EAAM,iBAAkBnF,GAExBA,EAAQA,EAAM1D,QAAQiJ,EAAGjL,EAAEuP,gBAAiBC,GAC5C3E,EAAM,kBAAmBnF,EAAOuF,EAAGjL,EAAEuP,iBASrC7J,GAHAA,GAHAA,EAAQA,EAAM1D,QAAQiJ,EAAGjL,EAAEyP,WAAYC,IAGzB1N,QAAQiJ,EAAGjL,EAAE2P,WAAYC,IAGzB5L,MAAM,OAAOmI,KAAK,KAKhC,IAAM0D,EAASvE,EAAQL,EAAGjL,EAAE8P,iBAAmB7E,EAAGjL,EAAE+P,YACpD,OAAOrK,EACJ1B,MAAM,KACNG,KAAI,SAAA6L,GAAI,OAAIC,EAAgBD,EAAM,EAAK3E,YACvCc,KAAK,KACLnI,MAAM,OACNG,KAAI,SAAA6L,GAAI,OAAIE,EAAYF,EAAM,EAAK3E,YAEnCpI,OAAOkF,KAAKkD,QAAQC,MAAQ,SAAA0E,GAAI,QAAMA,EAAKlN,MAAM+M,IAAU,kBAAM,IACjE1L,KAAI,SAAA6L,GAAI,OAAI,IAAIjB,EAAWiB,EAAM,EAAK3E,c,iCAG/B3F,EAAO2F,GACjB,KAAM3F,aAAiBoJ,GACrB,MAAM,IAAItD,UAAU,uBAGtB,OAAOrD,KAAK6G,IAAImB,MAAK,SAACC,GACpB,OACEC,EAAcD,EAAiB/E,IAC/B3F,EAAMsJ,IAAImB,MAAK,SAACG,GACd,OACED,EAAcC,EAAkBjF,IAChC+E,EAAgB1C,OAAM,SAAC6C,GACrB,OAAOD,EAAiB5C,OAAM,SAAC8C,GAC7B,OAAOD,EAAeE,WAAWD,EAAiBnF,iB,2BAU1DD,GACJ,IAAKA,EACH,OAAO,EAGT,GAAuB,iBAAZA,EACT,IACEA,EAAU,IAAID,EAAOC,EAASjD,KAAKkD,SACnC,MAAOqF,GACP,OAAO,EAIX,IAAK,IAAI5R,EAAI,EAAGA,EAAIqJ,KAAK6G,IAAIjN,OAAQjD,IACnC,GAAI6R,EAAQxI,KAAK6G,IAAIlQ,GAAIsM,EAASjD,KAAKkD,SACrC,OAAO,EAGX,OAAO,O,gCAGXxM,EAAOD,QAAUkQ,EAEjB,IAAMC,EAAajE,EAAQ,IACrBD,EAAQC,EAAQ,IAChBK,EAASL,EAAQ,I,EAOnBA,EAAQ,IALVG,E,EAAAA,GACAjL,E,EAAAA,EACAwP,E,EAAAA,sBACAE,E,EAAAA,iBACAE,E,EAAAA,iBAKIS,EAAgB,SAACO,EAAavF,GAKlC,IAJA,IAAInH,GAAS,EACP2M,EAAuBD,EAAYE,QACrCC,EAAiBF,EAAqBG,MAEnC9M,GAAU2M,EAAqB9O,QACpCmC,EAAS2M,EAAqBnD,OAAM,SAACuD,GACnC,OAAOF,EAAeN,WAAWQ,EAAiB5F,MAGpD0F,EAAiBF,EAAqBG,MAGxC,OAAO9M,GAMH+L,EAAkB,SAACD,EAAM3E,GAU7B,OATAR,EAAM,OAAQmF,EAAM3E,GACpB2E,EAAOkB,EAAclB,EAAM3E,GAC3BR,EAAM,QAASmF,GACfA,EAAOmB,EAAcnB,EAAM3E,GAC3BR,EAAM,SAAUmF,GAChBA,EAAOoB,EAAepB,EAAM3E,GAC5BR,EAAM,SAAUmF,GAChBA,EAAOqB,EAAarB,EAAM3E,GAC1BR,EAAM,QAASmF,GACRA,GAGHsB,EAAM,SAAAtF,GAAE,OAAKA,GAA2B,MAArBA,EAAGuF,eAAgC,MAAPvF,GAQ/CmF,EAAgB,SAACnB,EAAM3E,GAAP,OACpB2E,EAAK3L,OAAOL,MAAM,OAAOG,KAAI,SAAC6L,GAC5B,OAAOwB,EAAaxB,EAAM3E,MACzBc,KAAK,MAEJqF,EAAe,SAACxB,EAAM3E,GAC1B,IAAMzL,EAAIyL,EAAQC,MAAQL,EAAGjL,EAAEyR,YAAcxG,EAAGjL,EAAE0R,OAClD,OAAO1B,EAAKhO,QAAQpC,GAAG,SAAC+R,EAAGC,EAAG1S,EAAG0B,EAAGiR,GAElC,IAAIC,EAoBJ,OArBAjH,EAAM,QAASmF,EAAM2B,EAAGC,EAAG1S,EAAG0B,EAAGiR,GAG7BP,EAAIM,GACNE,EAAM,GACGR,EAAIpS,GACb4S,EAAM,KAAH,OAAQF,EAAR,kBAAmBA,EAAI,EAAvB,UACMN,EAAI1Q,GAEbkR,EAAM,KAAH,OAAQF,EAAR,YAAa1S,EAAb,eAAqB0S,EAArB,aAA2B1S,EAAI,EAA/B,QACM2S,GACThH,EAAM,kBAAmBgH,GACzBC,EAAM,KAAH,OAAQF,EAAR,YAAa1S,EAAb,YAAkB0B,EAAlB,YAAuBiR,EAAvB,aACED,EADF,aACQ1S,EAAI,EADZ,SAIH4S,EAAM,KAAH,OAAQF,EAAR,YAAa1S,EAAb,YAAkB0B,EAAlB,aACEgR,EADF,aACQ1S,EAAI,EADZ,QAIL2L,EAAM,eAAgBiH,GACfA,MAULZ,EAAgB,SAAClB,EAAM3E,GAAP,OACpB2E,EAAK3L,OAAOL,MAAM,OAAOG,KAAI,SAAC6L,GAC5B,OAAO+B,EAAa/B,EAAM3E,MACzBc,KAAK,MAEJ4F,EAAe,SAAC/B,EAAM3E,GAC1BR,EAAM,QAASmF,EAAM3E,GACrB,IAAMzL,EAAIyL,EAAQC,MAAQL,EAAGjL,EAAEgS,YAAc/G,EAAGjL,EAAEiS,OAC5CC,EAAI7G,EAAQE,kBAAoB,KAAO,GAC7C,OAAOyE,EAAKhO,QAAQpC,GAAG,SAAC+R,EAAGC,EAAG1S,EAAG0B,EAAGiR,GAElC,IAAIC,EA2CJ,OA5CAjH,EAAM,QAASmF,EAAM2B,EAAGC,EAAG1S,EAAG0B,EAAGiR,GAG7BP,EAAIM,GACNE,EAAM,GACGR,EAAIpS,GACb4S,EAAM,KAAH,OAAQF,EAAR,eAAgBM,EAAhB,cAAuBN,EAAI,EAA3B,UACMN,EAAI1Q,GAEXkR,EADQ,MAANF,EACI,KAAH,OAAQA,EAAR,YAAa1S,EAAb,aAAmBgT,EAAnB,aAAyBN,EAAzB,aAA+B1S,EAAI,EAAnC,QAEG,KAAH,OAAQ0S,EAAR,YAAa1S,EAAb,aAAmBgT,EAAnB,cAA0BN,EAAI,EAA9B,UAEIC,GACThH,EAAM,kBAAmBgH,GAGrBC,EAFM,MAANF,EACQ,MAAN1S,EACI,KAAH,OAAQ0S,EAAR,YAAa1S,EAAb,YAAkB0B,EAAlB,YAAuBiR,EAAvB,aACED,EADF,YACO1S,EADP,aACa0B,EAAI,EADjB,MAGG,KAAH,OAAQgR,EAAR,YAAa1S,EAAb,YAAkB0B,EAAlB,YAAuBiR,EAAvB,aACED,EADF,aACQ1S,EAAI,EADZ,QAIC,KAAH,OAAQ0S,EAAR,YAAa1S,EAAb,YAAkB0B,EAAlB,YAAuBiR,EAAvB,cACGD,EAAI,EADP,YAIL/G,EAAM,SAGFiH,EAFM,MAANF,EACQ,MAAN1S,EACI,KAAH,OAAQ0S,EAAR,YAAa1S,EAAb,YAAkB0B,GAAlB,OACAsR,EADA,aACMN,EADN,YACW1S,EADX,aACiB0B,EAAI,EADrB,MAGG,KAAH,OAAQgR,EAAR,YAAa1S,EAAb,YAAkB0B,GAAlB,OACAsR,EADA,aACMN,EADN,aACY1S,EAAI,EADhB,QAIC,KAAH,OAAQ0S,EAAR,YAAa1S,EAAb,YAAkB0B,EAAlB,cACGgR,EAAI,EADP,WAKP/G,EAAM,eAAgBiH,GACfA,MAILV,EAAiB,SAACpB,EAAM3E,GAE5B,OADAR,EAAM,iBAAkBmF,EAAM3E,GACvB2E,EAAKhM,MAAM,OAAOG,KAAI,SAAC6L,GAC5B,OAAOmC,EAAcnC,EAAM3E,MAC1Bc,KAAK,MAGJgG,EAAgB,SAACnC,EAAM3E,GAC3B2E,EAAOA,EAAK3L,OACZ,IAAMzE,EAAIyL,EAAQC,MAAQL,EAAGjL,EAAEoS,aAAenH,EAAGjL,EAAEqS,QACnD,OAAOrC,EAAKhO,QAAQpC,GAAG,SAACkS,EAAKQ,EAAMV,EAAG1S,EAAG0B,EAAGiR,GAC1ChH,EAAM,SAAUmF,EAAM8B,EAAKQ,EAAMV,EAAG1S,EAAG0B,EAAGiR,GAC1C,IAAMU,EAAKjB,EAAIM,GACTY,EAAKD,GAAMjB,EAAIpS,GACfuT,EAAKD,GAAMlB,EAAI1Q,GACf8R,EAAOD,EA8Db,MA5Da,MAATH,GAAgBI,IAClBJ,EAAO,IAKTT,EAAKxG,EAAQE,kBAAoB,KAAO,GAEpCgH,EAGAT,EAFW,MAATQ,GAAyB,MAATA,EAEZ,WAGA,IAECA,GAAQI,GAGbF,IACFtT,EAAI,GAEN0B,EAAI,EAES,MAAT0R,GAGFA,EAAO,KACHE,GACFZ,GAAKA,EAAI,EACT1S,EAAI,EACJ0B,EAAI,IAEJ1B,GAAKA,EAAI,EACT0B,EAAI,IAEY,OAAT0R,IAGTA,EAAO,IACHE,EACFZ,GAAKA,EAAI,EAET1S,GAAKA,EAAI,GAIA,MAAToT,IACFT,EAAK,MAEPC,EAAM,GAAH,OAAMQ,EAAOV,EAAb,YAAkB1S,EAAlB,YAAuB0B,GAAvB,OAA2BiR,IACrBW,EACTV,EAAM,KAAH,OAAQF,EAAR,eAAgBC,EAAhB,cAAwBD,EAAI,EAA5B,UACMa,IACTX,EAAM,KAAH,OAAQF,EAAR,YAAa1S,EAAb,aAAmB2S,EAAnB,aACED,EADF,aACQ1S,EAAI,EADZ,SAIL2L,EAAM,gBAAiBiH,GAEhBA,MAMLT,EAAe,SAACrB,EAAM3E,GAG1B,OAFAR,EAAM,eAAgBmF,EAAM3E,GAErB2E,EAAK3L,OAAOrC,QAAQiJ,EAAGjL,EAAE2S,MAAO,KAGnCzC,EAAc,SAACF,EAAM3E,GAEzB,OADAR,EAAM,cAAemF,EAAM3E,GACpB2E,EAAK3L,OACTrC,QAAQiJ,EAAGI,EAAQE,kBAAoBvL,EAAE4S,QAAU5S,EAAE6S,MAAO,KAQ3DvD,EAAgB,SAAAwD,GAAK,OAAI,SAACC,EAC9BjN,EAAMkN,EAAIC,EAAIC,EAAIC,EAAKC,EACvBxN,EAAIyN,EAAIC,EAAIC,EAAIC,EAAKC,GA2BrB,OAzBE3N,EADEwL,EAAI0B,GACC,GACE1B,EAAI2B,GACN,KAAH,OAAQD,EAAR,eAAiBF,EAAQ,KAAO,IAC3BxB,EAAI4B,GACN,KAAH,OAAQF,EAAR,YAAcC,EAAd,aAAqBH,EAAQ,KAAO,IAC/BK,EACF,KAAH,OAAQrN,GAEL,KAAH,OAAQA,GAAR,OAAegN,EAAQ,KAAO,IAIlClN,EADE0L,EAAI+B,GACD,GACI/B,EAAIgC,GACR,IAAH,QAAQD,EAAK,EAAb,UACO/B,EAAIiC,GACR,IAAH,OAAOF,EAAP,aAAcC,EAAK,EAAnB,QACOE,EACJ,KAAH,OAAQH,EAAR,YAAcC,EAAd,YAAoBC,EAApB,YAA0BC,GACnBV,EACJ,IAAH,OAAOO,EAAP,YAAaC,EAAb,aAAoBC,EAAK,EAAzB,MAEG,KAAH,OAAQ3N,GAGL,UAAIE,EAAJ,YAAYF,GAAMvB,SAGrBsM,EAAU,SAAC3B,EAAK5D,EAASC,GAC7B,IAAK,IAAIvM,EAAI,EAAGA,EAAIkQ,EAAIjN,OAAQjD,IAC9B,IAAKkQ,EAAIlQ,GAAG0D,KAAK4I,GACf,OAAO,EAIX,GAAIA,EAAQW,WAAWhK,SAAWsJ,EAAQE,kBAAmB,CAM3D,IAAK,IAAIzM,EAAI,EAAGA,EAAIkQ,EAAIjN,OAAQjD,IAE9B,GADA+L,EAAMmE,EAAIlQ,GAAG4U,QACT1E,EAAIlQ,GAAG4U,SAAW3E,EAAW4E,KAI7B3E,EAAIlQ,GAAG4U,OAAO3H,WAAWhK,OAAS,EAAG,CACvC,IAAM6R,EAAU5E,EAAIlQ,GAAG4U,OACvB,GAAIE,EAAQhI,QAAUR,EAAQQ,OAC1BgI,EAAQ/H,QAAUT,EAAQS,OAC1B+H,EAAQ9H,QAAUV,EAAQU,MAC5B,OAAO,EAMb,OAAO,EAGT,OAAO,I,cC7cTjN,EAAOD,QAAUiV,G,eCAjBhV,EAAOD,QAAUkV,G,mVCKJC,EAAyB,EAoB/B,SAASC,EAAmBC,G,MACjC,GAgIF,SAAsBA,GACpB,OAAQA,EAAMC,aAAeD,EAAME,cAAgBF,EAAMG,WAGnCC,EAH8DJ,EAAMI,SAIlFA,GAAY,IAAE5L,QAAQ4L,KAAgC,IAAnBA,EAAQtS,QAAmC,IAAnBsS,EAAQtS,QAAgB,IAAEuS,QAAQD,EAAQ,MAD/G,IAAwBA,EApIlBE,CAAaN,GAEf,cADOA,EAAMI,QACNJ,EAGT,IAAMO,EAuHR,SAA0BP,GACxB,OAAOA,EAAMO,eAAiB,EAxHRC,CAAiBR,GAmCvC,GAhCIO,EAAgB,IAClBP,EAAME,YAAc,CAACF,EAAMC,YAC3BD,EAAMI,QAAU,GAChBJ,EAAMI,QAAQJ,EAAME,YAAY,IAAMF,EAAMG,gBAGrCH,EAAMG,gBACNH,EAAMC,YAGXM,EAAgB,WAEXP,EAAMS,uBACNT,EAAMU,iBACNV,EAAMW,cACNX,EAAMY,wBAGXL,EAAgB,GACdP,EAAMI,UAAY,IAAEC,QAAQL,EAAMI,UACpC,IAAEtQ,KAAKkQ,EAAMI,SAAS,SAACS,GA/CG,IAACT,EAgDzB,IAAEU,aAAaD,EA/Cd,CACLhQ,MAAO,CAAC7B,OAAQ,IAChB8B,KAAM,CAAC9B,OAAQ,IACf+B,YAAa,CAAC/B,OAAQ,IACtB+R,QAAS,CAAC/R,OAAQ,IAClB+F,KAAM,CAAC/F,OAAQ,IACfgS,MAAO,CAAChS,OAAQ,IAChBwK,MAAO,YAAiB4G,QA6CtBG,EAAgB,GACdP,EAAMiB,YAAyC,MAA3BjB,EAAMiB,WAAWnV,QACvCkU,EAAMiB,WAAWnV,MAAQ,GAIzByU,EAAgB,EAAG,CACrB,IAAMW,EAAiB,GACvB,IAAK,IAAMC,KAAanB,EAAMI,QAAS,CAEhCgB,EADCP,EAASb,EAAMI,QAAQe,KACEE,EAAgBR,EAAQM,IACrDD,EAAerT,KAAK,EAAD,KACdgT,GAAM,CACTZ,WAAYkB,KAIlB,IAAqB,UAAAD,EAAA,eAAgB,EAA1BL,EAAM,MACHrH,QACVqH,EAAOrH,MAAQ,YAAiB0H,IAGpClB,EAAMI,QAAUc,SACTlB,EAAME,YAGf,GAAIK,EAAgB,EAAG,CACQ,IAAzBP,EAAMI,QAAQtS,OACZkS,EAAMI,QAAQ,GAAGH,aACnBD,EAAMC,WAAaD,EAAMI,QAAQ,GAAGH,kBAC7BD,EAAMI,QAAQ,GAAGH,YAEjBD,EAAMI,QAAQtS,OAAS,IAEhCkS,EAAMC,WAAa,eAErB,IAAqB,UAAAD,EAAMI,QAAN,eAAe,CAA/B,IAAMS,KAAM,MAERjR,UAAY,EACnBiR,EAAOS,aAAeC,EAAkBvB,GACxCa,EAAOzJ,QAAUoK,EAAexB,GAEhC,IAAEyB,SAASZ,EAAOzJ,QAlFf,CACLsK,oBAAoB,IAkFlB,IAAED,SAASZ,EAAQ,CAAE9L,KAAM,CAAE/F,OAAQ,MAGvCgR,EAAM2B,aAA+C,cAAZ,QAApB,EAAA3B,EAAM4B,sBAAc,eAAE9V,OAAuB,WAAa,oBAExEkU,EAAMiB,kBACNjB,EAAM6B,oBACN7B,EAAM0B,0BACN1B,EAAM4B,eAGf,OAAO5B,EAGT,SAASwB,EAAexB,G,MAClB8B,EAAe,EACQ,iBAAvB9B,EAAM6B,aACRC,EAAe,EACiB,mBAAvB9B,EAAM6B,eACfC,EAAe,GAIjB,IAAIC,EAAQ,KAKZ,OAJI/B,EAAM+B,OAAyB,MAAhB/B,EAAM+B,QACvBA,EAAQ/B,EAAM+B,OAGT,CACLL,mBAAoB1B,EAAM0B,mBAC1BC,aAA8C,cAAZ,QAApB,EAAA3B,EAAM4B,sBAAc,eAAE9V,OAAuB,WAAa,UACxEkW,YAAa,EACbF,aAAcA,EACdC,MAAOA,GAIX,SAASR,EAAkBvB,G,YACzB,OAAgC,KAAZ,QAAhB,EAAAA,EAAMiB,kBAAU,eAAEnV,OACb,IAAiBmW,SACa,KAAZ,QAAhB,EAAAjC,EAAMiB,kBAAU,eAAEnV,SAAsC,QAAvB,EAAgB,QAAhB,EAAAkU,EAAMiB,kBAAU,eAAEnV,aAAK,eAAEgC,QAAS,EACrE,IAAiBoU,QAEjB,IAAiBD,SAgB5B,SAASb,EAAcP,GACrB,OAAQA,KAAYA,EAAOhQ,OAASgQ,EAAO/P,MAAQ+P,EAAO9P,aAAe8P,EAAOE,SAGlF,SAASM,EAAgBR,EAAQM,GAC/B,OAAON,GAA2B,MAAjBA,EAAOrH,OAA+B,MAAd2H,I,oBCvKnCgB,EAA8BtL,EAAQ,IAAtCsL,0BACFvL,EAAQC,EAAQ,IAIhBG,GAHNrM,EAAUC,EAAOD,QAAU,IAGRqM,GAAK,GAClBoL,EAAMzX,EAAQyX,IAAM,GACpBrW,EAAIpB,EAAQoB,EAAI,GAClBsW,EAAI,EAEFC,EAAc,SAAClX,EAAMU,EAAOyW,GAChC,IAAMC,EAAQH,IACdzL,EAAM4L,EAAO1W,GACbC,EAAEX,GAAQoX,EACVJ,EAAII,GAAS1W,EACbkL,EAAGwL,GAAS,IAAIhT,OAAO1D,EAAOyW,EAAW,SAAM3P,IASjD0P,EAAY,oBAAqB,eACjCA,EAAY,yBAA0B,UAMtCA,EAAY,uBAAwB,8BAKpCA,EAAY,cAAe,WAAIF,EAAIrW,EAAE0W,mBAAV,mBACJL,EAAIrW,EAAE0W,mBADF,mBAEJL,EAAIrW,EAAE0W,mBAFF,MAI3BH,EAAY,mBAAoB,WAAIF,EAAIrW,EAAE2W,wBAAV,mBACJN,EAAIrW,EAAE2W,wBADF,mBAEJN,EAAIrW,EAAE2W,wBAFF,MAOhCJ,EAAY,uBAAD,aAA+BF,EAAIrW,EAAE0W,mBAArC,YACPL,EAAIrW,EAAE4W,sBADC,MAGXL,EAAY,4BAAD,aAAoCF,EAAIrW,EAAE2W,wBAA1C,YACPN,EAAIrW,EAAE4W,sBADC,MAOXL,EAAY,aAAD,eAAuBF,EAAIrW,EAAE6W,sBAA7B,iBACFR,EAAIrW,EAAE6W,sBADJ,SAGXN,EAAY,kBAAD,gBAA6BF,EAAIrW,EAAE8W,2BAAnC,iBACFT,EAAIrW,EAAE8W,2BADJ,SAMXP,EAAY,kBAAmB,iBAM/BA,EAAY,QAAD,iBAAoBF,EAAIrW,EAAE+W,iBAA1B,iBACFV,EAAIrW,EAAE+W,iBADJ,SAYXR,EAAY,YAAD,YAAmBF,EAAIrW,EAAEgX,cAAzB,OACRX,EAAIrW,EAAEiX,YADE,YAETZ,EAAIrW,EAAEkX,OAFG,MAIXX,EAAY,OAAD,WAAaF,EAAIrW,EAAEmX,WAAnB,MAKXZ,EAAY,aAAD,kBAA0BF,EAAIrW,EAAEoX,mBAAhC,OACRf,EAAIrW,EAAEqX,iBADE,YAEThB,EAAIrW,EAAEkX,OAFG,MAIXX,EAAY,QAAD,WAAcF,EAAIrW,EAAEsX,YAApB,MAEXf,EAAY,OAAQ,gBAKpBA,EAAY,wBAAD,UAA6BF,EAAIrW,EAAE2W,wBAAnC,aACXJ,EAAY,mBAAD,UAAwBF,EAAIrW,EAAE0W,mBAA9B,aAEXH,EAAY,cAAe,mBAAYF,EAAIrW,EAAEuX,kBAAlB,sBACElB,EAAIrW,EAAEuX,kBADR,sBAEElB,EAAIrW,EAAEuX,kBAFR,kBAGFlB,EAAIrW,EAAEiX,YAHJ,aAINZ,EAAIrW,EAAEkX,OAJA,aAO3BX,EAAY,mBAAoB,mBAAYF,EAAIrW,EAAEwX,uBAAlB,sBACEnB,EAAIrW,EAAEwX,uBADR,sBAEEnB,EAAIrW,EAAEwX,uBAFR,kBAGFnB,EAAIrW,EAAEqX,iBAHJ,aAINhB,EAAIrW,EAAEkX,OAJA,aAOhCX,EAAY,SAAD,WAAeF,EAAIrW,EAAEyX,MAArB,eAAiCpB,EAAIrW,EAAE0X,aAAvC,MACXnB,EAAY,cAAD,WAAoBF,EAAIrW,EAAEyX,MAA1B,eAAsCpB,EAAIrW,EAAE2X,kBAA5C,MAIXpB,EAAY,SAAU,UAAG,qBAAH,OACIH,EADJ,6BAEQA,EAFR,+BAGQA,EAHR,wBAKtBG,EAAY,YAAaF,EAAIrW,EAAE4X,SAAS,GAIxCrB,EAAY,YAAa,WAEzBA,EAAY,YAAD,gBAAuBF,EAAIrW,EAAE6X,WAA7B,SAA+C,GAC1DjZ,EAAQ8Q,iBAAmB,MAE3B6G,EAAY,QAAD,WAAcF,EAAIrW,EAAE6X,YAApB,OAAiCxB,EAAIrW,EAAE0X,aAAvC,MACXnB,EAAY,aAAD,WAAmBF,EAAIrW,EAAE6X,YAAzB,OAAsCxB,EAAIrW,EAAE2X,kBAA5C,MAIXpB,EAAY,YAAa,WAEzBA,EAAY,YAAD,gBAAuBF,EAAIrW,EAAE8X,WAA7B,SAA+C,GAC1DlZ,EAAQgR,iBAAmB,MAE3B2G,EAAY,QAAD,WAAcF,EAAIrW,EAAE8X,YAApB,OAAiCzB,EAAIrW,EAAE0X,aAAvC,MACXnB,EAAY,aAAD,WAAmBF,EAAIrW,EAAE8X,YAAzB,OAAsCzB,EAAIrW,EAAE2X,kBAA5C,MAGXpB,EAAY,kBAAD,WAAwBF,EAAIrW,EAAEyX,MAA9B,gBAA2CpB,EAAIrW,EAAEsX,YAAjD,UACXf,EAAY,aAAD,WAAmBF,EAAIrW,EAAEyX,MAAzB,gBAAsCpB,EAAIrW,EAAEmX,WAA5C,UAIXZ,EAAY,iBAAD,gBAA4BF,EAAIrW,EAAEyX,MAAlC,gBACHpB,EAAIrW,EAAEsX,YADH,YACkBjB,EAAIrW,EAAE0X,aADxB,MACyC,GACpD9Y,EAAQ4Q,sBAAwB,SAMhC+G,EAAY,cAAe,gBAASF,EAAIrW,EAAE0X,aAAf,4BAEJrB,EAAIrW,EAAE0X,aAFF,cAK3BnB,EAAY,mBAAoB,gBAASF,EAAIrW,EAAE2X,kBAAf,4BAEJtB,EAAIrW,EAAE2X,kBAFF,cAMhCpB,EAAY,OAAQ,mBAEpBA,EAAY,OAAQ,yBACpBA,EAAY,UAAW,4B,yPCrLhBxL,EAAcD,EAAQ,IAAtBC,W,EACWD,EAAQ,IAAlBG,E,EAAAA,GAAIjL,E,EAAAA,EACNmL,EAASL,EAAQ,IAkCvBjM,EAAOD,QAhCO,SAACwM,EAASC,GAQtB,GAPKA,GAA8B,WAAnB,EAAOA,KACrBA,EAAU,CACRC,QAASD,EACTE,mBAAmB,IAInBH,aAAmBD,EACrB,OAAOC,EAGT,GAAuB,iBAAZA,EACT,OAAO,KAGT,GAAIA,EAAQrJ,OAASgJ,EACnB,OAAO,KAIT,KADUM,EAAQC,MAAQL,EAAGjL,EAAEyL,OAASR,EAAGjL,EAAE0L,OACtClJ,KAAK4I,GACV,OAAO,KAGT,IACE,OAAO,IAAID,EAAOC,EAASC,GAC3B,MAAOqF,GACP,OAAO,Q,eC9BX,IAGM1F,EAAmB5D,OAAO4D,kBACH,iBAK7BnM,EAAOD,QAAU,CACfmZ,oBAV0B,QAW1BhN,WATiB,IAUjBC,mBACAoL,0BANgC,K,mPCTlC,IAAMvL,EACe,YAAnB,oBAAOmN,QAAP,cAAOA,WACPA,QAAQC,KACRD,QAAQC,IAAIC,YACZ,cAAc1V,KAAKwV,QAAQC,IAAIC,YAC7B,wCAAIC,EAAJ,yBAAIA,EAAJ,uBAAa,EAAAC,SAAQC,MAAR,SAAc,UAAd,OAA2BF,KACxC,aAEJtZ,EAAOD,QAAUiM,G,gBCRjB,IAAMgE,EAAU/D,EAAQ,IAExBjM,EAAOD,QADI,SAAC0J,EAAGiE,EAAGjB,GAAP,OAAiBuD,EAAQvG,EAAGiE,EAAGjB,GAAS,I,odCDnD,IAAMqI,EAAM9T,OAAO,cAEbkP,E,WAIJ,WAAaiB,EAAM3E,GAQjB,G,4FAR2B,CAAD,QACrBA,GAA8B,WAAnB,EAAOA,KACrBA,EAAU,CACRC,QAASD,EACTE,mBAAmB,IAInByE,aAAgBjB,EAAY,CAC9B,GAAIiB,EAAK1E,UAAYD,EAAQC,MAC3B,OAAO0E,EAEPA,EAAOA,EAAKjQ,MAIhB8K,EAAM,aAAcmF,EAAM3E,GAC1BlD,KAAKkD,QAAUA,EACflD,KAAKmD,QAAUD,EAAQC,MACvBnD,KAAKmQ,MAAMtI,GAEP7H,KAAKuL,SAAWC,EAClBxL,KAAKpI,MAAQ,GAEboI,KAAKpI,MAAQoI,KAAKoQ,SAAWpQ,KAAKuL,OAAOtI,QAG3CP,EAAM,OAAQ1C,M,2CA7Bd,OAAOwL,M,iCAgCF3D,GACL,IAAMpQ,EAAIuI,KAAKkD,QAAQC,MAAQL,EAAGjL,EAAE8P,iBAAmB7E,EAAGjL,EAAE+P,YACtD7Q,EAAI8Q,EAAKlN,MAAMlD,GAErB,IAAKV,EACH,MAAM,IAAIsM,UAAJ,8BAAqCwE,IAG7C7H,KAAKoQ,cAAoB1R,IAAT3H,EAAE,GAAmBA,EAAE,GAAK,GACtB,MAAlBiJ,KAAKoQ,WACPpQ,KAAKoQ,SAAW,IAIbrZ,EAAE,GAGLiJ,KAAKuL,OAAS,IAAIvI,EAAOjM,EAAE,GAAIiJ,KAAKkD,QAAQC,OAF5CnD,KAAKuL,OAASC,I,iCAOhB,OAAOxL,KAAKpI,Q,2BAGRqL,GAGJ,GAFAP,EAAM,kBAAmBO,EAASjD,KAAKkD,QAAQC,OAE3CnD,KAAKuL,SAAWC,GAAOvI,IAAYuI,EACrC,OAAO,EAGT,GAAuB,iBAAZvI,EACT,IACEA,EAAU,IAAID,EAAOC,EAASjD,KAAKkD,SACnC,MAAOqF,GACP,OAAO,EAIX,OAAO8H,EAAIpN,EAASjD,KAAKoQ,SAAUpQ,KAAKuL,OAAQvL,KAAKkD,W,iCAG3C2E,EAAM3E,GAChB,KAAM2E,aAAgBjB,GACpB,MAAM,IAAIvD,UAAU,4BAUtB,GAPKH,GAA8B,WAAnB,EAAOA,KACrBA,EAAU,CACRC,QAASD,EACTE,mBAAmB,IAID,KAAlBpD,KAAKoQ,SACP,MAAmB,KAAfpQ,KAAKpI,OAGF,IAAI+O,EAAMkB,EAAKjQ,MAAOsL,GAAS7I,KAAK2F,KAAKpI,OAC3C,GAAsB,KAAlBiQ,EAAKuI,SACd,MAAmB,KAAfvI,EAAKjQ,OAGF,IAAI+O,EAAM3G,KAAKpI,MAAOsL,GAAS7I,KAAKwN,EAAK0D,QAGlD,IAAM+E,IACe,OAAlBtQ,KAAKoQ,UAAuC,MAAlBpQ,KAAKoQ,UACb,OAAlBvI,EAAKuI,UAAuC,MAAlBvI,EAAKuI,UAC5BG,IACe,OAAlBvQ,KAAKoQ,UAAuC,MAAlBpQ,KAAKoQ,UACb,OAAlBvI,EAAKuI,UAAuC,MAAlBvI,EAAKuI,UAC5BI,EAAaxQ,KAAKuL,OAAOtI,UAAY4E,EAAK0D,OAAOtI,QACjDwN,IACe,OAAlBzQ,KAAKoQ,UAAuC,OAAlBpQ,KAAKoQ,UACb,OAAlBvI,EAAKuI,UAAuC,OAAlBvI,EAAKuI,UAC5BM,EACJL,EAAIrQ,KAAKuL,OAAQ,IAAK1D,EAAK0D,OAAQrI,KAChB,OAAlBlD,KAAKoQ,UAAuC,MAAlBpQ,KAAKoQ,YACX,OAAlBvI,EAAKuI,UAAuC,MAAlBvI,EAAKuI,UAC9BO,EACJN,EAAIrQ,KAAKuL,OAAQ,IAAK1D,EAAK0D,OAAQrI,KAChB,OAAlBlD,KAAKoQ,UAAuC,MAAlBpQ,KAAKoQ,YACX,OAAlBvI,EAAKuI,UAAuC,MAAlBvI,EAAKuI,UAEpC,OACEE,GACAC,GACCC,GAAcC,GACfC,GACAC,M,KAKNja,EAAOD,QAAUmQ,E,MAEDjE,EAAQ,IAAjBG,E,EAAAA,GAAIjL,E,EAAAA,EACLwY,EAAM1N,EAAQ,IACdD,EAAQC,EAAQ,IAChBK,EAASL,EAAQ,IACjBgE,EAAQhE,EAAQ,K,gBC1ItB,IAAMgE,EAAQhE,EAAQ,IAStBjM,EAAOD,QARW,SAACwM,EAAS1F,EAAO2F,GACjC,IACE3F,EAAQ,IAAIoJ,EAAMpJ,EAAO2F,GACzB,MAAOqF,GACP,OAAO,EAET,OAAOhL,EAAMlD,KAAK4I,K,cCPpBvM,EAAOD,QAAUma,G,cCAjB,IAAMC,EAAU,WACV9N,EAAqB,SAAC5C,EAAGiE,GAC7B,IAAM0M,EAAOD,EAAQxW,KAAK8F,GACpB4Q,EAAOF,EAAQxW,KAAK+J,GAO1B,OALI0M,GAAQC,IACV5Q,GAAKA,EACLiE,GAAKA,GAGAjE,IAAMiE,EAAI,EACZ0M,IAASC,GAAS,EAClBA,IAASD,EAAQ,EAClB3Q,EAAIiE,GAAK,EACT,GAKN1N,EAAOD,QAAU,CACfsM,qBACAiO,oBAJ0B,SAAC7Q,EAAGiE,GAAJ,OAAUrB,EAAmBqB,EAAGjE,M,gBCjB5D,IAAMuG,EAAU/D,EAAQ,IAExBjM,EAAOD,QADI,SAAC0J,EAAGiE,EAAGjB,GAAP,OAA0C,IAAzBuD,EAAQvG,EAAGiE,EAAGjB,K,gBCD1C,IAAMH,EAASL,EAAQ,IAMvBjM,EAAOD,QALc,SAAC0J,EAAGiE,EAAGjB,GAC1B,IAAM8N,EAAW,IAAIjO,EAAO7C,EAAGgD,GACzB+N,EAAW,IAAIlO,EAAOoB,EAAGjB,GAC/B,OAAO8N,EAASvK,QAAQwK,IAAaD,EAASE,aAAaD,K,gBCJ7D,IAAMxK,EAAU/D,EAAQ,IAExBjM,EAAOD,QADI,SAAC0J,EAAGiE,EAAGjB,GAAP,OAAiBuD,EAAQvG,EAAGiE,EAAGjB,GAAS,I,gBCDnD,IAAMuD,EAAU/D,EAAQ,IAExBjM,EAAOD,QADK,SAAC0J,EAAGiE,EAAGjB,GAAP,OAAiBuD,EAAQvG,EAAGiE,EAAGjB,IAAU,I,gBCDrD,IAAMuD,EAAU/D,EAAQ,IAExBjM,EAAOD,QADK,SAAC0J,EAAGiE,EAAGjB,GAAP,OAAiBuD,EAAQvG,EAAGiE,EAAGjB,IAAU,I,qPCDrD,IAAMH,EAASL,EAAQ,IACjBiE,EAAajE,EAAQ,IACpB6I,EAAO5E,EAAP4E,IACD7E,EAAQhE,EAAQ,IAChByO,EAAYzO,EAAQ,IACpB0O,EAAK1O,EAAQ,IACb2O,EAAK3O,EAAQ,IACb4O,EAAM5O,EAAQ,IACd6O,EAAM7O,EAAQ,IAuEpBjM,EAAOD,QArES,SAACwM,EAAS1F,EAAOkU,EAAMvO,GAIrC,IAAIwO,EAAMC,EAAOC,EAAM/J,EAAMgK,EAC7B,OAJA5O,EAAU,IAAID,EAAOC,EAASC,GAC9B3F,EAAQ,IAAIoJ,EAAMpJ,EAAO2F,GAGjBuO,GACN,IAAK,IACHC,EAAOL,EACPM,EAAQJ,EACRK,EAAON,EACPzJ,EAAO,IACPgK,EAAQ,KACR,MACF,IAAK,IACHH,EAAOJ,EACPK,EAAQH,EACRI,EAAOP,EACPxJ,EAAO,IACPgK,EAAQ,KACR,MACF,QACE,MAAM,IAAIxO,UAAU,yCAIxB,GAAI+N,EAAUnO,EAAS1F,EAAO2F,GAC5B,OAAO,EAMT,IAhCiD,eAgCxCvM,GACP,IAAM8R,EAAclL,EAAMsJ,IAAIlQ,GAE1Bmb,EAAO,KACPC,EAAM,KAiBV,OAfAtJ,EAAYhP,SAAQ,SAACuY,GACfA,EAAWzG,SAAWC,IACxBwG,EAAa,IAAIpL,EAAW,YAE9BkL,EAAOA,GAAQE,EACfD,EAAMA,GAAOC,EACTN,EAAKM,EAAWzG,OAAQuG,EAAKvG,OAAQrI,GACvC4O,EAAOE,EACEJ,EAAKI,EAAWzG,OAAQwG,EAAIxG,OAAQrI,KAC7C6O,EAAMC,MAMNF,EAAK1B,WAAavI,GAAQiK,EAAK1B,WAAayB,EAC9C,IAAO,GAKHE,EAAI3B,UAAY2B,EAAI3B,WAAavI,IACnC8J,EAAM1O,EAAS8O,EAAIxG,QAEZwG,EAAI3B,WAAayB,GAASD,EAAK3O,EAAS8O,EAAIxG,QACrD,IAAO,QADF,EADL,IAAO,IA7BF5U,EAAI,EAAGA,EAAI4G,EAAMsJ,IAAIjN,SAAUjD,EAAG,CAAC,IAAD,IAAlCA,GAAkC,8BAkC3C,OAAO,I,cC5ETD,EAAOD,QAAUwb,G,cCAjBvb,EAAOD,QAAUyb,G,gBCAjB,IAAMxL,EAAU/D,EAAQ,IAExBjM,EAAOD,QADK,SAAC0J,EAAGiE,EAAGjB,GAAP,OAA0C,IAAzBuD,EAAQvG,EAAGiE,EAAGjB,K,qPCD3C,IAAMgP,EAAKxP,EAAQ,IACbyP,EAAMzP,EAAQ,IACd0O,EAAK1O,EAAQ,IACb6O,EAAM7O,EAAQ,IACd2O,EAAK3O,EAAQ,IACb4O,EAAM5O,EAAQ,IA0CpBjM,EAAOD,QAxCK,SAAC0J,EAAGkS,EAAIjO,EAAGjB,GACrB,OAAQkP,GACN,IAAK,MAKH,MAJiB,WAAb,EAAOlS,KACTA,EAAIA,EAAE8C,SACS,WAAb,EAAOmB,KACTA,EAAIA,EAAEnB,SACD9C,IAAMiE,EAEf,IAAK,MAKH,MAJiB,WAAb,EAAOjE,KACTA,EAAIA,EAAE8C,SACS,WAAb,EAAOmB,KACTA,EAAIA,EAAEnB,SACD9C,IAAMiE,EAEf,IAAK,GACL,IAAK,IACL,IAAK,KACH,OAAO+N,EAAGhS,EAAGiE,EAAGjB,GAElB,IAAK,KACH,OAAOiP,EAAIjS,EAAGiE,EAAGjB,GAEnB,IAAK,IACH,OAAOkO,EAAGlR,EAAGiE,EAAGjB,GAElB,IAAK,KACH,OAAOqO,EAAIrR,EAAGiE,EAAGjB,GAEnB,IAAK,IACH,OAAOmO,EAAGnR,EAAGiE,EAAGjB,GAElB,IAAK,KACH,OAAOoO,EAAIpR,EAAGiE,EAAGjB,GAEnB,QACE,MAAM,IAAIE,UAAJ,4BAAmCgP,O,eC5C/C3b,EAAOD,QAAU6b,G,gBCCjB,IAAMC,EAAa5P,EAAQ,IAC3BjM,EAAOD,QAAU,CACfqM,GAAIyP,EAAWzP,GACfoL,IAAKqE,EAAWrE,IAChBsE,OAAQD,EAAW1a,EACnB+X,oBAAqBjN,EAAQ,IAAwBiN,oBACrD5M,OAAQL,EAAQ,IAChBI,mBAAoBJ,EAAQ,IAA0BI,mBACtDiO,oBAAqBrO,EAAQ,IAA0BqO,oBACvDb,MAAOxN,EAAQ,IACf8P,MAAO9P,EAAQ,IACf+P,MAAO/P,EAAQ,IACf4B,IAAK5B,EAAQ,IACbjF,KAAMiF,EAAQ,IACdc,MAAOd,EAAQ,IACfe,MAAOf,EAAQ,IACfgB,MAAOhB,EAAQ,IACfiB,WAAYjB,EAAQ,IACpB+D,QAAS/D,EAAQ,IACjBgQ,SAAUhQ,EAAQ,IAClBiQ,aAAcjQ,EAAQ,IACtBwO,aAAcxO,EAAQ,IACtBkQ,KAAMlQ,EAAQ,IACdmQ,MAAOnQ,EAAQ,IACf0O,GAAI1O,EAAQ,IACZ2O,GAAI3O,EAAQ,IACZwP,GAAIxP,EAAQ,IACZyP,IAAKzP,EAAQ,IACb6O,IAAK7O,EAAQ,IACb4O,IAAK5O,EAAQ,IACb0N,IAAK1N,EAAQ,IACboQ,OAAQpQ,EAAQ,IAChBiE,WAAYjE,EAAQ,IACpBgE,MAAOhE,EAAQ,IACfyO,UAAWzO,EAAQ,IACnBqQ,cAAerQ,EAAQ,IACvBsQ,cAAetQ,EAAQ,IACvBuQ,cAAevQ,EAAQ,IACvBwQ,WAAYxQ,EAAQ,IACpByQ,WAAYzQ,EAAQ,IACpB0Q,QAAS1Q,EAAQ,IACjB2Q,IAAK3Q,EAAQ,IACb4Q,IAAK5Q,EAAQ,IACb2F,WAAY3F,EAAQ,IACpB6Q,cAAe7Q,EAAQ,IACvB8Q,OAAQ9Q,EAAQ,M,cC9ClBjM,EAAOD,QAAUid,G,mBCAjB,IAAMvD,EAAQxN,EAAQ,IAKtBjM,EAAOD,QAJO,SAACwM,EAASC,GACtB,IAAM+C,EAAIkK,EAAMlN,EAASC,GACzB,OAAO+C,EAAIA,EAAEhD,QAAU,O,gBCHzB,IAAMkN,EAAQxN,EAAQ,IAKtBjM,EAAOD,QAJO,SAACwM,EAASC,GACtB,IAAMxK,EAAIyX,EAAMlN,EAAQ/G,OAAOrC,QAAQ,SAAU,IAAKqJ,GACtD,OAAOxK,EAAIA,EAAEuK,QAAU,O,gBCHzB,IAAMD,EAASL,EAAQ,IAcvBjM,EAAOD,QAZK,SAACwM,EAASoB,EAASnB,EAASoB,GACb,iBAAbpB,IACVoB,EAAapB,EACbA,OAAUxE,GAGZ,IACE,OAAO,IAAIsE,EAAOC,EAASC,GAASqB,IAAIF,EAASC,GAAYrB,QAC7D,MAAOsF,GACP,OAAO,Q,gBCXX,IAAM4H,EAAQxN,EAAQ,IAChBwP,EAAKxP,EAAQ,IAqBnBjM,EAAOD,QAnBM,SAACkd,EAAUC,GACtB,GAAIzB,EAAGwB,EAAUC,GACf,OAAO,KAEP,IAAMC,EAAK1D,EAAMwD,GACXG,EAAK3D,EAAMyD,GACXG,EAASF,EAAGjQ,WAAWhK,QAAUka,EAAGlQ,WAAWhK,OAC/CuM,EAAS4N,EAAS,MAAQ,GAC1BC,EAAgBD,EAAS,aAAe,GAC9C,IAAK,IAAM7b,KAAO2b,EAChB,IAAY,UAAR3b,GAA2B,UAARA,GAA2B,UAARA,IACpC2b,EAAG3b,KAAS4b,EAAG5b,GACjB,OAAOiO,EAASjO,EAItB,OAAO8b,I,gBCnBX,IAAMhR,EAASL,EAAQ,IAEvBjM,EAAOD,QADO,SAAC0J,EAAGgD,GAAJ,OAAc,IAAIH,EAAO7C,EAAGgD,GAAOM,Q,gBCDjD,IAAMT,EAASL,EAAQ,IAEvBjM,EAAOD,QADO,SAAC0J,EAAGgD,GAAJ,OAAc,IAAIH,EAAO7C,EAAGgD,GAAOO,Q,gBCDjD,IAAMV,EAASL,EAAQ,IAEvBjM,EAAOD,QADO,SAAC0J,EAAGgD,GAAJ,OAAc,IAAIH,EAAO7C,EAAGgD,GAAOQ,Q,gBCDjD,IAAMwM,EAAQxN,EAAQ,IAKtBjM,EAAOD,QAJY,SAACwM,EAASC,GAC3B,IAAM+Q,EAAS9D,EAAMlN,EAASC,GAC9B,OAAQ+Q,GAAUA,EAAOrQ,WAAWhK,OAAUqa,EAAOrQ,WAAa,O,gBCHpE,IAAM8C,EAAU/D,EAAQ,IAExBjM,EAAOD,QADU,SAAC0J,EAAGiE,EAAGjB,GAAP,OAAiBuD,EAAQtC,EAAGjE,EAAGgD,K,gBCDhD,IAAMuD,EAAU/D,EAAQ,IAExBjM,EAAOD,QADc,SAAC0J,EAAGiE,GAAJ,OAAUsC,EAAQvG,EAAGiE,GAAG,K,gBCD7C,IAAM+M,EAAexO,EAAQ,IAE7BjM,EAAOD,QADM,SAACyd,EAAM/Q,GAAP,OAAiB+Q,EAAKrB,MAAK,SAAC1S,EAAGiE,GAAJ,OAAU+M,EAAahR,EAAGiE,EAAGjB,Q,gBCDrE,IAAMgO,EAAexO,EAAQ,IAE7BjM,EAAOD,QADO,SAACyd,EAAM/Q,GAAP,OAAiB+Q,EAAKrB,MAAK,SAAC1S,EAAGiE,GAAJ,OAAU+M,EAAa/M,EAAGjE,EAAGgD,Q,gBCDtE,IAAMH,EAASL,EAAQ,IACjBwN,EAAQxN,EAAQ,I,EACNA,EAAQ,IAAjBG,E,EAAAA,GAAIjL,E,EAAAA,EAgDXnB,EAAOD,QA9CQ,SAACwM,EAASC,GACvB,GAAID,aAAmBD,EACrB,OAAOC,EAOT,GAJuB,iBAAZA,IACTA,EAAUoD,OAAOpD,IAGI,iBAAZA,EACT,OAAO,KAKT,IAAItI,EAAQ,KACZ,IAHAuI,EAAUA,GAAW,IAGRiR,IAEN,CAUL,IADA,IAAIC,GACIA,EAAOtR,EAAGjL,EAAEwc,WAAWtV,KAAKkE,OAC9BtI,GAASA,EAAM2T,MAAQ3T,EAAM,GAAGf,SAAWqJ,EAAQrJ,SAElDe,GACCyZ,EAAK9F,MAAQ8F,EAAK,GAAGxa,SAAWe,EAAM2T,MAAQ3T,EAAM,GAAGf,SAC3De,EAAQyZ,GAEVtR,EAAGjL,EAAEwc,WAAWC,UAAYF,EAAK9F,MAAQ8F,EAAK,GAAGxa,OAASwa,EAAK,GAAGxa,OAGpEkJ,EAAGjL,EAAEwc,WAAWC,WAAa,OArB7B3Z,EAAQsI,EAAQtI,MAAMmI,EAAGjL,EAAE4X,SAwB7B,OAAc,OAAV9U,EACK,KAEFwV,EAAM,GAAD,OAAIxV,EAAM,GAAV,YAAgBA,EAAM,IAAM,IAA5B,YAAmCA,EAAM,IAAM,KAAOuI,K,gBChDpE,IAAMyD,EAAQhE,EAAQ,IAOtBjM,EAAOD,QAJe,SAAC8G,EAAO2F,GAAR,OACpB,IAAIyD,EAAMpJ,EAAO2F,GAAS2D,IACvB7K,KAAI,SAAA6L,GAAI,OAAIA,EAAK7L,KAAI,SAAAhF,GAAC,OAAIA,EAAEY,SAAOoM,KAAK,KAAK9H,OAAOL,MAAM,U,gBCL/D,IAAMmH,EAASL,EAAQ,IACjBgE,EAAQhE,EAAQ,IAuBtBjM,EAAOD,QArBe,SAAC8d,EAAUhX,EAAO2F,GACtC,IAAIsR,EAAM,KACNC,EAAQ,KACRC,EAAW,KACf,IACEA,EAAW,IAAI/N,EAAMpJ,EAAO2F,GAC5B,MAAOqF,GACP,OAAO,KAYT,OAVAgM,EAAS9a,SAAQ,SAACwM,GACZyO,EAASra,KAAK4L,KAEXuO,IAA6B,IAAtBC,EAAM/N,QAAQT,KAGxBwO,EAAQ,IAAIzR,EADZwR,EAAMvO,EACkB/C,QAIvBsR,I,gBCtBT,IAAMxR,EAASL,EAAQ,IACjBgE,EAAQhE,EAAQ,IAsBtBjM,EAAOD,QArBe,SAAC8d,EAAUhX,EAAO2F,GACtC,IAAIyR,EAAM,KACNC,EAAQ,KACRF,EAAW,KACf,IACEA,EAAW,IAAI/N,EAAMpJ,EAAO2F,GAC5B,MAAOqF,GACP,OAAO,KAYT,OAVAgM,EAAS9a,SAAQ,SAACwM,GACZyO,EAASra,KAAK4L,KAEX0O,GAA4B,IAArBC,EAAMlO,QAAQT,KAGxB2O,EAAQ,IAAI5R,EADZ2R,EAAM1O,EACkB/C,QAIvByR,I,gBCrBT,IAAM3R,EAASL,EAAQ,IACjBgE,EAAQhE,EAAQ,IAChB0O,EAAK1O,EAAQ,IAsDnBjM,EAAOD,QApDY,SAAC8G,EAAO4F,GACzB5F,EAAQ,IAAIoJ,EAAMpJ,EAAO4F,GAEzB,IAAI0R,EAAS,IAAI7R,EAAO,SACxB,GAAIzF,EAAMlD,KAAKwa,GACb,OAAOA,EAIT,GADAA,EAAS,IAAI7R,EAAO,WAChBzF,EAAMlD,KAAKwa,GACb,OAAOA,EAGTA,EAAS,KACT,IAAK,IAAIle,EAAI,EAAGA,EAAI4G,EAAMsJ,IAAIjN,SAAUjD,EAAG,CACrB4G,EAAMsJ,IAAIlQ,GAElB8C,SAAQ,SAACuY,GAEnB,IAAM8C,EAAU,IAAI9R,EAAOgP,EAAWzG,OAAOtI,SAC7C,OAAQ+O,EAAW5B,UACjB,IAAK,IAC+B,IAA9B0E,EAAQlR,WAAWhK,OACrBkb,EAAQnR,QAERmR,EAAQlR,WAAWjK,KAAK,GAE1Bmb,EAAQtR,IAAMsR,EAAQrV,SAExB,IAAK,GACL,IAAK,KACEoV,IAAUxD,EAAGwD,EAAQC,KACxBD,EAASC,GAEX,MACF,IAAK,IACL,IAAK,KAEH,MAEF,QACE,MAAM,IAAItQ,MAAJ,gCAAmCwN,EAAW5B,eAK5D,OAAIyE,GAAUtX,EAAMlD,KAAKwa,GAChBA,EAGF,O,gBCtDT,IAAMlO,EAAQhE,EAAQ,IAUtBjM,EAAOD,QATY,SAAC8G,EAAO2F,GACzB,IAGE,OAAO,IAAIyD,EAAMpJ,EAAO2F,GAAS3F,OAAS,IAC1C,MAAOgL,GACP,OAAO,Q,gBCNX,IAAM8K,EAAU1Q,EAAQ,IAExBjM,EAAOD,QADK,SAACwM,EAAS1F,EAAO2F,GAAjB,OAA6BmQ,EAAQpQ,EAAS1F,EAAO,IAAK2F,K,gBCFtE,IAAMmQ,EAAU1Q,EAAQ,IAGxBjM,EAAOD,QADK,SAACwM,EAAS1F,EAAO2F,GAAjB,OAA6BmQ,EAAQpQ,EAAS1F,EAAO,IAAK2F,K,gBCFtE,IAAMyD,EAAQhE,EAAQ,IAMtBjM,EAAOD,QALY,SAACse,EAAIC,EAAI9R,GAG1B,OAFA6R,EAAK,IAAIpO,EAAMoO,EAAI7R,GACnB8R,EAAK,IAAIrO,EAAMqO,EAAI9R,GACZ6R,EAAGzM,WAAW0M,K,68BCDvB,IAAM5D,EAAYzO,EAAQ,IACpB+D,EAAU/D,EAAQ,IACxBjM,EAAOD,QAAU,SAAC8d,EAAUhX,EAAO2F,GACjC,IAD6C,EACvC2D,EAAM,GACR8N,EAAM,KACNM,EAAO,KACLhP,EAAIsO,EAAS1B,MAAK,SAAC1S,EAAGiE,GAAJ,OAAUsC,EAAQvG,EAAGiE,EAAGlB,MAJH,E,6nBAAA,CAKvB+C,GALuB,IAK7C,IAAK,EAAL,qBAAyB,CAAC,IAAfhD,EAAc,QACNmO,EAAUnO,EAAS1F,EAAO2F,IAEzC+R,EAAOhS,EACF0R,IACHA,EAAM1R,KAEJgS,GACFpO,EAAIlN,KAAK,CAACgb,EAAKM,IAEjBA,EAAO,KACPN,EAAM,OAhBmC,8BAmBzCA,GACF9N,EAAIlN,KAAK,CAACgb,EAAK,OAGjB,IADA,IAAMO,EAAS,GACf,MAAyBrO,EAAzB,eAA8B,CAAC,IAAD,YAAlB8N,EAAkB,KAAbH,EAAa,KACxBG,IAAQH,EACVU,EAAOvb,KAAKgb,GACJH,GAAOG,IAAQ1O,EAAE,GAEjBuO,EAEDG,IAAQ1O,EAAE,GACjBiP,EAAOvb,KAAP,YAAiB6a,IAEjBU,EAAOvb,KAAP,UAAegb,EAAf,cAAwBH,IAJxBU,EAAOvb,KAAP,YAAiBgb,IAFjBO,EAAOvb,KAAK,KAQhB,IAAMwb,EAAaD,EAAOlR,KAAK,QACzBoR,EAAgC,iBAAd7X,EAAMiG,IAAmBjG,EAAMiG,IAAM6C,OAAO9I,GACpE,OAAO4X,EAAWvb,OAASwb,EAASxb,OAASub,EAAa5X,I,iiCC1C5D,IAAMoJ,EAAQhE,EAAQ,IACd6I,EAAQ7I,EAAQ,IAAhB6I,IACF4F,EAAYzO,EAAQ,IACpB+D,EAAU/D,EAAQ,IAkDlB0S,EAAe,SAACC,EAAKC,EAAKrS,GAC9B,GAAmB,IAAfoS,EAAI1b,QAAgB0b,EAAI,GAAG/J,SAAWC,EACxC,OAAsB,IAAf+J,EAAI3b,QAAgB2b,EAAI,GAAGhK,SAAWC,EAE/C,IACI6F,EAAIC,EALkC,EAkBtCkE,EAdEC,EAAQ,IAAIC,IAJwB,IAM1BJ,GAN0B,IAM1C,IAAK,EAAL,qBAAqB,CAAC,IAAXte,EAAU,QACA,MAAfA,EAAEoZ,UAAmC,OAAfpZ,EAAEoZ,SAC1BiB,EAAKsE,EAAStE,EAAIra,EAAGkM,GACC,MAAflM,EAAEoZ,UAAmC,OAAfpZ,EAAEoZ,SAC/BkB,EAAKsE,EAAQtE,EAAIta,EAAGkM,GAEpBuS,EAAM9P,IAAI3O,EAAEuU,SAZ0B,8BAe1C,GAAIkK,EAAMI,KAAO,EACf,OAAO,KAGT,GAAIxE,GAAMC,EAAI,CAEZ,IADAkE,EAAW9O,EAAQ2K,EAAG9F,OAAQ+F,EAAG/F,OAAQrI,IAC1B,EACb,OAAO,KACJ,GAAiB,IAAbsS,IAAmC,OAAhBnE,EAAGjB,UAAqC,OAAhBkB,EAAGlB,UACrD,OAAO,KAxB+B,MA2CtC0F,EAAUC,EA3C4B,IA4BzBN,GA5ByB,IA4B1C,IAAK,EAAL,qBAAwB,CAAC,IAAdtD,EAAa,QACtB,GAAId,IAAOD,EAAUe,EAAI9L,OAAOgL,GAAKnO,GACnC,OAAO,KAET,GAAIoO,IAAOF,EAAUe,EAAI9L,OAAOiL,GAAKpO,GACnC,OAAO,KALa,UAONqS,GAPM,IAOtB,IAAK,EAAL,qBAAqB,CAAC,IAAXve,EAAU,QACnB,IAAKoa,EAAUe,EAAI9L,OAAOrP,GAAIkM,GAC5B,OAAO,GATW,8BAWtB,OAAO,GAvCiC,wCA4C1BqS,GA5C0B,IA4C1C,IAAK,EAAL,qBAAqB,CAAC,IAAXve,EAAU,QAGnB,GAFA+e,EAAWA,GAA2B,MAAf/e,EAAEoZ,UAAmC,OAAfpZ,EAAEoZ,SAC/C0F,EAAWA,GAA2B,MAAf9e,EAAEoZ,UAAmC,OAAfpZ,EAAEoZ,SAC3CiB,EACF,GAAmB,MAAfra,EAAEoZ,UAAmC,OAAfpZ,EAAEoZ,UAE1B,GADSuF,EAAStE,EAAIra,EAAGkM,KACVlM,EACb,OAAO,OACJ,GAAoB,OAAhBqa,EAAGjB,WAAsBgB,EAAUC,EAAG9F,OAAQlF,OAAOrP,GAAIkM,GAClE,OAAO,EAEX,GAAIoO,EACF,GAAmB,MAAfta,EAAEoZ,UAAmC,OAAfpZ,EAAEoZ,UAE1B,GADQwF,EAAQtE,EAAIta,EAAGkM,KACTlM,EACZ,OAAO,OACJ,GAAoB,OAAhBsa,EAAGlB,WAAsBgB,EAAUE,EAAG/F,OAAQlF,OAAOrP,GAAIkM,GAClE,OAAO,EAEX,IAAKlM,EAAEoZ,WAAakB,GAAMD,IAAoB,IAAbmE,EAC/B,OAAO,GAhE+B,8BAsE1C,QAAInE,GAAMyE,IAAaxE,GAAmB,IAAbkE,MAGzBlE,GAAMyE,IAAa1E,GAAmB,IAAbmE,IAOzBG,EAAW,SAACxV,EAAGiE,EAAGlB,GACtB,IAAK/C,EACH,OAAOiE,EACT,IAAMyD,EAAOnB,EAAQvG,EAAEoL,OAAQnH,EAAEmH,OAAQrI,GACzC,OAAO2E,EAAO,EAAI1H,EACd0H,EAAO,GACQ,MAAfzD,EAAEgM,UAAmC,OAAfjQ,EAAEiQ,SADbhM,EAEXjE,GAIAyV,EAAU,SAACzV,EAAGiE,EAAGlB,GACrB,IAAK/C,EACH,OAAOiE,EACT,IAAMyD,EAAOnB,EAAQvG,EAAEoL,OAAQnH,EAAEmH,OAAQrI,GACzC,OAAO2E,EAAO,EAAI1H,EACd0H,EAAO,GACQ,MAAfzD,EAAEgM,UAAmC,OAAfjQ,EAAEiQ,SADbhM,EAEXjE,GAGNzJ,EAAOD,QA3HQ,SAAC6e,EAAKC,EAAKrS,GACxBoS,EAAM,IAAI3O,EAAM2O,EAAKpS,GACrBqS,EAAM,IAAI5O,EAAM4O,EAAKrS,GACrB,IAHoC,EAGhC8S,GAAa,EAHmB,IAKLV,EAAIzO,KALC,IAKpCoP,EAAO,IAAK,EAAL,qBAAiC,CAAC,IAAD,EAAtBC,EAAsB,YACdX,EAAI1O,KADU,IACtC,IAAK,EAAL,qBAAiC,CAAC,IAAvBsP,EAAsB,QACzBC,EAAQf,EAAaa,EAAWC,EAAWjT,GAEjD,GADA8S,EAAaA,GAAwB,OAAVI,EACvBA,EACF,SAASH,GALyB,8BAWtC,GAAID,EACF,OAAO,GAjByB,8BAmBpC,OAAO,I,yKCgBP,EAAO,G,OACPrJ,EAAM,aAAG,EAAe,cAAQ,c,SAzDZA,G,QAClB,EAAK,MAA2B,IAApB,EAAU,MAA+B,IAApB,EAAU,WACtCA,EAAO,YAAc,EAAM,YAAM,sBACjCA,EAAO,MAAK,EAAM,KAAK,YACd,IAAZ,EAAO,KAAK,gCAuDd,CADF,E,SAWoB,GAClBA,EAAOhQ,OAAQ,MAAE,QAAY,EAAG,SACjC,qBAEF,SAfK,CAAiBgQ,I,SA5CO,GAK7B,OAJCA,EAAO,MAAK7R,OAA8B,MAArB6R,EAAO,MAAKzV,KAAe,SAAe,MAAO,KACtEyV,EAAO,YAA4B,MAAhB,EAAS,UAAmB,EAAe,EAAK,YAAO,EAAiB,UAC3FA,EAAO,YAAW,OAAgC,MAAtB,EAAK,YAAc,KAAG,GAAeA,EAAO,YAAc,KACtF,EAAO,YAAO,gDACf,EAyCE,K,SAtCqB,G,GACpB,EAAgB,U,IAAX,IAAO,kCACV,IAAI0J,EAAE,EAAG,GACPA,EAAEC,KAAW,cAAP,EAAI,IAAG,OACd,0BAoCL,CAAiB3J,G,SA9BG,QACE,IAApB,EAAI,YACa,YAAf,OAED,qBACoB,IAAnBA,EAAO,OACP,EAAO,UAAY,cACpB,SAwBH,CAAiB,G,SAnBN,GACTA,EAAO,YAAc,EAAO,mBAC7B,sBAkBD,I,YAdA,IAAI,EACuC,cAAd,QAA3B,EAAO,EAAO,eAA2B,IAAX,OAAW,oBAC1C,mCAaD,CAAc,GACf,G,SAUK,EAAK,G,OACP,EACD,UAEA,O,SAKI,EAAU,G,GACb4J,IACD,O,SAoBwB,G,GACvB,EAAO,eAAK,4BACb,S,GAEC,EAAO,QA3BK,IA2BA,SACb,SAEF,SAxBG,CAAgB,GACjB,SAGD,MAAe,EAAG,QAAiB,E,GAEnC,EAAI,OAZU,EAaZ,EAAM,GACN,MAAS,EAAqBC,cAAoB,GAClDD,EAAS,qBAA2B,SAAoB,EACxD,EAAO,yBAAsB,4BAC9B,eAGF,SC9GD,IAAM,KACJ,EAAa,CACb,UAAW,GACX,UAAU,GACV,OAAQ,GACR,OAAQ,GACR,KAAK,GACL,MAAO,GACP,Y,SAGA,EAAc,GACdE,EAAQ,SAAgB,QAAQ,GAEhC,EAAI,cAAkB,oBACpB,YACD,sBAED,EAAMA,EAAQ,QACf,yB,EAKO,CACN,eACA,SAAQ,Y,OACJ,CACF,CAAEvf,KAAM,WAAYwf,KAAM,UAC3B,oFAEA,6B,EAGK,CACN,aACA,SAAQ,Y,OACJ,CACH,sDAEA,sB,EAGK,CACN,cACA,SAAQ,Y,OACJ,CACH,gDAEA,sB,EAGK,CACN,aACA,SAAU,YACV,UACC,mB,EAGK,CACN,YACA,SAAU,YACV,UACC,mB,EAGK,CACN,qBACA,SAAQ,Y,OACJ,CACH,sDAEA,qB,EAGK,CACN,gCACA,SAAQ,Y,OACJ,CACH,2DAEA,qB,EAGK,CACN,kBACA,SAAQ,Y,OACJ,CACF,CAAExf,KAAM,WAAWwf,KAAM,UAC1B,gEAEA,0B,EAGK,CACN,wBACA,SAAQ,Y,OACL,CACF,8BAEA,oB,EAGK,CACN,wBACA,SAAQ,Y,OACL,CACF,8BAEA,oB,EAGK,CACN,qBACA,SAAQ,Y,OACL,CACF,8BAEA,oB,EAKK,CACN,iBACA,SAAU,YACV,UACC,mB,EAGK,CACN,cACA,SAAQ,Y,OACJ,CACH,iCAEA,uB,EAGK,CACN,eACA,SAAQ,Y,OACJ,CACH,iCAEA,uB,EAGK,CACN,qBACA,SAAQ,Y,OACJ,CACF,CAAExf,KAAM,WAAWwf,KAAM,UAC1B,gEAEA,0B,EAGK,CACN,WACA,SAAQ,Y,OACJ,CACH,iCAEA,uB,EAGK,CACN,WACA,SAAQ,Y,OACJ,CACH,iCAEA,uB,EAGK,CACN,WACA,SAAQ,Y,OACJ,CACH,iCAEA,uB,EAGK,CACN,aACA,SAAQ,Y,OACJ,CACH,iCAEA,uB,EAGK,CACN,mBACA,SAAQ,Y,OACJ,CACF,CAAExf,KAAM,WAAYwf,KAAM,UAC3B,oFAEA,6B,EAKK,CACN,WACA,SAAQ,S,OACJ,CACF,CAAExf,KAAM,SAASwf,KAAM,OACxB,iFAEA,0B,EAGK,CACN,cACA,SAAQ,S,OACJ,CACF,CAAExf,KAAM,SAASwf,KAAM,OACxB,iFAEA,0B,EAGK,CACN,kBACA,SAAQ,S,OACJ,CACH,yDAEA,wB,EAKK,CACN,kBACA,SAAQ,S,OACJ,CACH,uEAEA,wB,EAKK,CACN,iBACA,SAAQ,O,OACJ,CACH,yEAEA,wB,EAKK,CACN,gBACA,SAAQ,Q,OACJ,CACH,8BAEA,mB,EAGK,CACN,uBACA,SAAQ,Q,OACJ,CACH,qCAEA,mB,EAGK,CACN,oBACA,SAAQ,Q,OACJ,CACF,CAAExf,KAAM,SAAU,KAAM,UACzB,iCAEA,gC,EAIK,CACN,qBACA,SAAQ,U,OACJ,CACH,uEAEA,wB,EAGD,OAAW,GAAW,SAAE,EAAO,GAC9B,6B,IAQD,EAA2B,W,SACpB,EAAa,EAAC,GAEnB,KAAI,IAAM,EACR,EACD,eAGC8I,KAAKhH,OAAS,GACf,sCAGF,kBAuFF,O,EApFa,UAAG,aAAqB,SAAU,GAC5C,IAAI2d,EAAM,iB,GAER,G,IAEA,IAAI,EAAK,EACT,OAAU,EACH,EAAG,EAAI,EAAC,KAAQ,OAAE,WAEvB,iBAEgC,QAA5B3W,KAAKsW,IAAItd,OAAOrC,GAAG+f,MACC,UAAtB,KAAK,IAAG,OAAO,UAChB,aAEF,mBAEF,SAEA,kD,EAGH,UAsBC,mBArBC,IAAM,EAAM1W,KACN,OAAU,IAAG,SACjB,EAAe,EAAmB,EAAM,IAAC,KAAK,sBAC9C,IAAI4W,EAAS,EAAK,IAAK,e,MACL,QAAdA,GACc,UAAdA,GACc,oBAAdA,GACW,YAAb,GAEa,oBAAb,GAAa,eADd,EAMA,aAOJ,OAJG,GACD,aAGF,oB,EAGK,UAAS,2BAAqB,c,OACnB,IAAb,EAAO,QAAM,OAIhB,sD,EAED,UAiBC,0BAhBC,WAGE,gCAAOC,EAAS,G,EACG,OAAQ,EAAQ,MAAK,oBACrC,8BAKS,KAAZ,GAAmB,KAAK,IAAI,OAAC,YAC9B,wBAEA,iBAGF,oB,EAGU,UAAO,WAAc,W,GACP,IAArB7W,KAAK,OAAO,O,CAKd,IAAI,EAAIA,KAAK,IAAO,KAAK,IACzB9B,GAAQ,KAAI,kBACZ,GAAK,IACN,iBAPG,UAAO,oBAQZ,EAnG4B,G,SAsGvB,IAAE,G,GACJ,EAAK,EAAK,SAAS,GAAE,C,IACnB,EAAiB,GAClB,wCAEF,OAEF,kB,SAOC,IACD,S,SC9UK,EAAW,EAAc,K,GACjB,IAAV,EAAU,OACX,S,GAGC,IAAO,EAA0C,EAClD,c,IAGD,IAGI,EAIJ,EAPM,EAAc,EAAM,KACtB,EAAiB,GACjB,EAAY,GAEZ,IAAiB,OAAS,OAxFhC,GAwFgC,KAC1B,EAAM,EAGH,EAAG,IAAA4Y,EAAc,W,IAEtB,EAAI,GADJC,EAAA,EAAiB,IA7FrB,GA8FqC,MACb,EACnB,SAlGC,SAmGA,KAAc,EAAgB,C,IAC9B,EAAc,EAAO,GAErB,cAEA,GAAO,EACL,EAAc,GACd,EAAY,WAAY,IACzB,KAEF,KA7GC,IAoHL,OAHC,EAAc,EAAO,GAErB,EAAO,MAAc,EAAC,IACvB,E,SAGO,EAAY,EAAM,G,IACxB,IAGA,EAHM,EAAc,GACd,EAAYD,EAAW,GAvH/B,GAwHM,EAAM,cAxHZ,GA0HS,EAAG,IAAAA,EAAc,WACtB,IAAkB,GACnB,SA9HG,IAgIJ,MAAS,EAAyB,GACnC,oB,SAqNK,EAAG,G,IACP,MAAU,KACJ,IAAQ,EAAC,EAAS,OAAE,IACR,OAAd,EAAO,KACR,SAGJ,S,SA8CC,EAAkB/R,EAAYiS,GAC/B,yB,SAGC,EAAO,G,OACL,EAAgB,wBACf,e,SA+BC,EAAY,G,IAEhB,QAEO,EAAAC,EAAW,OAAG,WACjB,EAAO,QACP,EAAK,EAAG,EAAuB,GAC/B,EAAK,EAAM,KACTC,IACD,KAECC,IACD,KAEF,wBAGJ,S,SAGK,EAAoB,EAAE,K,OACxB,OAAY,EAAM,IACnB,aAEA,sC,SAII,EAAQ,EAAgB,G,IAC3B,IAAI,IAAiB,EAAI,EAAE,W,GACR,OAAjB,EAAO,MACR,YAGJ,Y,SAGM,EAAQ,EAAgB,G,IAC3B,IAAI,IAAiB,EAAI,EAAE,I,GACR,OAAjB,EAAO,MACR,YAGJ,Y,MAgBW,CACV,W,SAteM,EAAuB,O,IAC7B,IAAM,EAAa,GACjB,EAAa,CACb,KAAc,IAAVC,EAAc,EAClB,UAGE,EAAa,EACb,EAAa,EACb,EAAW,EAEf,EAAU,GACJ,IAAe,OAAG,EAAU,GAAK,EAAC,GAAI,EACxC,EAAU,KAAIN,EAAe,GAAE,mBAC/B,GAAa,QACb,IACD,kBAGC,EAAQ,EAAY,MAClB,UACD,0BACC,UACD,0BAEA,iBAIDO,EAAW,GAAK,EAAG,KAEnB,EAAU,MAAK,EACf,EAAa,EACb,EAAW,EAEX,KAED,KAGJ,oBA+bCC,Q,SAxbM,EAAc,KAEpB,QAA6B,KAE3B,cAAqC,eAEpC,+BAKD,EAAY,EAAG,YAAM,GAAO,Y,IAC1B,EAAO,EAAS,qBACf,eAEF,e,OAID,EAAc,EAAgB,EAAU,IAAE,iBACxC,iCAqaJ,aAAY,EACZ,aAAS,EACT,U,SAvWA,G,IAEE,EAAgB,6CACd,gBAGJ,EAAM,EAA0B,Y,IAC9B,EAA0B,EAAkB,qBAC5C,E,SA4QgB,EAAC,G,IACnB,IAEA,EAFM,EAAS,GACX,EAAS,GAEP,MAAY,EAAW,OAAG,IAC5B,EAAS,GAAO,KAhatB,IAiaM,EAAY,CAAC,IAAW,IACzB,WACC,EAAgB,KAAY,EAAG,UAnarC,KAoaM,EAAY,KAAW,IACxB,WAGJ,qCAzRS,CAAa,K,IACjB,EAAa,EAAG,qBACf,eAED,EAAY,EAAa,uCACxB,kBAGF,SADgB,EAAC,OAAY,OAKhC,EAA0B,Y,IAC1B,IACA,EADI,EAAI,GAEH,EAAK,qBACR,EAAK,E,IACH,IAAG,EAAIC,EAA0B,OAAO,WACzC,cAEF,iBAGF,aAyUC,M,SAtUO,K,OACL,EAAO,qB,MACL,CACAR,EAAM,GAAE,EACR,UAmUJ,O,SAnToBD,EAAW,G,IAC7B,QAAY,EAAI,a,EACd,GAAY,CACZA,EAAWngB,GAlMX,GAkM6B,EAC7B,KAjMN,IAqMC,UA4SC,W,SA/TgB,EAAI,G,IAClB,QAAY,EAAI,a,EACd,GAAY,CACZmgB,EAAWngB,GAvLX,GAuL6B,EAC7B,KAtLN,IA0LC,UAwTC,M,SAtSqB,G,IACrB,IACA,EADI,EAAW,GAEb,IAAU,EAAGmgB,EAAc,OAAK,IAChC,EAAU,EAAM,GAAU,GAAEA,EAAe,EAAI,MAChD,oBAEF,UAgSC,K,SAzRM,G,IACN,IACI,IADA,EAAO,GAEP,EAAa,EACjB,EAAgB,EACT,EAAG,IAAAA,EAAc,WACtBC,EAAA,EAAa,GAEb,IAAwB,KAGxB,KArOJ,GAqOI,EArOJ,IAqOgD,IAE1C,EAzOA,IAyOoB,EAzOpB,KA0OD,KA1OC,GA0OD,EA1OC,IA0OD,GAGF,YA3OH,KA6OC,UAuQC,oB,SApQe,K,IACf,IACI,EADA,EAAM,GAEN,EAAQ,KAEZ,IAEM,MAAY,EAAGS,IACU,OAA3B,EAAS,KA1PT,KA2PA,GAAS,EAAC,KA3PV,GA4PD,KAGD,EAAQ,EACT,KAEA,OAGD,OAAS,CAAC,EAAO,EAAG,EAAW,GAnQjC,K,IAoQI,YAAoB,WAEM,OAAxB,EAAQ,GAxQR,KA0QA,IADA,EAAQ,EAAM,GACJ,KA1QV,KA0QU,KACX,KAGyB,OAAxB,EAAQ,EAAK,GA9Qb,KA+QA,EAAI,EAAW,EACb,EAAS,GACT,GAAS,EAAC,OAjRZ,KAiRY,KACX,MAEC,EAAQ,KACT,MAGJ,eAtRH,KAwRC,UA6NC,iB,SA1NsB,EAAI,GAC1B,IAEI,EAEA,EAJAC,EAAA,GAAW,IACX,EAAQ,KA/RR,G,GAmSF,KAGA,U,IAEA,IAAI,EAAQ,KACZ,EAAc,EACR,MAAY,EAAGD,IACU,OAA3B,EAAS,KA3SX,KA4SE,GAAS,EAAC,KA5SZ,GA6SC,KAGD,EAAQ,IAORC,EAAA,EANA,KAMW,EAAM,GArTvB,KAsTM,EAAM,EACP,UAID,EAAI,EACL,I,IAGC,IAAI,MAAY,EAAE,OAAiB,IACL,OAA5B,EAAW,GAlUX,IAoUA,EADA,EAAQ,EAAG,EAAQ,GAnUnB,IAmUmB,OAEpB,eAnUL,MAqUK,kBArUL,KAwUC,UA8KC,IAAK,EACL,M,SAvKOC,GACR,iBAuKC,Q,SA1JMA,GACN,IAAIC,E,SAOoB,G,IACxB,MAAoB,GACd,IAAQ,EAAC,EAAS,OAAE,IACtB,OAAAD,EAAA,IACD,aAGJ,SAdqB,CAAc,G,OACpB,IAAZ,EAAY,OACb,KAEF,eAsJC,I,SAzIO,GACR,mBAyIC,I,SAtIO,GACR,mBAsIC,O,SAnIY,GACZ,MAAa,EAAmB,EAAM,OAAO,GAC9C,kCAkIC,W,SAjLe,KACf,MAAa,EAAmB,EAAM,OAAO,GAC9C,sCAgLC,aACA,kB,SAlCc,G,OACL,EAAO,MACd,EAED,EAEF,iBC7eK,EAAM,EAAE,IACR,EAAQ,EAAE,MACV,EAAM,EAAO,QACb,EAAM,EAAG,IACT,EAAM,EAAG,IACT,IAAa,OAEb,EAAmB,EAAG,WACtB,EAAmB,EAAoB,WAEvC,EAAQ,EAAG,U,SAST,EAAkB,SACxB,IAAM,EAAiB,EAAG,GAOtB,EAAkB,EAAE,YANP,Y,IACb,EAAO,EAAS,gCACf,eAEH,e,MAGO,WAAP,EACD,aAEA,Y,SAwFK,EAAkB,OACxB,QAA6C,qBAG9C,SADe,EAAyB,WAAe,GACvD,K,IA4BC,EAAuB,CACvB,Q,SA/CqB,EAAG,KAEzB,aADgB,EAAqC,KA+CpD,MA5IU,SAAG,EAAQZ,GAAe,SAAG,WAAOA,EAAY,IA6I1D,OA5II,SAAmB,EAAG,GAAI,OAAU,EAAK,SAAG,IA6IhD,MAhJW,EAAG,MAiJd,KAhJS,EAAsB,KAiJ/B,cA9IuB,SAAI,EAAAA,GAAe,SAAG,oBAAiBA,EAAe,IA+I7E,yBA9I4B,SAAG,EAAU,GAAK,SAA8B,mBAAS,IA+IrF,WA7IO,WAAc,EAAE,GAAa,SAAU,uBA8I9C,c,SA3GO,K,OACL,EAAO,qB,MACJ,CACO,OAARC,EAAO,GAAC,OACR,UAwGJ,Y,SAnDA,OAEA,QAA6C,qBAI9C,SAFsB,EAAG,WAAqB,GAE9C,EADgB,EAAwB,KAgDvC,c,SArCqB,EAAG,KACxB,QAA6C,qBAI9C,SAFsB,EAAK,WAAQ,GAEnC,EADgB,EAAwB,YAAiB,KAkCxD,QAAK,EAAE,EAAAa,QAAQC,EAAkB,GACjC,IAAK,IAAED,QAAQC,EAAkB,GACjC,MAAQ,UAAE,EAAQ,GAClB,OAAK,EAAE,EAAAD,QAAQC,EAAkB,GACjC,IAAK,EAAE,UAAE,EAAwB,GACjC,QAAW,UAAS,KACpB,YACA,iB,SAxIO,K,OACL,EAAO,qB,MACJ,CACDd,EAAO,GAAC,YACR,UAqIJ,iB,SAhIO,K,OACL,EAAO,qB,MACJ,CACDA,EAAO,GAAC,YACR,UA6HJ,MAAQ,UAAE,EAAQ,OAClB,SAAsB,sBACtB,W,SAjHO,K,SACY,UAAc,eAC7B,SAAU,OAAC,gBAChB,IA+GC,U,SA1Cc,KACd,MAAO,EAAa,KAAI,I,OACtB,EAAoB,qBACnB,eAwCHe,S,SA7GA,KAMD,OAJG,KAAK,aAAQ,GAAoB,EAAO,aACzC,4CAED,EAAO,OAAW,EACnB,GAwGC,gB,SApFoB,K,IAKd,EAHP,OADC,EAAO,QAID,EAJY,SAKK,WALL,GAMO,QAC1B,IANA,GAmFC,a,SAtGY,OACZ,IAAI,EAEH,EADC,EAAU,KACX,OAEA,EAGD,4BAMD,OAJG,KAAK,aAAQ,GAAoB,EAAO,aACzC,4CAED,EAAO,OAAW,EACnB,IA2FC,EAAY,CACZ,IAAK,EACL,IAAK,EACL,MACA,OAAK,EACL,IAAK,EACL,SAGkB,EAAgB,CAClC,iBAAS,EACT,QAxLI,SAAY,OAAY,OAAC,UAyL7B,QAAK,EACL,IAAK,EACL,MACA,OAAK,EACL,IAAK,EACL,QAEA,kB,SA5DgB,KAChB,MAAO,EAAkB,K,OACvB,EAAO,qB,MACF,CACHC,EAAG,GACH,Y,2BAyDH,U,sBAIA,W,kNCxMD,WAYA,IAAM,EAAQ,EAAS,sBAEvB,EAAO,EAAK,EAAC,SAAsB,EAAE,QAAM,8B,OACzC,EAAa,SAAc,SAAS,EAAEC,GACtC,IAAI,EAAK,EAAa,qBAEtB,SAEE,EAAY,CACZ,kBAAqB,EAAO,MAC5B,gBAAkB,CAAEpgB,MAAOoC,EAAK,MAChC,+B,GAGA,EAAa,UAAE,OAAU,EAAE,CAC3B,MAAW,EAAuB,EAAE,KAAK,EAAO,mBAChDie,EAAW,YAAkB,MAAK,EAAOrb,MAEzC,2BAA6C,MAE3C,EAAwB,OAAG,GAAM,cAClC,iB,MAID,CACA,SACA,WAAU,aACV,iB,SA4DA,EAAa,EAAO,GAExB,c,OAEE,EAAK,aACN,8CAGC,CACA,EACA,kC,SAII,EAA4B,EAAA4B,EAAS,GAC3C,IACI0Z,EADmB,cACH,Q,OAClB,EACE,EACD,KAEA,KAGJ,G,SA6EC,K,MAEE,CACA,OAAM,EAAK,OACX,kC,SAIE,EAAM,KACV,M,OACE,G,IACE,MACA,EAAM,YACR,M,IACE,MACA,EAAM,YACR,M,IACE,MACA,EAAM,YACR,M,IACE,MACA,EAAM,YACR,M,IACE,QACA,EAAM,cACR,M,QAED,c,MAGC,CACA,OAAM,GACN,aAIW,QACb,c,SA1LqC,IAAAC,GAEtC,YADQ,IAAP,IAA6B,GAAS,GACvC,YAyLC,eAAY,EACZ,a,SAxL+C,MAAAA,GAGhD,YAFO,QAAuB,MAE9B,QADuB,EAA6B,YAAsB,KAuLzE,W,SApL0C,MAAAA,GAG3C,YAFO,QAAsB,MAE7B,QADuB,EAA2B,EAAE,QAAAC,EAAqB,KAmLxE,qB,SA/KuB,IAAa,GACpC,IAAAC,EAAM,IAAU,EAAgB,EAChCA,EAAMC,UAAU,CAACpa,KAAM,SACvBma,EAAMC,UAAU,CAACpa,KAAM,SACvBma,EAAMC,UAAU,CAACpa,KAAM,QAEvB,EAAM,gBAAkB,eACxB,QAAc,EAAC,QAAI,YAuBpB,O,EAtBuB,UAAgB,SAAKlE,GACzC,IAAM,EAAY,aAAO,GACrB,EAAY,EAAsB,OAAQ,GAE1C,EAAO,EAAQ,EAAmB,MAAE,K,IACtC,EAAO,mC,CAKP,eACD,wCAGD,IAAI,EAAO,EAAkB,iBAE7B,EAAM,EAAK,EAAK,Q,EACd,KAAM,KAAK,CACV,wBAIN,GAkJC,kB,SApHkB,EAAU,EAAqB,GACjD,IAAI,EAAY,EAAQ,EAAK,WAAU,I,GAChB,WAArB,EAAM,SAAwB,CAC9B,MAAO,mC,MACL,CACA,SAAY,gB,WACT,CACF,kBAIH,IAAM,SACN,EAAa,G,IACXrD,EAAK,IAAM,EAAE,WACL,IAAN,GACD,yCAEF,uC,MAEC,CACA,SAAkB,gBAClB,eAgGJ,uB,SA3FK,EAAS,EAAC,G,GACb,EAAyB,aAazB,CACA,IAAM,E,SAkBO,GACf,iBAAoD,0EAEpD,KASD,O,EARsB,EAAC,KAAM,GAAQ,SAAU,GAC3C,kC,EAED,OAAE,GAAK,SAAgB,G,EACH,OAAQ,EAAS,QAAG,YACrC,8BAGN,EA9BS,CAAa,GACb,EAAiB,EAAa,gBACpC,EAAM,IAAU,EAAmB,EAYpC,OAXC,kBAAE,e,EACiB,OAAM,EAAgB,6CACtC,8B,EAEG,UAAE,SAAS,EAAkB,G,GAC/B,EAAU,WAAC,EAAK,IAChB,IAAI,EAAE,EAAE,MAAM,EAAR,UAAC,EAAoB,UAAK,oEAChC,IAAqB,+BACtB,mBAGJ,EA3BC,IAAI,O,IAEH,Y,MACC,GACD,sD,MAEC,CACA,wB,WACG,CACF,gBAiFL,e,SAxMA,GAKD,O,EAHuB,sBAAQ,GAC3B,sEAEJ,I,SC1DO,GAAkC,K,IAExC,MAAoB,GACX,EAAG,IAAQ,EAAI,YACtB,IAAM,IAAY,GAGdkB,EAAG,EAFW,OAAC,a,GAGjB,G,IACE,EAAW,CACX,UAAW,OAAE,SACb,UAAW,WACX,QAAQ,UACR,OAAQ,KACR,WAAY,SACZ,aAAcY,EAAE,aAChB,aAAY,eACZ,YACA,wBACA,iBAAe,mBACf,YAAY,cACZ,SAAS,WACT,MAAM,EAAG,MACT,OAAQ,EAAC,OACT,MAAOZ,EAAE,MACT,MAAM,EAAG,MACT,OAAO,EAAG,OACV,UACA,wBACA,iBAAkB,EAAC,iBACnB,gBAAgB,kBAChB,aAAc,eACd,MAAOA,EAAE,MACT,eAGH,WAKJ,S,SAOS,GAA0B,IAAC,G,IACnC,IAAM,EAA+B,EAAG,eAExC,EAAoB,GACX,EAAG,IAAQ,EAAE,YACpB,IAAM,IAAS,GAGXA,EAAG,EAFW,OAAC,a,GAGjB,G,IACE,EAAO,CACP,QAAoB,EAAM,cAC1B,UAAW,OAAE,SACb,UAAWmN,EAAA,SACX,QAAQ,UACR,OAAQ,KACR,WAAY,SACZ,aAAcA,EAAE,aAChB,aAAY,eACZ,YACA,WAAW,EAAG,WACd,YAAY,cACZ,SAAU,WACV,OAAQ,EAAC,OACT,MAAOnN,EAAE,MACT,MAAM,EAAG,MACT,OAAO,EAAG,OACV,UACA,wBACA,iBAAkB,EAAC,iBACnB,gBAAgB,kBAChB,aAAc,eACd,MAAOA,EAAE,MACT,eAGH,WAKJ,S,OA2FC,CACA,qB,SA1EE,EAAK,GAIR,O,EAHqB,EAAG,KAAM,GAAC,SAAW,GACtC,6BAEJ,GAuEC,oB,SApEiB,EAAQ,GAU1B,O,EATO,SAAQ,SAASgV,G,GACnB,EAAU,OAAGA,EAAc,MAAG,QAC9B,IAAIjQ,EAAK,QAAY,G,GACD,MAAlB,EAAM,aAAoB,CAC1B,IAAI,EAAS,EAAW,EAAC,cAC1B,yBAIN,GA2DC,qB,SA3FE,GAKH,O,EAJS,EAAkB,KAAG,eAC3B,MAAsB,EAAmB,gEACxC,mBAEJ,GAuFC,mB,SApFA,EAAO,GAIR,O,EAHW,EAAa,KAAG,GAAa,SAAC,GACrC,qBAEJ,GAiFC,kB,SA1DA,EAAiC,GAEjC,IAAI2b,EAAe,iBAUpB,OATG,IACD,E,SAWG,EAAcA,G,OAChB,EAAO,KACL,EAAO,SAAiB,YAAoB1L,GAC3C,qCAGD,EAA0B,SAAK,GAAc,YAC5C,4BAlBJ,OAIC,EAAc,6BACf,qDAGF,GA+CC,a,cAhCA,IAAI,IAML,MAL4D,cAA9C,QAAX,IAAW,eAAE,IAAF,OAAU,EAAW,gBACjC,wDAC2D,gBAA/C,QAAX,EAAW,iBAAU,IAAR,OAAmB,IAAW,gBAC5C,0DAEF,GA2BC,Y,SAxBmB,GAcpB,MANS,CACN,KAAM,WACN,OAAQ,CATQ,CAChB,KAAM,WACN,KAAM,EAAM,gBACZ,OAAQ,IAAE,iBACV,YAMA,kBAcF,yBAAsB,GACtB,2B,mBCxLA,GAAY,W,SACL,EAAY,GACjB7M,KAAK,aAAewY,EAAoB,QAExC,oBAEAxY,KAAK,MAAQ,GACd,iBAiCF,O,EA3BU,UAAY,aAAe,SAAE2W,EAAW,EAAM,GACtD,O,SAqDD,S,OAEE,WACE8B,EAAKC,MAAMC,KACZ,eAGD,IAAM,EAAO,QAAe,GACxB,EAAK,GAAiB,W,OACxB,iBAAsB,EAAC,WAAY,EAAa,IACjD,4BAEE,EAAK,QAAM,WACV,MAAI,SAAW,GAOd,YANY,IAAX,I,EACS,GAAM,CACb,QACA,uBAGH,MAzEN,c,EAMU,UAAU,QAAS,SAAE,OAK/B,OAJG3Y,KAAK4Y,SAASD,KACf,qB,SAyBH,O,OAEE,WACA,IAAI,EAAC,GAAqB,WAa1B,OAZEE,EAAcC,K,EAEN,WAAM,6BACV,eAAc,GAEb,OADD,EAAc,QACP,K,OACP,SAAc,GAGhB,MAFE,EAAU,QAEZ,OAGJ,MAtCD,GADqB,KAAE,YACvB,I,EAGO,UAAY,iBAAmB,SAAUnC,EAAS,EAAE,GAC1D,MAAY,aAAa,EAAS,EAAU,GAC7C,iC,EAGK,UAAa,uB,GACf,EAAM,CACN,MAAS,KAAY,MAAS,EAAI,UACnC,iCAEA,UAEJ,EAxCa,G,SA6FN,GAAgB,GAEvB,O,SAGa,GACZ,IAAc,IAAQ,EAAlB,EAAI,E,GACS,IAAf,S,IACE,EAAG,EAAK,EAAI,SAAc,QAC1B,EAAI,EAAM,WAAU,GACpBmC,GAAS,GAAE,OACZ,KAGJ,SAZA,CADgB,eAAU,ICxG3B,wHAAAniB,EAAA,EAAAA,EAAA,SAAAA,IAAA,SAAAA,GAAA,2KAGO,IACL,GADkC,CAElC,EAAK,UACL,EAAK,cACL,EAAK,cACL,EAAK,e,kBAIL,GADgC,CAEhC,EAAK,S,iBAYL,GADuC,CAEvC,IAAO,YACP,IAAO,YACP,IAAO,YAJF,qBAYL,GAAqB,WACnB,SAAKoiB,EAAL,GAA4BA,GAA5B/Y,KAAA,GACAA,KAAKgZ,aAAL,EAAsB9V,aACtBlD,KAAKiZ,eAAL,iBACAjZ,KAAKkZ,iBAAL,KALJ,6B,sDAwBI,MAAOC,KACNC,OAAK,EAAM,sDACV,eAAKH,GAFP,OAGE,EAAKC,iBAAL,EAA0BG,KAAGC,GAC7B,EAAK,mBAAqB,YACxB,EAAKN,iBACN,yBAEC,EAAKD,eACN,qBATI,OAiBQ,uCAEhB,mCAKY,mCAEZ,+BAKW,kCAvDd,8B,8CA4DI,EAAOQ,WAAyBC,UAASzf,OAAOoe,QAAhD,IAAgDA,UAAhD,kBA5DJ,oB,oUACuB,GAiErB,GAAYsB,WACV,SAAKC,EAAL,MAAA1Z,KAAA,GACAA,KAAK9I,KAAO,KACZ8I,KAAKJ,KAAL,uBAJJ,oH,8CAAA,wB,EACc6Z,GAsBZ,mBAEA,IAAIE,IAAgBnQ,SAAC,EAAKA,UAAEoQ,EAAsB,MAAA3C,EAAU,oBAC1D,EAAeA,EAAf,kCACA,IAAMjd,EAAOwP,OACT9J,EAAK,EAAT,qB,SAIE,EAAc,CACd,kBAAqB9H,EAAOoC,MAC5B,gBAAkB,CAAEpC,MAAOoC,EAAKC,M,+BAIhC,KAAauP,UAAErO,OAAY,EAAC,CAC5B8c,MAAW,EAAuB,EAAErb,KAAKA,EAAzC,mBACAqb,EAAW,YAAX,MAAkCrgB,EAAOgF,M,iCAIvC8C,EAAQ,EAAmBA,KAA3B,iBACD,iBAMDiN,OACAmK,SACAmB,WAHK,wB,iBAQV,8BAGCkB,I,GAAAA,CACAU,eACAC,oBAhK+B,IAiK/BC,wBACAC,sBACAC,kBAtJ+B,CAE/B,IAAO,MACP,IAAO,MACP,IAAO,MACP,U,6FCEA,GAAoD,W,SAC7C,EAAe,EAAa,KACjCja,KAAK,aAAa,EAElBA,KAAK,cAAc,oBAAG,0C,KACpB,eAAW,CACX,YACA,mBAGF,wCAGD,mBAwmBF,O,EAjmBe,kBAAkB,SAAe,EAAM,G,qDACjD,MACC,wE,EAG6B,4BAAgB,mBAC1C,QAAgC,M,IACpC,EAAU,CACV,SAAQ,cACR,OAAO,O,QACL,CACD,mC,KAEC,CACA,aAAM,kBACN,OAAM,EACP,WAYJ,OAPG,KAAAka,eAAe,WAAkB,KAAK,kCACvC,sBAEC,KAAAA,eAAe,YAChB,uDAGF,gD,EAMa,UAAQ,WAAkB,WACvC,wC,EAED,UAiBC,uBAhBC,IAAI,EAAM,KAgBX,OAfGla,KAAKma,oB,KAED,kBAAa,oDAUf,OATI,EACD,2CAEA,kEAGD,EAAK,WAjFf,QAkFU,oBAAe,KAEjB,OAGL,wB,EAOc,6CACXC,IACD,0C,IAGC,EAAQ,CACR,SAAS,EACT,QAAQ,EACR,UAOH,OAJG,IACD,cAGF,qC,EAGgB,+BAOhB,oCANY,CACT,QAAS,QACT,UAAU,OACV,iB,EAMkB,+B,IAClB,EAAS,CACT,QAAS,OAAQ,QACjB,kBAMH,OAJG,IACD,cAGF,4B,EAGgB,8B,IACb,EAAQ,CACR,OAAO,SACP,WAGH,0C,EAUqB,mC,IAClB,EAAQ,C,OACN,CACA,cACA,aACA,SACA,SACD,SAED,UAAU,OACV,UAAU,EACV,UACA,sC,OAEA,IACD,aAEC,IACD,oBAEC,YAED,2BAEC,aAED,6BAGA,KAAK,sBACP,W,EAGgB,oC,IACb,EAAS,CACT,QAAQ,E,OACN,CACA,cACA,aACA,SACA,SACD,SAED,YACA,+B,OAGD,KAAK,mBAAS,GAChB,oC,EAGgB,gC,IACb,EAAQ,CACR,OAAO,SACP,WAGH,wC,EAGgB,qCAMhB,oCALW,CACR,gBACA,kB,EAMa,mC,IACb,EAAS,CACT,OAAO,CAAE,aACT,W,OAED,KAAK,mBAAS,GAChB,0D,EAUD,UAwBC,2BAtBC,WAEM,EAAW,EAAK,EAAC,UAAe,cACpC,EAAa,EAAG,MAAE,GAAW,SAAU,KACvC,IACE,EAAQ,CACR,OAAO,SACP,QAAS,EACT,QAJkB,oBAKlB,UAAW,QACX,UAAW,MACX,aAQD,OAJC,IACD,eAGA,8BAGJ,yC,EAWD,UAwBC,qCAtBC,WAEM,EAAW,EAAK,EAAC,UAAe,cACpC,EAAa,EAAG,MAAE,GAAW,SAAU,KACvC,IACE,EAAQ,CACR,OAAO,SACP,MAAO,EACP,QAJkB,oBAKlB,UAAW,QACX,UAAW,MACX,aAQD,OAJC,IACD,eAGA,4BAGJ,yC,EAGkB,UAAC,8BAClB,IAGE,EAAS,C,OACP,UACA,QACD,GAED,QANkB,oBAOlB,aAQH,OAJG,IACD,eAdY,KAiBd,wB,EAGgB,mC,IACb,EAAQ,CACR,gBACA,cAEH,sC,EAG4B,UAAS,OAAnB,SAAU,EAAU,KACrC,IACI,EAAQ,OADC,EAAY,GACS,GADG,EAAW,K,GAE7B,SAAjB,EAAM,YAEP,O,SAoUH,GAEA,IACA,EAAe,GAAW,iBADT,IACS,GAAkB,IAC7C,uBAzUiB,CAAkB,oBAE9B,GAAiB,SAAX,EAAQ,YAAG,CAElB,OADa,EAA6B,IAAU,kB,IAInD,GACA,WAAS,EACT,aAGH,yC,EAG6E,UAAO,YAA3D,SAA2D,EAAzD,EAAkD,EAA1C,GAElC,IAAM,EAAc,oFAClB,EAAQ,CACR,gBACA,4BACA,sBAAoB,SACpB,WAAW,SACX,OAAQ,IACR,WACA,UAAW,YACX,UAAU,OACV,aAEA,SAAO,EACP,UACA,eAAM,EACN,UAwBH,OArBG,IACD,qBAGQ,IAAP,IACD,kBAGC,IACD,UAGC,IACD,YAGC,GAAO,KACPphB,EAAO,UAAY,EACpB,eAGF,yC,EAGqB,uC,IAClB,EAAQ,CACR,gBACA,aACA,mBAAgB,EAChB,cACA,eAAe,EACf,aACA,eAAe,EACf,aAAc,SACd,YAAa,CAAC,OAAQ,OAAQ,qBAAY,gBAC1C,2BAA6B,aAG7B,kBAGH,gD,EAGQ,UAA+C,YAAnC,SAAE,EAAiC,EAAO,EAAnB,GAE1C,IAAM,EAAc,uDAClB,EAAQ,CACR,OAAQ,SACR,SAAS,EACT,UACA,iBACA,mBAAgB,EAChB,cACA,eAAe,EACf,aACA,iB,OAEE,CACD,SAED,aAAc,SACd,YAAa,CAAC,OAAQ,OAAQ,qBAAY,gBAC1C,oBAAiB,OAAQ,aACzB,gBAAY,SACZ,qBAkBH,OAfG,IAAc,GAAU,WACzB,iBACC,IAAsB,GAAO,6BAC9B,sBAGC,IACD,mBAGC,GAAO,KACPA,EAAO,gBAAiB,EACzB,oBAGF,+B,EAGqB,wC,IAClB,EAAQ,CACR,gBACA,UAAW,EACX,UAAW,EACX,YACA,oBAAqB,SACrB,YAAO,SACP,SASH,OANG,IACAA,EAAO,QACPA,EAAO,UAAY,QACpB,oBAGF,uC,EAGwD,UAAO,iBAAP,SAAO,EAApC,EAA6B,EAAnB,GAEpC,IAAM,EAAc,yDAClB,EAAQ,CACR,gBACA,UAAW,EACX,UAAU,EACV,MAAM,IACN,OAAQ,IACR,OAAQ,IACR,SAAS,IACT,UAAW,YACX,iBACA,oBAAoB,SACpB,oBACA,sBAAQ,mCACR,SAAO,EACP,UACA,kBAeH,OAZG,IACD,WAGC,IACD,gBAGC,IACD,WAGF,uC,EAGgB,2C,IACb,EAAQ,CACR,OAAQ,SACR,WACA,gBACA,oBAAoB,SACpB,WAAW,SACX,UAAW,QACX,kBAGH,oC,EAGgB,qC,IACb,EAAQ,CACR,SAAQ,E,OACN,CACA,UACA,UACA,QACD,SAED,gBAGH,oC,EAGgB,sC,IACb,EAAQ,CACR,OAAQ,SACR,WACA,gBACA,oBAAkB,SAClB,UAAW,QACX,kB,OAGD,KAAK,oBAAM,GACV,eAAO,GACN,qE,EAIiB,oC,IAClB,EAAQ,CACR,OAAO,SACP,UACA,mBAAgB,EAChB,cACA,eAAe,EACf,aACA,iBAKA,0BAQH,OALG,GAAO,KACPA,EAAO,gBAAiB,EACzB,oBAGF,+B,EAGmB,UAAkD,cAAhD,SAAY,EAA6B,EAA3B,GAClC,IAAM,EAAc,iEAClB,EAAQ,CACR,OAAO,SACP,UACA,aAAU,EACV,cAAiB,GACjB,mBAAgB,EAChB,cACA,eAAe,EACf,aACA,eAAe,EACf,gBAAc,SACd,aAAc,SACd,6B,OAGA,GAA0B,IAAnB,GAAmB,QAC3B,kBAGC,GAAOqhB,EAAiB,SACzB,qBAGC,GAAO,KACPrhB,EAAO,gBAAiB,EACzB,oBAGA,KAAK,QAAC,cAAQ,GACb,MAAK,SAAS,GAOb,OANC,GAAW,IAAH,GAAyC,IAAtC,IACX,E,SAoCkB,K,OACf,IAAP,EACD,kEACQ,IAAP,EACD,kEAEA,EA1CgB,MACT,IACD,aAGF,M,EAIY,gCAKhB,gCAJY,CACT,6B,EAMkB,mC,IAClB,EAAQ,CACR,OAAO,SACP,WAGH,+C,EAGqB,sC,IAClB,EAAM,CACN,OAAQ,EACR,YAGH,yCACF,EArnBqD,G,SAyoB/C,GAAoBshB,EAAV,GACf,IAAM,EAAS,EAAM,UAErB,KAEA,EAASzc,KAAK,MAAK,EAASgB,GAAYA,EAExC,EAAS,KAAI,OAAe,GAASA,E,IACnC,IAAAlI,EAAS,EAAM,Y,EACN,KAAC,CACR,KAAO,EACN,SAKN,S,IASC,GAA+B,W,SACxB,EAAa,GAClBqJ,KAAK,KAAOkQ,EAAM,MAAQ,KAC1BlQ,KAAK,KAAOkQ,EAAM,SAAW,GAC7BlQ,KAAK,KAAO,EAAG,SAChB,0DAKF,O,EAFc,UAAQ,SAAW,WAC/B,gCACF,EAVgC,GCvpB/Bua,I,GAAAA,CACAC,aA/BA,SAAS,aASV,MATW,wEAAD,OAEAnC,EAFA,sCAGYoC,EAHZ,kCAISC,EAJR,yBAIgCC,OACtBD,EALX,iBAK4BE,SAL5B,iC,iEAgCTC,YApBA,SAAS,eASV,MATW,wEAAD,OAEAxC,EAFA,8CAGYoC,EAHZ,kCAISC,EAJR,yBAIgCC,OACtBD,EALX,iBAK4BE,SAL5B,iC,2EAcT,WACD,M,0GCC2BE,OADZ,sC,0GAUdP,I,GAAY,CACZC,aApCA,SAAmB,IAAcI,EAAd,OACnB,IAAInf,EAAK,qCASV,MAR6Bqf,iCAA8BC,O,yBADjD,wFAGYN,EAHZ,kCAISC,EAJR,yBAIgCC,O,+EAgC1CE,YAxBA,SAAmB,IAAcD,EAAd,IAA+BA,EAAlD,GACA,IAAInf,EAAK,qCASV,MAR6Bqf,iCAA8BC,O,yBADjD,gGAGYN,EAHZ,kCAISC,EAJR,yBAIgCC,O,yFAa1C,WACD,YCtCD,gQAAAhkB,EAAA,EAAAA,EAAA,SAAAA,IAAA,SAAAA,GAAA,suCAOEqkB,O,WAKA,GAAqB,aAZvB,mOAYuB,UAZvB,MAYuB,QACnB,cAAM9X,IAAN,IAFJ,OAXA,4FAaI,U,kBAGK+X,QAAa,OJbW,I,kBIgB5B7B,IAAM,EAAK,qDACV,iBAFF,EANmB,oBADvB,E,OAXA,E,GAAA,E,wCA0BMpZ,KAAKib,mBAAaC,GADpB,KAEO,cAEN,qBAMc,uCAEf,MAAYC,gBAAeN,YA1B/B,gC,iCA8BSO,IAA6BlY,EAA7BkY,GAAYC,MAAiBnY,KAClC,EAAI0X,EAAc/c,WAAUud,EAA5B,gB,mBAMAR,EAAeD,KAAWD,QAAYY,GAAtCV,G,qCAGA,EAAgB,GAAcZ,OAI1BpB,EAAWpP,EAAA,EAAM+R,UAAe,cAClC,EAAW,EAAG/R,EAAC,IAAD,GAAa,SAAe,EAA1C,GACA,IAAI6O,EAAQyB,EAAqB0B,MAAjC,uBACI/f,EAAQ,GAAgB8e,G,yCAH9B,OAME,EAAO,OAAKY,EAAZ,EAAO,CAAP,GANF,uBAUE,eAAO3R,aAAC,SAASiS,GADnB,OAAO,EAAP,kB,gCAMML,IAA8BlY,EAA9BkY,GAAYC,MAAkBnY,KACpC,EAAI0X,EAAc/c,WAAUud,EAA5B,gB,mBAMAR,EAAeD,KAAWD,QAAYY,GAAtCV,G,qCAGA,EAAgB,GAAcZ,OAI1BpB,EAAWpP,EAAA,EAAM+R,UAAe,cAClC,EAAW,EAAG/R,EAAC,IAAD,GAAa,SAAe,EAA1C,GACA,IAAI6O,EAAQ0B,EAAmByB,MAA/B,uBACIE,KAAclS,GAClBkS,EAAcC,EAAY1B,WAA0ByB,aAApD,wBACA,EAAY,GAAKT,0BAAgC5C,G,8CALnD,OAQE,EAAO,OAAK8C,EAAZ,EAAO,CAAP,GARF,uBAYE,eAAO3R,aAAC,SAASiS,GADnB,OAAO,EAAP,kB,qCAMA,GACEnW,MADa,CAEb7F,MAAM,IACNsZ,qBACA6C,aAJa,kBAKbC,S,0BAIAphB,OAAK,SADkC,cAClC,GADkC,mBAEvCqhB,sBACAC,OAAM,OACJ1W,M,eAIF,eAAW,GACX,IAAIoW,EAAQ,EAAM,aAChB,SAAOA,EACF,WAEN,aA1HP,6B,EAYuB,C,ICZvB,gQAAA9kB,EAAA,EAAAA,EAAA,SAAAA,IAAA,SAAAA,GAAA,suCAIE,OADwB,CAExB,IAAO,OACP,IAAO,MACP,IAAO,MACP,U,eAIA,GAAqB,aAZvB,mOAYuB,UAZvB,MAYuB,QACnB,sBAMD,OAnBH,4FAaI,UACA,EAAKqlB,YAAkB9Y,IACvB,kCACE,6EADF,OAEE,aALiB,KAOpB,E,OAnBH,EAwBmB,GAxBnB,EAwBmB,wCAEb,OAAInH,KAAM,SAAN,iBAAiB,MAAkB,SAAS,GAC9C,SAAOkgB,QAAuB,UAAfC,EAASH,OACtBnc,QAAO,c,2DAHN,O,iCAWDwb,IAA+ClY,EAA/CkY,GAAYC,MAAmCnY,KACrD,EAAM0X,EAAc/c,WAAUud,EAA9B,oC,mBAGAC,GAAc,SAAEA,EAAiB,SAAjC,G,WAIA,IAAMzC,EAAWpP,EAAA,EAAM+R,UAAe,cACpC,EAAa,EAAG/R,EAAC,IAAD,GAAa,SAA7B,KACA,IAAM6O,EAAQyB,EAAqB0B,MAAnC,YACM/f,EAAQ,GAAK0gB,GACnB,EAAO,EAAKC,kBAAoB3gB,EAAhC,WAJF,mCAQC2d,OAAK5P,eACL4P,KAAK,EAAW,WACf,eAAOiD,GAHT,OAyCF,SAAc,GACZ,MACD,SAIC,IADF,MAAiB,GACTtgB,EAAO,EAAE0f,IAAf,Y,WAGE,KAAW,OACX,MAAOQ,mBAAe,OAAf,EAAP,OACD,oCAGC,eAMA,I,kBAAMK,MAAY,EAAmB,OAArC,KACA,IAAMxF,EAAN,KACIwF,EAAa5E,GACf,KAAa,OACXZ,QAAU,EAAV,EAAiBwF,OAAa5E,OAAd,IACjB,qCAGDxgB,MAAMolB,CACNC,KAAM,EAFW,KAAnB,O,UAKD,W,SAzEM,CAAP,Q,gCAQArZ,IAAQ8Y,EAAR9Y,GAhDJ,OAiDI,EAAO,gBAAgBnJ,KAAO2gB,gBAjDlC,2B,wCAqDYA,IAAuBnd,EAAvBmd,EAD0E,EAChEC,GADgE,IAElF,EAAM6B,EAAW,SAAGR,EAAe,WAC/BpkB,EAAQ,EAAZ,oDACIokB,UACFpkB,IACD,sBAED,IAAM6kB,EAAY,GAAlB,MACMhhB,EAAK,yBACDghB,EADC,mBAC6B/B,aAD7B,qBACwDC,EADxD,yBAEOC,EAFP,0BAAX,iEAGA,EAAO3a,2BAhEX,wB,uCAoEI,GACA,MAAWyc,OAAX,gEArEJ,0B,0CAyEI,GACCtD,OAAK,cAAI,aAAQ,GA1EtB,4BAAuCD,YAAvC,mBAXA,6B,EAYuB,C,iMCOrB,GAAc,CACd,aAAa,WAAa,uBAAiB,UAAmB,uBAAwB,gBACtF,wBAAkB,gBAAwB,kBAAe,eAAoB,sBAAoB,aACjG,0GAGA,GAAa,CACb,qGAGA,GAAc,CACd,wBAAmB,YAAgB,gBAAc,YAAoB,YAAY,gBACjF,iCAAwB,aAAc,mBAAe,8BACrD,qDAyBA,GAAmB,W,SAAnB,KAEI,WAUE,EAAC,YAA2B,IAAyB,uKAEzD,gC,IAEE,EAAa,CACb,SAAK,EACL,O,GAGFnZ,KAAK,aAAY,IAAI,MAErBA,KAAK,cAAe,GAAG,OACvBA,KAAK,kBACLA,KAAK,gBAEL,KAAI,eACF,EAAgC,CAChC,IAAI,EAAiB,6BAA0B,G,KAC9C,gBAAK,OACJ,MAAK,WACL,EAAK,aAAc,EAAK2c,aAAaC,iBAAiB,EAAKjB,YAAY,WAAW,aAAa,EAAKA,aACnG,qGAgXR,O,EA5WC,UAAAkB,gBAYC,gBAXC,MAAO,K,OACN,GAAO,oBACN,MAAM,YACN,IAAI,EAAY,cAAY,oBAO3B,MANC,qBACA,EAAgB,gBAAO,8BACxB,yBAEA,wBAEA,kB,EAIH,UAAsB,2B,IAAjB,IAAM,IAAO,qBAChB,IAAI,EAAU,EAAiB,GAChC,kF,EAID,UAAsB,yB,IAAjB,IAAM,IAAO,qBAChB,IAAI,EAAU,EAAiB,GAChC,uF,EAID,UAAsB,wB,IAAjB,IAAM,IAAO,qBAChB,IAAI,EAAU,EAAiB,GAChC,iD,EAgBH,UAAAC,eA2BC,WA1BC,IACI,EACJ,EAFI,O,OAGH,KAAK,aACJ,eAAgB7Z,GAEhB,OADA,EAAY,EACZ,oBAEA,MAAI,W,OACF,2BACD,+BAEA,qBAGD,OAAO,SAAQ,GACf,4BAEA,MAAI,SAAY,GAOf,OANC,I,EACe,CACb,OAAQ,EAAK0Y,YAAY,mBACzB,sCAGH,0C,EAIH,UAAe,mBAAiB,SAAa,EAAS,GACtD,IACA,EAAY,EAAD,MADG,CAAD,QAAG,qBAAM,SACX,SAAoB,GAAE,OAAO,EAAE,aAC3C,4C,EAGC,UAAe,mBAAiB,SAAc,GAC9C,IACA,EAAc,EAAK,MADL,CAAD,QAAG,uBACG,kC,OACjB,QAAK,IAAQ,CACb3b,KAAK,SAAO,MAAZA,KAAgB+c,GACf,KAAK,mBAAO,K,MACP,SAAQtB,GACd,IAAI,EAAqBA,EAAS,GAC9BuB,EAAK,KAIR,OAHCA,EAAI,iBACL,MAEA,U,EAIH,UAAY,aAAU,WACvB,mC,EAGC,UAAY,UAAY,SAAE,G,OACzB,KAAK,eACP,qC,EAKD,UAAAC,YAMC,YALC,MAAY,K,OACX,KAAK,aACJ,MAAM,SAAW,GACjB,MAAY,EAAmB,EAAS,IAAC,aACxC,mC,EAIH,UAAY,SAAY,SAAAC,EAAY,G,OACnC,KAAK,eACP,qC,EAKD,UAAAC,WAMC,cALC,MAAY,K,OACX,KAAK,WAAK,GACT,MAAM,SAAU,GAChB,MAAY,EAAyB,EAAE,gBACtC,kC,EAGL,UAAAC,QAcC,gBAbC,MAAY,K,OACX,KAAK,WAAK,GACT,MAAM,SAAU,GAChB,IAAI,EAAS,EAAE,kB,GACb,E,OACC,EAAK,kBAAQ,GACf,oCAEC,IAAAC,EAAaC,EAGd,OAFCD,EAAa,UACb,EAAO,gBAAgB,EACxB,uB,EAIL,UAAAE,YAkBC,kBAlB+C,W,YAClC,IAAZ,IAAoB,EAAa,IAChC,KAAK,UAAI,KACR,MAAI,SAAK,G,GACP,iBACD,yDAEC,MAAY,EAAmB,MAAW,EAAM,iBACjD,oDAGD,MAAK,SAAQ,GAKb,OAJE,EAAQ,oBACT,8BAGD,KAEH,uC,EAGC,UAAa,gBAAoB,SAAC,KAClC,M,SA8Pc,G,IACd,EAAO,EAAE,EAAG,IAAC,GAAU,SAAU,GAChC,oCAEJ,gCAlQe,CAAU,G,OACrB,KAAK,aACJ,kBAUC,O,EATK,aAAoB,YACtB,EAAmB,oBACjB,EACD,iBAEA,oBAIJ,M,EAGwD,8BAAY,S,YAC3D,IAAZ,IAAwB,EAAW,IAClC,KAAK,cAAS,EAAa,EAAQ,GACrC,qC,EAED,UAAAC,cAiBC,oBAjBiE,W,YACpD,IAAZ,IAAqB,EAAa,IAChC,KAAI,SAAa,IAAM,EAAW,EAAS,GAAQ,kBACnD,IAAI,EAAQ,CAAK,OAAE,sCACjB,UACD,2CAGD,MAAY,EAAU,KAAW,EAAO,G,OACtC,EAAI,UAAS,oC,OACX,EACa,EAAc,SAAO,KAAE,SAAU,sBAC/C,mCAEA,U,EAML,UAAY,cAAU,SAAc,G,OACnC,KAAK,yBACP,qC,EAED,UAAAC,YAmCC,oBAlCC,IAAM,EAAQ,KACZ,EAAK,CACLzd,KAAK,UAASkd,GACdld,KAAK,SAAQkd,EAAaQ,GAC1B,qB,OAGD,QAAK,OACG,kBACP,IAAM,EAAgB,mBAElB,KAWJ,OAVE,IACD,0DAEC,GAAgB,SAAF,IACf,+BAEC,IACD,iCAGD,KAEDtE,MAAK,YAAS,OAAD,oEACZ,MAAM,SAAU,GAChB,MAAe,aAAI,0C,OACjB6C,QAAQ,IAAO,CACf,QAAK,QAAU,GACd,qC,MAEG,SAAQ,GAA6D,UAA7C,KAAyB,SAEzD,mDAAsE,O,EAGxE,UAAA0B,mBAkCC,oBAjCS,WAEF,EAAW,iBACf,EAAK,CACL3d,KAAK,UAASkd,GACdld,KAAK,SAAQkd,EAAaQ,GAC1B,qB,OAGD,QAAK,OACG,kBACP,IAAM,EAAgB,mBAElB,KAWJ,OAVE,IACD,0DAEC,IACD,+BAEC,IACD,iCAGD,KAEDtE,MAAK,YAAS,OAAD,yEACZ,MAAM,SAAU,GAChB,MAAe,aAAqC,EAAU,OAAiB,SAAY,GAAE,qBAC7F,4E,MACM,SAAQ,GAA+E,UAA/D,KAAuB,KAAwC,uBAE/F,mDAAsE,O,EAItE,UAAY,sBAAmB,SAAY,K,OAC1C,KAAK,mBAAO,GACX,MAAI,SAAW,G,GACb,GAA8B,SAAf,GAAe,EAAS,CACvC,MAAW,EAAe,KAAC,YAAO,oB,EAC3B,EAAW,QAAI,SAAa,G,IAC/B,IAAM,EAAK,EAAE,EAAAvM,EAAa,MAAI,YAC9B,IAAI,IAAU,MAAS,G,GACrB,EAAY,yBACb,SAGF,YAGJ,a,EAIH,UAAY,mBAAsB,Y,OACjC,KAAK,uBACJ,eAAgB,GAEf,OADD,EAAO,kBAAa,GAAS,OAAa,iBACzC,Y,EAGL,UAAA+Q,aASC,gBARQ,MAAQ,KACX,EAAK,OAA0B,K,OACjC,8BACC,KAAK,eAAW,IAAK,GACvB,uEAEE,KAAK,qBAAW,OAClB,mD,EAGH,UAAAC,UAWC,gBAVQ,MAAQ,KACX,EAAK,OAA0B,K,GACjC,8B,OACC,KAAK,cAAW,IAAK,GACvB,uEAEC,MAAY,EAAU,eAAgB,EAAU,U,OAC/C,KAAK,mBAAW,OAChBzE,MAAK,YAAgB,UAAiB,eAA8B,QACtE,yB,EAIM,UAAQ,eAAE,SAAU,EAAS,EAAC,GACrC,IAAI,EAAM,EAAQ,U,OAChB,SACC,KAAK,qBAAO,OACX,MAAI,SAAO,G,MACc,UAAvB,EAAO,aACR,+BAEA,wBAIJ,qB,EAID,UAAM,OAAe,WAAC,EAAK,EAAY,GACvC,MAAY,EAA+B,QAAkB,a,OAC5D,KAAK,mBAAW,KACf,eAAO,G,OACL,EAAkB,SAAO,SAAU,GACnC,MAAO,EAAiC,EAAC,OAAkB,WAAa,IACvE,sDAGR,EAjZoB,G,SAsbb,GAAa,EAAG,GACtB,MAAO,EAAe,K,OACpB,EAA0B,SAAQ,GAAM,YACvC,yB,SAIC,Q,OACF,EAAqB,EAAI,GAC1B,Q,SAnCc,KACf,IAAI0E,EAAQ,qB,OACV,EACD,IAEA,GAgCA,M,SAIG,Q,OACF,EAAqB,EAAI,GAC1B,Q,SA1Bc,KACf,IAAIA,EAAQ,uB,OACV,GAGD,GAuBA,M,+1DClfmC,GAAkD,Y,SAqBH,IAAW,GAG5F,MAAK,EAAW,KAAG,SAAY,KAC/B,EAAK,YAAc,EAEnB,gBACA,EAAK,eAAwB,gBAAxB,EAAsB,gBAG3B,EAAK,oBAAmB,EAAoB,4BAE5C,EAAK,aAAmBC,EAAiB,GACzC,EAAK,OAAmB,KAExB,EAAM,UAAW,EAA2B,UAE5C,oCACA,MAAwB,EAAgB,YAExC,EAAKC,OAAA,EAAmB,OAExB,eAA4B,iBAC5B,EAAM,YAAe,EAAQ,aAAS,KAGtC,QAAgB,eAChB,EAAK,WAAmC,KAGxC,EAAK,wBAAwB,EAAW,wBAExC,EAAK,yBAA2B,EAAE,qBAAS,EAC3C,EAAK,yBAA2B,EAAG,yBAEnC,EAAM,2BAAgB,6B,EACpB,4BAAyB,8B,IACzB,EAAe,CACf,UAAU,EAAK,UACf,kCACA,oBACA,yBAA0B,EAAE,yBAC5B,2BAA6B,yBAC7B,2BAAmB,EAAY,2BAC/B,0DAEF,aAAc,EAAI,cAGpB,OAFC,mBAED,E,OAlDA,KAAgB,G,EAEd,4BAAM,e,EA0DN,yBAAiC,GACjC,IAAM,EAAQ,KAEZ,EAAU,EAAE,6B,GAEX,OAEG,SAGJ,gBAAsB,2BACtB,EAAQ,KAAU,KAAG,EAAkB,MAAA9a,EAAQ,UAAY,KAG3D,EAAI,WAAS,iBAAE,aAAa,cAG5B,IAAAyJ,EAAS,EAA2B,eAGpC,OACA,EAAM,uBAAgB,EAAiB,G,IAE/B,EAAuB,KAAe,UAAgB,Q,GAC5D,EAAW,OAAU,CACrB,MAAS,EAAQ,IAAR,CAAQ,OAClB,EADkB,KAEb,EAFa,KAMnB,SAAwB,GACpB,EAAQ,EAAS,YAAW,G,OAE9B,EAAK,WAAgB,EAAO,YAAU,EAAa,qBAa9CA,EAAO,YAAS,IAEpB,UAEQ,EAAO,gBAAc,SADvB,GAGP,EAAW,YAAC,EAA+C,EAClD,EAAO,mBAAc,OAE9B,EAAW,YAAC,EAAqC,EACxC,EAAO,kBAAc,KAE9B,EAAW,YAAc,EAA6B,EACjD,uBAGN,GA3BE,wBAIA,+BAEA,kBAAM,qBAGR,GALY,EAAO,iBAAc,MAAa,GAFlC,M,OA8BZ,QAAK,MAAI,cACR,OAAsB,WACrB,kBACN,mB,EAGO,UAAuB,0B,IAC3B,EAAO,K,EACE,C,QACP,EAAO,QAAY,cAAY,GAGjC,OAFE,EAAO,aAAO,eACd,wBACF,MAUJ,OANI,UACD,yCAED,EAAO,cAAe,UAAM,YAG9B,qD,kDASM,C,QACE,C,CAED,+BACF,8BAML,4D,EAIM,UAAY,iBAAS,kBACzB,IACE,EAAU,EADN,O,OAKJ,YAAa,mBAAqB,EAHlC,CACF,SAAY,QAGV,eAAY,GAEZ,OADC,GAAK,UAAM,UACZ,EAAW,yBAAqB,c,MAC5B,SAAK,GAKZ,O,GAJY,IAAI,MAAC,UACb,kBACD,QAAO,IAAO,2DAEjB,M,EAMK,UAAkB,6CACtB,MAAQ,K,OAGR,EAAI,UAAW,0B,EACb,c,SAsdY,G,IACd,EACC,oCACC,MAAyB,kBAAlB,EAAI,YAEd,+BACD,EAAoB,EAAC,WAGvB,OAAS,EA/diB,CAAY,IAAe,EAAE,WAClD,EAAM,6BAIiB,iCAGzB,gEAED,yB,SAud0B,EAAc,GACxC,MAAO,uBAAuB,IAC5B,EAAe,EAAiB,qBAAW,EAAe,kB,SACnC,EAAG,OAAa,YAK1C,O,EAJQ,WAAgB,OAAU,kBAC9B,eACM,QAAU,EAAC,0BAErB,KA/dkB,CAAO,S,EAEhB,UAAiB,2BAAM,G,IAE3B,EAAO,EAAU,EAAC,QAA6B,OAAE,QAChD,oCACH,OAAO,EAAiB,WAAsB,EAAW,eAG3D,qBAA4B,O,EAEpB,uCAA+C,SAAW,EAAa,GAC7E,IAAM,EAAuBsR,GAAiBtR,EAAOuR,UAAW,aAC1D,EAAuBD,GAAuB,EAACC,UAAW,aAEhE,KAAiC,sBACjC,EAAkB,KAAE,UAAU,S,KAErB,EAAW,mCAGpB,OAFI,kCAEJ,MAGC,WAED,EAAqB,WAGnB,EAAK,QAEL,IAAM,IAAe,QAAM,cAC3B,EAAM,EAAU,IAAV,CAAqB,G,IACzB,EAAO,EAAU,EAAC,QAA6B,kB,EAKrC,EACT,OALA,sCAEH,SAAmB,4BAGhB,KACJ,eAYH,OANE,gBAA0D,iBAI3D,iCAED,G,EAEQ,UAAgB,uBAAE,SAAY,EAAW,GAE/C,IAAG,oCACC,MAAe,cAAf,MAAe,Q,GAEjB,G,IACE,EAAO,EAAa,UACtB,EAAG,yBACJ,sD,EAOY,UAAG,4B,IACd,EAAQ,K,OAIR,KAAO,OAAK,mBAAqB,EAHjC,CACF,SAAY,SAGT,kBACJ,0C,EAMY,UAAU,gBAAQ,kBAC7B,MAAUle,KACVya,EAAU,U,OAEV,EAAK,KAAS,wC,EACZ,EAAU,oDAKV,KAAO,OAAK,iBACX,kBACJ,gDAJY,I,EAUX,6BAA0C,gBAC1C,IAOI,EAPA,EAAO,K,OAEV,yDAEG,I,EAIF,eAAyB,8B,EACzB,eACK,OAIe,yBAAmB,gC,EAGxC,YAAK,c,6BACJ,MAAI,SAAQ,G,IACV,E,OACD,iBACD,EAAY,EAA0B,SAAW,EAAQ,WAAS,yDAC9D,gBAAA0D,EAAgB,EAAK,QAG7B,wDAAmC,U,EAClB,UAAY,2BAAU,KACrC,MAAY,K,EACN,KAAO,O,OACJ,YAAe,sBACtB,MAAI,SAAY,G,IACd,EAAM,EAAU,U,GAChB,EAAM,OAAS,CACf,IAAM,EAAU,oBACd,IAA6B,QAAW,iBACxC,GACA,YAAa,EAAClS,SAAc,YAC5B,aAAU,EAAQ,sBAClB,MAAM,EAAQ,eACd,WACI,UAEJ,EAAY,QAAc,O,OAC1B,QAAK,IAAO,CACZ,8B,EACI,iBAAmB,KACvB,eAAO,GACN,kBACJ,2CAGA,+B,EAIY,UAAY,uBAAS,EAAC,KACrC,IAAM,MAAY,EAAG,UAAW,IAAS,EAAG,EAKtC,EACA,EAJF,EAAQ,YACR,EAAa,EAAQ,iDAKnB,IAAoB,cAAiB,GAAsB,WAGjE,EAFgB,EAAM,kBAEO,8CAC7B,GAAiB,KAAO,yBAAqB,EAE7C,IAAM,EAAYjM,KAAKoe,oBAAsC,QAAnB,EAACzR,EAAO,aAAW,sBAAE,EAAQ,YACjE,EAAW,KAAO,oBAAiC,QAAZ,EAAD,EAAO,YAAM,sBAAQ,EAAE,YAE7D,OAAgB,oBAAuC,QAAlC,EAAmB,EAAC,mBAAc,eAAE7R,OAAQoI,EAAQ+U,YACzE,EAAajY,KAAKoe,oBAA+B,QAAZ,EAACzR,EAAO,aAAI,eAAE7R,OAAQoI,EAAQ+U,YAEnE,EAAc,yBAED,QADd,EAAM,EACTpL,eAAgC,IAAb,OACf,EAAU,EAAE,SAChB,YAEF,mDAAwE,oCAClE,EAAgB,GAAU,GAAS,GAAI,GAAM,SAAc,CAAE,OAAE,qBAEjE,EAAS,EAAG,kCACd,S,EACA,SAAI,SAAa,GAGb,WAAe,K,IAwBnB,EAtBA,EAAW,CACX,OAAK,IAAS,GAAO,SACrB,kEAEE,MAAqB,QAAb,EAAK,EAAM,eAAE,sB,GAExB,cAEG,EAAO,KAAO,GAEjB,6HAED,EAAW,gBAAO,2BAAa,IAAX,OAAa,mBAEb,QAAlB,IAAI,eAAc,2BAAE,C,IAClBwR,EAAa,OAAU,EAAC,KAAO,iBAAC,gBAAI,IAAc,QAAP,EAAO,4BAAE,EAAW,mBAChE,wDACD,EAAgBA,EAAU,QAAG,SAAW,qFAGtC,aAA0C,E,OAG5C,IAAgB,GAAgB,WAChC,WAA0B,EAC3B,W,EAAM,2CAID,EAAmB,KAAO,OAAK,uBAElB,aACjB,E,IAEA,eAAU,GACV,MAAe,EAAC,U,OAChB,yBACIC,KAELlF,MAAK,SAAAkF,GAAY,UAAgB,qBAAkBA,MACnDlF,MAAK,SAAAkF,GAAY,UAAgB,mBAAaA,EAAgB,MAC9DlF,MAAK,SAAAkF,GAAY,UAAgB,oBAAqB,MACtDlF,MAAK,SAAAkF,GAAY,UAAgB,eAAoB,MAEtD,MAAO,SAAAA,GAAsB,UAAQ,6BACnC,MAAM,SAAAA,GAAoB,UAA2B,oBAAW,QACzD,MAAkB,YAE5B,OADI,sB,8IAQ4C,EAAvC,O,sBAAuC,GAArC,KAAAC,OAAa,kB,KACjB,E,OACJ,EAAI,WAAmB,sC,EACrB,uBAAW,EACZ,IACD,2BAAO,U,CAEL,EAAO,CACP,OAAO,UACP,gB,iBAEF,E,SACE,oBACU,G,CACR,EAAY,CACZ,OAAO,QACP,gBACH,oB,EAEG,MAAQ,EAAO,a,CACf,EAAO,CACP,OAAO,QACP,4BACH,yBAEkB,iBAAf,E,CACA,EAAO,CACP,OAAO,QACP,sBACH,a,QAGG,O,CACA,EAAO,CACP,OAAO,QACP,0BACH,4C,2BAiBC,UAAa,yBAAE,EAAe,GAElC,IAAI,EACF,EAAO,EAAoB,e,IAC5B,EAEG,OAAO,QAAK,QAAK,IAEN,iBAAb9iB,IAGF,EAAmB,EAAiC,M,IAClD,MAAU,EAAC,EAAK,CAAG,QAAK,qBAAoB,QAAgB,EAAK,EAAC,YACnE,WAEO,EAAmC,GAAU,KAAxC,oBAAwC,EAAhC,GAAW,I,IAG9B,EAAK,YAAmB,KAAK,yB,OAC3B,a,KACA,GAAM,QACR,EAAK,sBAAmB,EAAI,OAC1B,M,KACA,GAAM,OACR,EAAK,qBAAmB,EAAW,cACjC,M,KACA,GAAM,cACR,EAAK,oBAAkB,EAAK,4BAC1B,M,KACA,GAAM,OACR,EAAK,qBAAmB,EAAU,mCAChC,M,KACA,GAA4B,aAC5B,MAAM,uBACR,+CACE,M,QAEH,sBAID,OAAG,oBACJ,yB,EAOgB,UAAU,gBAAkB,SAAS,GACpD,IAAM,EAAQ,KACR,EAAS,EAAU,SAAc,SACjC,EAAW,KAAE,KAAQ,EAAW,mBAEtC,YAAoB,mBACd,IAAuB,WAE3B,EAAgB,CAChB,QAAQ,2BACR,gBAAM,EACN,WAEE,U,GAEF,cAAgB,CACjB,2EAEK,EAAc,WAAK,EAEzB,IAAM,EAAYuE,KAAKoe,oBAAoBI,EAAW,UAChD,EAAW,KAAG,oBAAU,WAE9B,EAAY,KAAO,oBAAmB,EAAa,YAAY,I,OAE7D,+BAAiC,WAD7B,EAC6B,GACjC,MAAM,SAAW,G,IAEf,EAAW,sBAAE,EAAO,QAAU,I,SACrB,KACT,EAAG,0BACJ,qCAEG,IACF,EAAG,0BACJ,6B,uBAKU,EAAe,wBACrB,MACJ,mEAKC,EAAkC,qBAClC,IAAI,EAAuB,EAAE,kBAC3BC,EAAiB,G,OAClB,iBAED,EAAO,yBAEL,CACA,MAAY,MAAZ,QAAsB,eACtB,KAAe,IAAThmB,EAAE,UACR,WAAM+lB,EACN,cACD,e,EAMU,UAAS,uBAAuB,SAAQ,KACvD,W,EAEoB,UADd,SAAa,OAAS,cAAS,SACT,YACzB,oBACA,gE,EAID,WAAc,yBAAE,EAAQ,WAAS,c,EACf,UAAK,EAAU,uB,SAC7B,EAAyB,MAAQ,EAAM,QAAQ,SAAW,G,MAC3D,oBAAM,iDAGN,6C,EAMC,UAAgB,YAAU,YAChC,IAAM,IAAqB,GAAC,EAAK,KAC3B,EAAgB,KAAC,KAAM,EACf,aAAc,sBAC1B,EAAU,KAAW,OACrB,yBAGN,OAFoB,KAAC,cAClB,Q,EAhqBqF,CAmqBxF,EAAS,e,SAED,GAAc,K,IAClB,EAAO,EAAWre,EAAA,QAA2B,GAAU,QACtD,4BAEH,OAAO,EAAE,EAAI,WAAiB,e,OAE5B,EAAoB,MAAa,GAAa,SAAC,GAElD,OADI,kBACJ,mC,SA2BG,GAAMue,G,MACN,CACA,YACH,e,SAcG,GAAO,G,MACR,mBAEK,EAAgB,KAIf,IAFR,eAEQ,KAA2B,KAAM,I,SAEtC,GAAa,G,MACd,mBACM9mB,EAGT,Y,SAUM,GAAW,EAAmB,K,IAChC+mB,EAAiB,EAAO9kB,QAAA,EAAqB,EAAC,IAKlD,OAJG,gBACD,EAAqB,KAAC,QAGf,E,sWCvwByB,GAC6C,G,MCqG7E,GAAgB,Y,SAKd,MAA2C,OAC3C,MAAK,YAAsB,EAAK,IAAW,KAiJ3C,OAhJA,EAAK,SAAc,WAAY,O,EAG5B,oBAA0B,aAAe,oB,EACzC,YAAa,E,EACb,YAAO,CACR,CAACjC,MAAO,WAAa,UAAM,UAAe,EAAW,GACrD,CAACA,MAAO,YAAa,OAAM,UAAe,EAAW,GACrD,CAACA,MAAO,YAAasG,KAAM,cAAexC,UAAW,EAAgB,GACrE,8CAEF,CAAK,MAAO,WAAU,KAAG,0BACvB,OAAS,qCAAc,M,EAEvB,OAAS,WAAE,CACX,QAAQ,EAAa,EACrB,OAAU,EACV,UAAU,EAAe,EACzB,WAEF,SAAK,EAAkB,EACrB,SAAO,EAA6B,G,EAEnC,gBAAiB,CAClB,CAACxE,KAAM,kBAAgB,UACvB,CAACA,KAAM,eAAa,OACpB,mCAEF,CAAK,oBAAe,wBAClB,CAAE,KAAM,YAAa,SAAS,iB,EAE5B,aAAc,CAChB,CAAEgH,KAAM,cAAYtG,MAAO,QAC3B,CAAEsG,KAAM,aAAY,QACpB,CAAEA,KAAM,SAAUtG,MAAO,MACzB,CAAEsG,KAAM,WAAWtG,MAAO,OAC1B,6BAEF,CAAK,cAAa,YAChB,CAACsG,KAAM,gBAAgB,O,EAEtB,WAAM,CACP,8BAEF,CAAK,sBAAoB,SACvB,qBAAc,U,EAEd,kBAAc,CACd,eAEF,iBACE,gB,EAEE,aAAM,CACR,iCAEF,CAAK,mBAAmB,oBACtB,CAAEA,KAAM,WAAiB,MAAM,a,EAE7B,iBAAkB,CACpB,yBAEF,CAAK,gBAAmB,KACtB,CAAEA,KAAM,WAAYtG,MAAO,I,EAEzB,oBAAsB,CACxB,mCAEF,CAAK,uBAAyB,gBAE9B,CAAK,eAAe,MAAG,YAGvB,EAAK,cAAgB,2BAAO,eAAK,MAAgB,QAAM,MAAY,UACnE,EAAK,gBA3HA,EAA4B,EA6HjC,EAAK,cAAe,EAAC,EAACO,KAAK,EAAKymB,eAAgB,EAAM,aACtD,EAAK,aAAa,EAAG,EAAC,KAAK,EAAK,eAAe,EAAM,YAAE,GACvD,EAAK,oBAAgB,EAAM,EAAC,KAAK,EAAAA,eAAoB,EAAE,WACvD,EAAK,aAAe,IAAEzmB,KAAK,EAAK,iBAAsB,YAEtD,0CAA8D,mBAC9D,gBAAe,IAAiC,KAAE,iBAAM,EAAK,aAE7D,wBAAkD,0B,EAE3C,uCAAe,0CAGtB,EAAK,IAAI,qBAAG,WACV,EAAI,kB,EAGJ,KAAS,WAET,IAAM,OAAa,O,EAEjB,EAAW,G,IACX,EAAgB,CAChB,UACF,YAAe,EAAE,eAAe,QAEhC,iBAAsB,+BAEtB,IAAEoV,SAAA,KAAa,G,IAGb,EA5MJ,CACA,UAAQ,EAAc,EACtB,cAAe,IACf,KAAM,CAAE,OAAU,IAClB,YAAa,YACb,MAAQ,OAAE,I,UACD,G,SACP,CACA,SACD,cACD,aAAkB,GAElB,QAAQ,CAAAzS,OAAU,IAClB,MAAO,OAAE,I,MACP,Y,QACA,CACD,qBACD,iBAAO,G,MAEN,CACD,qB,EAyLmB,eAAa,KAC7B,wBAED,cAA4C,EAC5C6R,EAAO,QAAY,W,SA/JK,G,IAC3B,EAEK,SAAW,EAAE,EAAG,O,QACjB,EAAe,GACd,IAAS,EAAO,kB,IAClB,EAAW,EAAe,GAC3B,QACF,mBAIH,SAmJyB,CAAa,KAAS,MAAE,kBAI3C,EAAI,UAAO,EAAc,mBAAkB,YACzC,SAAE,EAAA2J,IAAA,EAAa,WAGb3J,EAAOjR,YAAc,EAAe,GACtC,IAAEkR,aAAaD,EAhMnB,CACA,wCACH,qBAiMSA,EAAOjR,YAAc,EAAc,GACnC,EAAqB,iBA7L3B,C,aACE,GAAc,W,QACd,CACA,YAAY,EACZ,uBACA,aAAW,EACX,oBAAO,EACR,aACD,aAuLMiR,EAAOjR,YAAc,KACvB,EAAK,YAAc,KACpB,mB,EAAU,YAAgB,EAAK,EAC9BsE,KAAK,cAEP,mBAEF,0BAKA,EAAS,MAAG,aACZ,EAAK,oBAAwB,GAAyB,GACvD,SAED,8CACQ,E,OAtJR,UAAY,UAAQ,YAAW,aAAkB,sB,GAC/C,EAAc,G,EAuJG,iC,IACf,EAAK,EAAe,2DACpB,EAAK,EAAY,EAAE,WACnB,EAAK,CACL,qBAEEA,KAAK,eACP,oBAWJ,OARMA,KAAK2M,OAAOjR,YAAc,KAAiB,6BAC7Ckd,EAASjf,KAAKqG,KAAK,iBAGrB,KAAO,OAAQ,YAAc,KAC9B,8BAGD,gB,EAIE,UAAE,eAAa,SAAY,EAAW,G,IACpC6e,EAAQ,EAAuB,EAAK,KAAC,gCAWvC,OARA,EAAiB,kDACfA,EAAQC,QAAQ,IAAM,EAAE,SAG1B,GACD,kBAGQ,G,EAEJ,0CACJ,uDAED,qB,EAEQ,UAAM,yB,IACV,EAAK,K,OACL,KAAO,OAAO,eACb,kBAGL,OAFC,qBAED,M,EAEoB,UAAC,aAAwB,W,MACrC,KACJ,EAAY,yBAAiB,0B,OAC7B,KAAO,OAAM,eACZ,kBAGL,OAFC,oBAED,M,EAEqB,UAAK,YAAoB,WAC5C,MAAY,K,EACN,yBAAI,0BACR,EAAY,yBAAe,yB,OAC3B,KAAO,OAAK,gBACX,kBAGL,OAFC,mBAED,M,EACsB,UAAK,aAAoB,SAAK,GAClD,IAAM,YACY,IAAZ,IAAiB,SACvB,IAAM,EAAU,mDACd,EAAU,KAAQ,6CAClB,OAAiB,oBAAc,KAAQ,mBAAiB,QACxD,GAEF,SAAY,E,kBACC,KAAW,OAAE,QAAY,mB,OAEpC9e,KAAK,OACL,YAAa,SACZ,kBAGL,OAFC,oBAED,M,EAEQ,4BAAU,W,IACd,EAAK,K,OACL,KAAO,sBACN,kBAGL,OAFC,yBAED,M,EAEQ,UAAQ,0B,IACZ,EAAM,K,OACNA,KAAK,OAAO,aACZ,eAAe,GACd,wBAGL,OAFC,qBAED,MAIA,oBAAU,SAAV,GACE,OAAO+e,EAAA,MAGT,uBAAY,SAAZ,GACE,OAAM,EAAa,EAAC,OAAU,YAAa,Y,EAE3B,UAAG,aAAU,W,IAC3B,EAAK,EAAgB,yBACtB,0CACF,iBACD,uBAIA,oCACE,MAAI,IAAK,kC,EAER,sCACF,4BAED,sB,EAKa,UAAa,oBAAsB,W,MAC1C,K,OACD,qD,WAAM,iCACE,EAAM,kDASnB,wBAA0C,aAK1C,wC,EAGiB,UAAU,yBAC1B,mBAED,mBACE,KAAM,UAAU,W,EAEJ,UAAe,YAAS,YAEpC,IAAI,EAAC,EAAoB,GAEzB,EAAI,OAAQ,E,KACR,OAAQ,UAAU,KAAC,G,KACrB,qBACD,0BACF,0BAED,sBAGA,EAAC,qCAED,kCAAiB,KAAE,OAAM,aACvB,KAAM,iB,EAEN,UAAE,aAAiB,SAAS,EAAO,GACnC,IAAI,EAAC,KAAApS,OAAgB,qBAGvB,IAAAqS,KAAA,6BACE,KAAM,iB,EAEH,uCAEH,IAAIC,EAAW,4CACb,MAAwB,UAAnB,EAAO,gBAEb,IACF,2DAED,gCAIA,+BAAmB,WACjBjf,KAAK,kBAAmBA,KAAK,kBAE/B,EAAC,yCAED,2BAAAkf,yBACE,KAAM,gB,EAEJ,4CAEF,IAaC,K,KAAU,OAAK,YAAgB,EAAK,EACnCC,EAduB,CACvB,kBAAc,uBAgBV,KAAU,OAAG,+CACnB,EAfmB,CACjB,6BACA,aAAO,eACP,gBAAW,oBACX,+CAEE,uBAEA,UAAW,e,MASP,G,SACF,yCAAyD,G,MACzD,EAAa,G,IACd,MACC,iBAEA,C,IAEC,I,GAAUvnB,EAAS,KAClBwnB,EAAcxnB,EAAM,KAEd,GAAK,EAAW,QACzB,WAEF,yB,4BAcS,uCACZoI,KAAK2M,OAAA,UAAgB,EACtB,oDACH,YAnb2C,sB,EA4BzB,C,irBD3FhB,IAAe,QAAL,GAAE,sBAAG,kCAGf,GAAe,aAAG,U,KAQH,OACT,GAAY,8B,MAEX,YACD,OAAI/U,K,EAGD,sBACF,sBAMH,aAAM,qB,MAGH,YACD,MAAY,MAAZ,G,aAKN,8CAGA,IACA,GAAe,SAAU,GAEzB,IAAI,IAAU,MAAqB,GAAX,MAAW,6DAEjC,EApCD,mBAEG,qBAA2B,IAA3B,CAA2B,iFAC/B,cAAC,UAAqB,IAArB,CAA2B,KAAG,8EAiC7B,CADE,OAAe,GAAwB,SAAvC,IAEH,e,UAAU,QACTynB,EAAaC,EAAO,cAIpB,iBAOF,gB,kaElEkD,O,qKAAA,uB,GA+CjD,Y,SAvCC,EAAS,G,IACT,EAAO,EAAE,mB,KACP,WAAO,CACT,CAAE1nB,MAAO,KAAmB,MAAM2nB,MAAO,SACzC,CAAE3nB,MAAO,KAAmB,WAAY,QACxC,6CAEF,UAA8B,qBAC5B,UAA4B,mBAAmB,gB,EAE/C,SAAa,CACb,kBAAQ,iCACR,UAAW,GAAI,QACf,MAAM,OACN,QA+BF,eACE,KAAM,I,oBAEa,c,IAGjB,EAAQ,EAAC,cAAc,M,EAEvB,UAAO,YAGN,eAGL,OAFC,OAED,GAAoB,U,EAGlB,kBAAoB,WACrB,4BAED,aAAwB,EAAC,MAFxB,QAEyE,KAFzE,OAEyE,YAFzE,cAEyE,KAFzE,QAGC,EAAK,eAAS,kB,EAOd,sBAAkB,SAAmB,GACrC,EAAM,SAAU,GAAgB,GAAa,KAAW,0BAAS,uBACjE,MAAK,EAAM,MAAS,IAAY,QAAY,OAAW,EAAE,uBAC1D,UAzDK,EAAgB,WAAW,EAAW,MAAK,EAAK,KAAU,wBAC5D,mBAAyB,gBAEzB,EAAM,aAA6C,iBAAzB,EAAK,YAA2B,CAM3D,iCAAM,EAAsB,oCAC3B,EAAM,MAAS,GAAmC,wDAElD,GAAI,EAAM,MAAG,OAKd,gBAAM,sCACL,EAAK4nB,MAAQ,GAAc,oDAE9B,mBAGC,OAAO,E,UA3CgD,KA+EzD,oEAuEC,yC,EAnEG,4B,IACE,O,EACE,iCAAC,EAAgB,EAAO,YAAE,EAA8B,0C,OACxD,mBAAC,GACM,EAAE,SACA,KAKX,0BAAKC,UAAU,wBACb,sBAAgB,gBAAD,yB,GACb,mBAAC,iBAAe,MAAM,EAA6B,+D,GACnD,uBAAC,UAAW,kBAMb,GAAuB,gBAAK,yCAC3B,sBAAgB,gBAAD,oB,GACb,mBAAC,SAAe,SAAU,YAAwB,wE,EAClD,WACE,SAON,GAA4B,iCAAmB,wBAC/C,GAA4B,mBAAuB,mCACnD,GAA4B,0BAAmB,EAAW,8F,EAC1D,WAAe,e,EACb,WAAc,EAAC,M,EACb,WAAC,e,GACD,uBAAC,UAAW,kBAMb,GAAmB,EAAK,cAAK,yCAC5B,GAAuB,gBAAK,mBAAkB,CAAC,UAAW,eAC1D,sBAAK,OAAU,WAAsB,2F,EACnC,WAAC,Q,EACD,WACE,EAAK,aASF,GAAD,yDACV,mBAAK,GAAmB,mCACtB,mBAAC,IAAgB,QAAS,SAAU,uCAAkC,EAA+B,2C,GAS9G,+CACH,GAAC,yGAxJ8C,GAwJ9C,mD,EA/GE,C,siBC/CiD,U,qDAU1C,GAAkC,SAAzB,uBAmNlB,GAAC,mCAEI,M,uFAcL,GAAC,mCAEI,M,kFAcL,GAAC,mCAEI,M,mGAcL,GAAC,mCAEI,MAQJ,EAAM,GAAa,GAA8B,wBAAY,GAAsB,GAAO,8CAE1F,GAAmC,qCACnC,MAAS,oBACJ,GACH,OAAU,kBAKb,EAAC,2BAEI,IAAyB,MAC7B,EAAI,GAAU,GAAgB,GAAW,GAAS,wEAElD,GAAc,WACd,4CAGA,OADI,YAAuB,2CAG3B,GAAc,W,OACd,K,qGC9SF,W,KASE,6BACA,UAASC,oBAGe,wBASlB,O,mBAEAC,MAAOC,I,EA8DT1L,SAAA,GACD,OAFD,4B,OAGA,wBACC,EALH,gB,IAQF,I,IAjEQ,EAAI2L,aAoEN3hB,SADK,GAEL4hB,SAAStW,SAAY,SAAS5R,EAAT,GACnB,OACEsG,OACA6hB,QAAK,EAAE,EAAuBnoB,IAAK,GAA5B,SAFT,G,OAHJ,Y,+CAnEkBooB,CAAEC,GAEhBJ,MAAQK,K,0QAERC,EAAOC,SAAK,GACZD,EAAOE,SAAU,GAEfC,OAAS,eAFM,aAGfvmB,EAAK,UAHU,CAIfwmB,OAAO,EACL,UAAI9J,EACJ,MAAKA,GACH,oBACA7e,M,SlB8XL,GACR,YkB/XqBA,CAAMwR,GACdqN,OAEC,EAFD,gB,0BAIA,OAAyB,IAApBA,EAAW,cAAS,e,4BAO3B0J,EAAOtT,KAAP,kB,wBAQFsT,EAAM,OAAN,WAHFN,EAAA,O,SAMAM,EAAOK,W,oBAIPL,EAAOM,YAAK,OAAW,iBAGrBC,QAAU,WAGRb,YAAQc,WACRtgB,EAAKugB,QAJG,EAAV,OAHF,S,wBAWAlB,QAzER,wB,aCLsD,W,OC0BnD,YAED,SACE,YAGI,GACE,gBAA0B,OAC1B,WACA,8DAIR,wFAEW,qFAIV,qB,GAMoB,Y,MACf,EAAO,KAAM,kE,OACb,GAAgB,gBAAe,cAChC,eAED,aACA,iCAMA,2BAAMD,UAAU,2BAA4BoB,QAAO,WAAE,OAAM,QAG/D,2F,6hBCjEF,O,qKAAA,MAAmC,iB,GAkBnB,SAKb,G,SAED,EAAa,G,MAAM,YAAoB,SAuCvC,O,EAtCQ,WAMG,GALG,c,EAMJ,uBAAuB,GAE/B,IAAI,EAAoB,uBACtB,IACE,uBAAK,EAAO,YAAY,EAAM,EAAE,SAAW,EAAO,EAAE,OAAmB,c,OACrE,2BAAiC,GAAI,uG,GAAO,6CAC5C,IAGL,EAGC,KAGI,GAAsB,gBAAM,eAG9B,GAAa,wDACX,EAAW,EAAK,MAAM,MACtBC,KAEF,uBACE,EAAK,EAAW,Y,uBAEb,WACJ,EAEH,6CACF,Y,SAvCD,uBAyCD,E,UAjDqB,K,EAqDN,UACL,kB,MACG9gB,K,UAOmB,EAAE,iBAA6B,8F,UAChC,mC,EACd,YACa,GACH,EAAE,cAA0B,2I,EAAvB,SAAU,qBAAE,IAAgB,KAE3C,aAEJ,0BAED,qBACK,EAAE,UAGH,UAAa,gF,GAGA,EAAE,cAEhB,OAAK,KAAM,EAAS,WAGzB,2CAGN,IACH,qCACH,MAAC,gD,EAtFe,C,6BCAd,GAAO,K,gBAIG,I,KACN,SAAoB,EAAK,GACzB,IAAI,OALO,yMAMP,SACA,IAAa,KAEb,GAAC,EACH,EAAmB,EACnB,O,SAcM,EAAe,GAGrB,MAAW,KAAyB,MAEpC+gB,EAAO,EAAY,eACnB,EAAa,SACbZ,EAAO,IAAI,EAAG,WACd,EAAO,YAAQ,oBACf,EAAM,OAEN,EAAM,OACN,EAAI,Q,EACF,S,IACAE,EAAU,EAAS,kBACpB,IACF,UAED,EAAS,U,SAiBN,KACD,OAAK,sBACI,gBAET,EAAU,8BACX,oDAGC,G,SAGA,EAAa,EAAY,GAGzB,IAAM,EAAQ,KAAc,GAC5B,aAAe,GACf,EAAe,KAEf,eACI,EAAS,EAAM,KAAI,UACrB,EAAK,EAAY,OAElB,yBAED,gBAA0B,GAE1B,EAAO,KAAQ,EAAD,yCAtCV,IAAkB,kB,OAIlB,EACF,YAAQ,WACT,IACF,OAEQ,OAiCP,EAAI,QAAM,WACR,qB,EACK,qCACL,EAAM,6BAIRW,EAAU,YAAG,oBAGf,SACA,EAAS,O,SAGP,KAEA,MAAa,KAGd,yBAED,EAAS,EAAyBC,KAChC,K,SAEE,IAAE,GAEL,cAED,KAAqB,aAGrB,SAAC,IAGC,WAAW,MAA8B,GAA7B,OAAgB,cAAa,K,SA+BnC,IAEN,EAAO,SAAY,GAInB,I,IAHEC,EAAU,EAAK,QAAE,EAAO,IAAI,QAC7B,yBAED,iBAAE,EAAK,QAAW,GAAa,EAAa,UAC1C,EAAU,OAAwB,EAAM,OAAQ,GAAE,kB,EAEjD,wBAED,GAAI/nB,EAAA,UAAa,SAAY,SACvB,SAGN,IAAI,EAAa,EAAW,sCAC1B,EAAW,QACZ,uCAEG,GAAQ,EAAG,WACb,OAGI,KAEF,KAAQ,sBAAyB,qD,IAEjC,EAAY,KAAsB,kDAClC,EACF,wBACI,MACN,EAAY,EAAe,UAE3B,QAEA,EAAW,KA7LF,8FA8MX,OAhBEgnB,EAAO,mBAAe,QAEtB,IACA,EAAO,SAAM,GACbA,EAAO,SAAS,GAChB,OAAW,EAAM,UAAE,EAAQ,IAE3B,EAAI,MAAM,G,EACR,SAAY,EAAgB,gB,EAC7B,wBAED,EAAO,S,SA3EI,EAAY,G,EACvB,KAAO,eAAG,a,MACR,EAAW,GAAW,QACrB,QAAH,EAAG,+BACJ,yBAEM,SAAU,e,EAGf,UAAS,CACT,OAAO,E,UACE,E,MACP,G,QACA,SAAa,GAIX,OAHH,SACA,UAEY,KAGD,EAAO,KAAK,aACxB,kBAGJ,OAFC,mCAEQ,kBAAqB,SAoDzB,OAIM,KAGX,KAAS,kBAA0B,YACjC,EAAI,EAAO,WAAX,CAAuB,G,SAcvB,IACD,sBAED,I,EAdM,KAAI,Q,OACD,OAAK,E,YACL,W,EAEE,kCACR,QACF,UAEQ,KAjNTgB,EAAK,qBAAiB,SAAI,GACxBA,EAAK,eAAaxK,IAGpBwK,EAAK,eAAe,SAAGxK,GACrBwK,EAAKC,aAAazK,GAAO,IAG3B,kBAAuB,SAAY,GACjC,qBAiNP,M,mDHtPiB,O,GACL,YAAe,GACxB,iBACC,YACJ,iBITD,wEAEgD,wC,IAQvC,GAAc,WACvB,cAIA,OAFA,cAAkC,qDAElC,EALuB,G,GAOd,2D,OACN,gB,CAAA,CAEU,sE,MACV,oE,OAEA,MAAuB,qBACvB,iBNXuD,YAClD,QAEN,cAAwC,kBACxC,YAAU,SAAV,CAAU,oBACA,SAAQ,GAAE,SAAV,CAAU,MAA4B,OAAC,K,cAGvC,GAAsC,U,EAA9B,WAChB,IAAI,EAAC,EAAgB,8B,EAEV,EAAC,SAAiB,EAAG,mB,IAC7B,6BACDzT,EAAQme,iBACT,qBAaGne,EAAQ,eAAS,Y,EAEX,GAAiB,GAAS,MAA2B,wE,EAC3D,4B,KACK,SAAC,yBAiBN,CACD,kFACF,6BACI,cApBO,C,IACN,EAAQ,sC,SACa,iB,GAAA1L,IAAA,G,MACnB,Y,GACA,GACA,MAAgB,uBACJ,OACV,EAAU,aAKb,6BACA,UACJ,wF,IAkBC,sBAAc,WAAc,K,GAC5B,mBAAe,6EAAsB,qD,GACnC,uBAAC,UAAS,iBASZ,mCAAc,gBAAC,sB,GAEX,yD,GACE,mBAAC,CAAS,WACR,EAAU,WACV,GAAY,MACZ,WAAM,MACN,EAAU,SACV,UACA,YAAY,GACZ,+B,GACF,uBAAC,mCAA0D,QAA1C,IAAqB,wBAAqC,IAAD,OACxE,cACJ,mBAAC,GACW,EAAE,SACZ,KASN,mBAAO,GACC,YACN,aAAoB,GACpB,MAAS,WAAQ,UAAS,EAC1B,MAAU,8BAEH,GAAe,iEACtB,yN,GACE,0BAAK,SAAS,WAAU,gE,WACtB,Q,GAWF,mBAAc,EAAC,SAAS,K,GACtB,sBAAC,WACC,WAYR,mBAAK,GAAU,YAAS,oQACtB,mBAAC,MAAS,CACR,UAAU,WAWhB,mBAAK,GAAU,YAAe,2TAC5B,0BAAIioB,UAAU,WACd,mBAAC,GACM,CAAC,WACN,aAAW,QACX,YAAiB,QAAS,mBAC1B,GAAU,0BAAsB,GAA6B,WAAE,EAC/D,2G,GACgB,gBAAkB,kC,GAClC,wE,GACE,0BAAK,SAAS,WAAU,wF,WACtB,oB,GACA,mBAAO,EACL,SAAS,KAMZ,GAAkB,gBAAU,4BAC3B,sBAAgB,gBAAD,OAAS,kB,GACtB,mBAAC,OAAS,CACR,SAAU,QACV,KACM,QACS,SAAS,GAAiC,EACzD,EAAY,EACF,MAUtB,gBACE,mBAAI,MAAU,sBACd,GAAC,gBACM,GAAC,4BAA0C,MAChD,mBACA,MAASvc,EAAQqT,SAAS,6BAC1B,GAAU,oCAAsB,SAAyB,GAAW,8BAI1E,4KACF,qDAEI,GAAwB,gBAG5B,MAAkC,UAC/B,gBAC8D,S","file":"datasource-zabbix/module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 75);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import _ from 'lodash';\nimport moment from 'moment';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as c from './constants';\nimport { VariableQuery, VariableQueryTypes } from './types';\n\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\nexport const variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::(\\w+))?}/g;\n\n/**\n * Expand Zabbix item name\n *\n * @param  {string} name item name, ie \"CPU $2 time\"\n * @param  {string} key  item key, ie system.cpu.util[,system,avg1]\n * @return {string}      expanded name, ie \"CPU system time\"\n */\nexport function expandItemName(name: string, key: string): string {\n\n  // extract params from key:\n  // \"system.cpu.util[,system,avg1]\" --> [\"\", \"system\", \"avg1\"]\n  const key_params_str = key.substring(key.indexOf('[') + 1, key.lastIndexOf(']'));\n  const key_params = splitKeyParams(key_params_str);\n\n  // replace item parameters\n  for (let i = key_params.length; i >= 1; i--) {\n    name = name.replace('$' + i, key_params[i - 1]);\n  }\n  return name;\n}\n\nexport function expandItems(items) {\n  _.forEach(items, item => {\n    item.item = item.name;\n    item.name = expandItemName(item.item, item.key_);\n    return item;\n  });\n  return items;\n}\n\nfunction splitKeyParams(paramStr) {\n  const params = [];\n  let quoted = false;\n  let in_array = false;\n  const split_symbol = ',';\n  let param = '';\n\n  _.forEach(paramStr, symbol => {\n    if (symbol === '\"' && in_array) {\n      param += symbol;\n    } else if (symbol === '\"' && quoted) {\n      quoted = false;\n    } else if (symbol === '\"' && !quoted) {\n      quoted = true;\n    } else if (symbol === '[' && !quoted) {\n      in_array  = true;\n    } else if (symbol === ']' && !quoted) {\n      in_array = false;\n    } else if (symbol === split_symbol && !quoted && !in_array) {\n      params.push(param);\n      param = '';\n    } else {\n      param += symbol;\n    }\n  });\n\n  params.push(param);\n  return params;\n}\n\nconst MACRO_PATTERN = /{\\$[A-Z0-9_\\.]+}/g;\n\nexport function containsMacro(itemName) {\n  return MACRO_PATTERN.test(itemName);\n}\n\nexport function replaceMacro(item, macros, isTriggerItem?) {\n  let itemName = isTriggerItem ? item.url : item.name;\n  const item_macros = itemName.match(MACRO_PATTERN);\n  _.forEach(item_macros, macro => {\n    const host_macros = _.filter(macros, m => {\n      if (m.hostid) {\n        if (isTriggerItem) {\n          // Trigger item can have multiple hosts\n          // Check all trigger host ids against macro host id\n          let hostIdFound = false;\n          _.forEach(item.hosts, h => {\n            if (h.hostid === m.hostid) {\n              hostIdFound = true;\n            }\n          });\n          return hostIdFound;\n        } else {\n          // Check app host id against macro host id\n          return m.hostid === item.hostid;\n        }\n      } else {\n        // Add global macros\n        return true;\n      }\n    });\n\n    const macro_def = _.find(host_macros, { macro: macro });\n    if (macro_def && macro_def.value) {\n      const macro_value = macro_def.value;\n      const macro_regex = new RegExp(escapeMacro(macro));\n      itemName = itemName.replace(macro_regex, macro_value);\n    }\n  });\n\n  return itemName;\n}\n\nfunction escapeMacro(macro) {\n  macro = macro.replace(/\\$/, '\\\\\\$');\n  return macro;\n}\n\nexport function parseLegacyVariableQuery(query: string): VariableQuery {\n  let queryType: VariableQueryTypes;\n  const parts = [];\n\n  // Split query. Query structure: group.host.app.item\n  _.each(splitTemplateQuery(query), part => {\n    // Replace wildcard to regex\n    if (part === '*') {\n      part = '/.*/';\n    }\n    parts.push(part);\n  });\n  const template = _.zipObject(['group', 'host', 'app', 'item'], parts);\n\n  if (parts.length === 4 && template.app === '/.*/') {\n    // Search for all items, even it's not belong to any application\n    template.app = '';\n  }\n\n  switch (parts.length) {\n    case 1:\n      queryType = VariableQueryTypes.Group;\n      break;\n    case 2:\n      queryType = VariableQueryTypes.Host;\n      break;\n    case 3:\n      queryType = VariableQueryTypes.Application;\n      break;\n    case 4:\n      queryType = VariableQueryTypes.Item;\n      break;\n  }\n\n  const variableQuery: VariableQuery = {\n    queryType,\n    group: template.group || '',\n    host: template.host || '',\n    application: template.app || '',\n    item: template.item || '',\n  };\n\n  return variableQuery;\n}\n\n/**\n * Split template query to parts of zabbix entities\n * group.host.app.item -> [group, host, app, item]\n * {group}{host.com} -> [group, host.com]\n */\nexport function splitTemplateQuery(query) {\n  const splitPattern = /\\{[^\\{\\}]*\\}|\\{\\/.*\\/\\}/g;\n  let split;\n\n  if (isContainsBraces(query)) {\n    const result = query.match(splitPattern);\n    split = _.map(result, part => {\n      return _.trim(part, '{}');\n    });\n  } else {\n    split = query.split('.');\n  }\n\n  return split;\n}\n\nfunction isContainsBraces(query) {\n  const bracesPattern = /^\\{.+\\}$/;\n  return bracesPattern.test(query);\n}\n\n// Pattern for testing regex\nexport const regexPattern = /^\\/(.*)\\/([gmi]*)$/m;\n\nexport function isRegex(str) {\n  return regexPattern.test(str);\n}\n\nexport function isTemplateVariable(str, templateVariables) {\n  const variablePattern = /^\\$\\w+/;\n  if (variablePattern.test(str)) {\n    const variables = _.map(templateVariables, variable => {\n      return '$' + variable.name;\n    });\n    return _.includes(variables, str);\n  } else {\n    return false;\n  }\n}\n\nexport function getRangeScopedVars(range) {\n  const msRange = range.to.diff(range.from);\n  const sRange = Math.round(msRange / 1000);\n  const regularRange = kbn.secondsToHms(msRange / 1000);\n  return {\n    __range_ms: { text: msRange, value: msRange },\n    __range_s: { text: sRange, value: sRange },\n    __range: { text: regularRange, value: regularRange },\n    __range_series: {text: c.RANGE_VARIABLE_VALUE, value: c.RANGE_VARIABLE_VALUE},\n  };\n}\n\nexport function buildRegex(str) {\n  const matches = str.match(regexPattern);\n  const pattern = matches[1];\n  const flags = matches[2] !== \"\" ? matches[2] : undefined;\n  return new RegExp(pattern, flags);\n}\n\n// Need for template variables replace\n// From Grafana's templateSrv.js\nexport function escapeRegex(value) {\n  return value.replace(/[\\\\^$*+?.()|[\\]{}\\/]/g, '\\\\$&');\n}\n\nexport function parseInterval(interval: string): number {\n  const intervalPattern = /(^[\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  const duration = moment.duration(Number(momentInterval[1]), momentInterval[2]);\n  return (duration.valueOf() as number);\n}\n\nexport function parseTimeShiftInterval(interval) {\n  const intervalPattern = /^([\\+\\-]*)([\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  let duration: any = 0;\n\n  if (momentInterval[1] === '+') {\n    duration = 0 - (moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf() as any);\n  } else {\n    duration = moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf();\n  }\n\n  return duration;\n}\n\n/**\n * Format acknowledges.\n *\n * @param  {array} acknowledges array of Zabbix acknowledge objects\n * @return {string} HTML-formatted table\n */\nexport function formatAcknowledges(acknowledges) {\n  if (acknowledges.length) {\n    let formatted_acknowledges = '<br><br>Acknowledges:<br><table><tr><td><b>Time</b></td>'\n      + '<td><b>User</b></td><td><b>Comments</b></td></tr>';\n    _.each(_.map(acknowledges, ack => {\n      const timestamp = moment.unix(ack.clock);\n      return '<tr><td><i>' + timestamp.format(\"DD MMM YYYY HH:mm:ss\") + '</i></td><td>' + ack.alias\n        + ' (' + ack.name + ' ' + ack.surname + ')' + '</td><td>' + ack.message + '</td></tr>';\n    }), ack => {\n      formatted_acknowledges = formatted_acknowledges.concat(ack);\n    });\n    formatted_acknowledges = formatted_acknowledges.concat('</table>');\n    return formatted_acknowledges;\n  } else {\n    return '';\n  }\n}\n\nexport function convertToZabbixAPIUrl(url) {\n  const zabbixAPIUrlPattern = /.*api_jsonrpc.php$/;\n  const trimSlashPattern = /(.*?)[\\/]*$/;\n  if (url.match(zabbixAPIUrlPattern)) {\n    return url;\n  } else {\n    return url.replace(trimSlashPattern, \"$1\");\n  }\n}\n\n/**\n * Wrap function to prevent multiple calls\n * when waiting for result.\n */\nexport function callOnce(func, promiseKeeper) {\n  return function() {\n    if (!promiseKeeper) {\n      promiseKeeper = Promise.resolve(\n        func.apply(this, arguments)\n        .then(result => {\n          promiseKeeper = null;\n          return result;\n        }).catch(err => {\n          promiseKeeper = null;\n          throw err;\n        })\n      );\n    }\n    return promiseKeeper;\n  };\n}\n\n/**\n * Apply function one by one: `sequence([a(), b(), c()]) = c(b(a()))`\n * @param {*} funcsArray functions to apply\n */\nexport function sequence(funcsArray) {\n  return function(result) {\n    for (let i = 0; i < funcsArray.length; i++) {\n      result = funcsArray[i].call(this, result);\n    }\n    return result;\n  };\n}\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport function isValidVersion(version) {\n  return versionPattern.exec(version);\n}\n\nexport function parseVersion(version: string) {\n  const match = versionPattern.exec(version);\n  if (!match) {\n    return null;\n  }\n  const major = Number(match[1]);\n  const minor = Number(match[2] || 0);\n  const patch = Number(match[3] || 0);\n  const meta = match[4];\n  return { major, minor, patch, meta };\n}\n\n/**\n * Replaces any space-like symbols (tabs, new lines, spaces) by single whitespace.\n */\nexport function compactQuery(query) {\n  return query.replace(/\\s+/g, ' ').trim();\n}\n\nexport function getArrayDepth(a, level = 0) {\n  if (a.length === 0) {\n    return 1;\n  }\n  const elem = a[0];\n  if (_.isArray(elem)) {\n    return getArrayDepth(elem, level + 1);\n  }\n  return level + 1;\n}\n\n/**\n * Checks whether its argument represents a numeric value.\n */\nexport function isNumeric(n: any): boolean {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Parses tags string into array of {tag: value} objects\n */\nexport function parseTags(tagStr: string): any[] {\n  if (!tagStr) {\n    return [];\n  }\n\n  let tags: any[] = _.map(tagStr.split(','), (tag) => tag.trim());\n  tags = _.map(tags, (tag) => {\n    const tagParts = tag.split(':');\n    return {tag: tagParts[0].trim(), value: tagParts[1].trim()};\n  });\n  return tags;\n}\n\nexport function mustArray(result: any): any[] {\n  return result || [];\n}\n","// Plugin IDs\nexport const ZABBIX_PROBLEMS_PANEL_ID = 'alexanderzobnin-zabbix-triggers-panel';\nexport const ZABBIX_DS_ID = 'alexanderzobnin-zabbix-datasource';\n\n// Data point\nexport const DATAPOINT_VALUE = 0;\nexport const DATAPOINT_TS = 1;\n\n// Editor modes\nexport const MODE_METRICS = 0;\nexport const MODE_ITSERVICE = 1;\nexport const MODE_TEXT = 2;\nexport const MODE_ITEMID = 3;\nexport const MODE_TRIGGERS = 4;\nexport const MODE_PROBLEMS = 5;\n\n// Triggers severity\nexport const SEV_NOT_CLASSIFIED = 0;\nexport const SEV_INFORMATION = 1;\nexport const SEV_WARNING = 2;\nexport const SEV_AVERAGE = 3;\nexport const SEV_HIGH = 4;\nexport const SEV_DISASTER = 5;\n\nexport const SHOW_ALL_TRIGGERS = [0, 1];\nexport const SHOW_ALL_EVENTS = [0, 1];\nexport const SHOW_OK_EVENTS = 1;\n\n// Acknowledge\nexport const ZBX_ACK_ACTION_NONE = 0;\nexport const ZBX_ACK_ACTION_CLOSE = 1;\nexport const ZBX_ACK_ACTION_ACK = 2;\nexport const ZBX_ACK_ACTION_ADD_MESSAGE = 4;\nexport const ZBX_ACK_ACTION_CHANGE_SEVERITY = 8;\n\nexport const TRIGGER_SEVERITY = [\n  {val: 0, text: 'Not classified'},\n  {val: 1, text: 'Information'},\n  {val: 2, text: 'Warning'},\n  {val: 3, text: 'Average'},\n  {val: 4, text: 'High'},\n  {val: 5, text: 'Disaster'}\n];\n\n/** Minimum interval for SLA over time (1 hour) */\nexport const MIN_SLA_INTERVAL = 3600;\n\nexport const RANGE_VARIABLE_VALUE = 'range_series';\n\nexport const DEFAULT_ZABBIX_PROBLEMS_LIMIT = 1001;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","import { SelectableValue, DataQuery, DataSourceJsonData } from \"@grafana/data\";\n\nexport interface ZabbixDSOptions extends DataSourceJsonData {\n  username: string;\n  password?: string;\n  trends: boolean;\n  trendsFrom: string;\n  trendsRange: string;\n  cacheTTL: string;\n  dbConnectionEnable: boolean;\n  dbConnectionDatasourceId?: number;\n  dbConnectionDatasourceName?: string;\n  dbConnectionRetentionPolicy?: string;\n  disableReadOnlyUsersAck: boolean;\n}\n\nexport interface ZabbixSecureJSONData {\n  password?: string;\n}\n\nexport interface ZabbixConnectionInfo {\n  zabbixVersion: string;\n  dbConnectorStatus: {\n    dsType: string;\n    dsName: string;\n  };\n}\n\nexport interface ZabbixConnectionTestQuery {\n  datasourceId: number;\n  queryType: string;\n}\n\nexport interface ZabbixMetricsQuery extends DataQuery {\n  triggers: { minSeverity: string; acknowledged: boolean; count: number; };\n  queryType: string;\n  datasourceId: number;\n  functions: ZabbixMetricFunction[];\n  options: any;\n  textFilter: string;\n  mode: number;\n  itemids: number[];\n  useCaptureGroups: boolean;\n  group: { filter: string; name: string; };\n  host: { filter: string; name: string; };\n  hostFilter: string;\n  application: { filter: string; name: string; };\n  item: { filter: string; name: string; };\n  itemFilter: string;\n}\n\nexport interface ZabbixMetricFunction {\n  name: string;\n  params: any;\n  def: { name: string; params: any; };\n}\n\n// The paths of these files have moved around in Grafana and they don't resolve properly\n// either. Safer not to bother trying to import them just for type hinting.\n\nexport interface TemplateSrv {\n  variables: {\n    name: string;\n  };\n  highlightVariablesAsHtml(str: any): any;\n  replace(target: any, scopedVars?: any, format?: any): any;\n}\n\nexport interface DashboardSrv {\n  dash: any;\n}\n\n// Grafana types from backend code\n\ntype RowValues = object[];\ntype TimePoint = [number?, number?];\ntype TimeSeriesPoints = TimePoint[];\ntype TimeSeriesSlice = TimeSeries[];\n\ninterface TimeSeries {\n  name: string;\n  points: TimeSeriesPoints;\n  tags: { [key: string]: string };\n}\n\ninterface TableColumn {\n  text: string;\n}\n\ninterface Table {\n  columns: TableColumn[];\n  rows: RowValues[];\n}\n\ninterface QueryResult {\n  error: string;\n  refId: string;\n  meta: any;\n  series: TimeSeriesSlice[];\n  tables: Table[];\n}\n\nexport interface TSDBResponse {\n  results: { [key: string]: QueryResult };\n  message: string;\n}\n\nexport interface VariableQueryProps {\n  query: LegacyVariableQuery;\n  onChange: (query: VariableQuery, definition: string) => void;\n  datasource: any;\n  templateSrv: any;\n}\n\nexport interface VariableQueryData extends VariableQuery {\n  selectedQueryType: SelectableValue<VariableQueryTypes>;\n  legacyQuery?: string;\n}\n\nexport interface VariableQuery {\n  queryType: VariableQueryTypes;\n  group?: string;\n  host?: string;\n  application?: string;\n  item?: string;\n}\n\nexport type LegacyVariableQuery = VariableQuery | string;\n\nexport enum VariableQueryTypes {\n  Group = 'group',\n  Host = 'host',\n  Application = 'application',\n  Item = 'item',\n  ItemValues = 'itemValues',\n}\n\nexport enum ShowProblemTypes {\n  Problems = 'problems',\n  Recent = 'recent',\n  History = 'history',\n}\n\nexport interface ProblemDTO {\n  triggerid?: string;\n  eventid?: string;\n  timestamp: number;\n\n  /** Name of the trigger. */\n  name?: string;\n\n  /** Same as a name. */\n  description?: string;\n\n  /** Whether the trigger is in OK or problem state. */\n  value?: string;\n\n  datasource?: string;\n  comments?: string;\n  host?: string;\n  hostTechName?: string;\n  proxy?: string;\n  severity?: string;\n\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n\n  groups?: ZBXGroup[];\n  hosts?: ZBXHost[];\n  items?: ZBXItem[];\n  alerts?: ZBXAlert[];\n  tags?: ZBXTag[];\n  url?: string;\n\n  expression?: string;\n  correlation_mode?: string;\n  correlation_tag?: string;\n  suppressed?: string;\n  suppression_data?: any[];\n  state?: string;\n  maintenance?: boolean;\n  manual_close?: string;\n  error?: string;\n\n  showAckButton?: boolean;\n}\n\nexport interface ZBXProblem {\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n  clock: string;\n  ns: string;\n  correlationid?: string;\n  datasource?: string;\n  name?: string;\n  eventid?: string;\n  maintenance?: boolean;\n  object?: string;\n  objectid?: string;\n  opdata?: any;\n  r_eventid?: string;\n  r_clock?: string;\n  r_ns?: string;\n  severity?: string;\n  showAckButton?: boolean;\n  source?: string;\n  suppressed?: string;\n  suppression_data?: any[];\n  tags?: ZBXTag[];\n  userid?: string;\n}\n\nexport interface ZBXTrigger {\n  acknowledges?: ZBXAcknowledge[];\n  showAckButton?: boolean;\n  alerts?: ZBXAlert[];\n  age?: string;\n  color?: string;\n  comments?: string;\n  correlation_mode?: string;\n  correlation_tag?: string;\n  datasource?: string;\n  description?: string;\n  error?: string;\n  expression?: string;\n  flags?: string;\n  groups?: ZBXGroup[];\n  host?: string;\n  hostTechName?: string;\n  hosts?: ZBXHost[];\n  items?: ZBXItem[];\n  lastEvent?: ZBXEvent;\n  lastchange?: string;\n  lastchangeUnix?: number;\n  maintenance?: boolean;\n  manual_close?: string;\n  priority?: string;\n  proxy?: string;\n  recovery_expression?: string;\n  recovery_mode?: string;\n  severity?: string;\n  state?: string;\n  status?: string;\n  tags?: ZBXTag[];\n  templateid?: string;\n  triggerid?: string;\n  /** Whether the trigger can generate multiple problem events. */\n  type?: string;\n  url?: string;\n  value?: string;\n}\n\nexport interface ZBXGroup {\n  groupid: string;\n  name: string;\n}\n\nexport interface ZBXHost {\n  hostid: string;\n  name: string;\n  host: string;\n  maintenance_status?: string;\n  proxy_hostid?: string;\n}\n\nexport interface ZBXItem {\n  itemid: string;\n  name: string;\n  key_: string;\n  lastvalue?: string;\n}\n\nexport interface ZBXEvent {\n  eventid: string;\n  clock: string;\n  ns?: string;\n  value?: string;\n  name?: string;\n  source?: string;\n  object?: string;\n  objectid?: string;\n  severity?: string;\n  hosts?: ZBXHost[];\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n  tags?: ZBXTag[];\n  suppressed?: string;\n}\n\nexport interface ZBXTag {\n  tag: string;\n  value?: string;\n}\n\nexport interface ZBXAcknowledge {\n  acknowledgeid: string;\n  eventid: string;\n  userid: string;\n  action: string;\n  clock: string;\n  time: string;\n  message?: string;\n  user: string;\n  alias: string;\n  name: string;\n  surname: string;\n}\n\nexport interface ZBXAlert {\n  eventid: string;\n  clock: string;\n  message: string;\n  error: string;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","import _ from 'lodash';\nimport moment from 'moment';\nimport { DataQuery } from '@grafana/data';\nimport * as utils from '../datasource-zabbix/utils';\nimport { ProblemDTO } from 'datasource-zabbix/types';\n\nexport function isNewProblem(problem: ProblemDTO, highlightNewerThan: string): boolean {\n  try {\n    const highlightIntervalMs = utils.parseInterval(highlightNewerThan);\n    const durationSec = (Date.now() - problem.timestamp * 1000);\n    return durationSec < highlightIntervalMs;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst DEFAULT_TIME_FORMAT = \"DD MMM YYYY HH:mm:ss\";\n\nexport function formatLastChange(lastchangeUnix: number, customFormat?: string) {\n  const timestamp = moment.unix(lastchangeUnix);\n  const format = customFormat || DEFAULT_TIME_FORMAT;\n  const lastchange = timestamp.format(format);\n  return lastchange;\n}\n\nexport const getNextRefIdChar = (queries: DataQuery[]): string => {\n  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  return _.find(letters, refId => {\n    return _.every(queries, other => {\n      return other.refId !== refId;\n    });\n  });\n};\n\nexport type UrlQueryMap = Record<string, any>;\n\nexport function renderUrl(path: string, query: UrlQueryMap | undefined): string {\n  if (query && Object.keys(query).length > 0) {\n    path += '?' + toUrlParams(query);\n  }\n  return path;\n}\n\nfunction encodeURIComponentAsAngularJS(val: string, pctEncodeSpaces?: boolean) {\n  return encodeURIComponent(val)\n    .replace(/%25/gi, '%2525') // Double-encode % symbol to make it properly decoded in Explore\n    .replace(/%40/gi, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%3B/gi, ';')\n    .replace(/%20/g, pctEncodeSpaces ? '%20' : '+');\n}\n\nfunction toUrlParams(a: any) {\n  const s: any[] = [];\n  const rbracket = /\\[\\]$/;\n\n  const isArray = (obj: any) => {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  const add = (k: string, v: any) => {\n    v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n    if (typeof v !== 'boolean') {\n      s[s.length] = encodeURIComponentAsAngularJS(k, true) + '=' + encodeURIComponentAsAngularJS(v, true);\n    } else {\n      s[s.length] = encodeURIComponentAsAngularJS(k, true);\n    }\n  };\n\n  const buildParams = (prefix: string, obj: any) => {\n    let i, len, key;\n\n    if (prefix) {\n      if (isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          if (rbracket.test(prefix)) {\n            add(prefix, obj[i]);\n          } else {\n            buildParams(prefix, obj[i]);\n          }\n        }\n      } else if (obj && String(obj) === '[object Object]') {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key]);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key]);\n      }\n    }\n    return s;\n  };\n\n  return buildParams('', a).join('&');\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__14__;","module.exports = __WEBPACK_EXTERNAL_MODULE__15__;","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    const loose = this.options.loose\n    range = range.trim()\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    return range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = require('../internal/re')\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__18__;","module.exports = __WEBPACK_EXTERNAL_MODULE__20__;","import _ from 'lodash';\nimport { getNextRefIdChar } from './utils';\nimport { ShowProblemTypes } from '../datasource-zabbix/types';\n\n// Actual schema version\nexport const CURRENT_SCHEMA_VERSION = 8;\n\nexport const getDefaultTarget = (targets?) => {\n  return {\n    group: {filter: \"\"},\n    host: {filter: \"\"},\n    application: {filter: \"\"},\n    trigger: {filter: \"\"},\n    tags: {filter: \"\"},\n    proxy: {filter: \"\"},\n    refId: getNextRefIdChar(targets),\n  };\n};\n\nexport function getDefaultTargetOptions() {\n  return {\n    hostsInMaintenance: true,\n  };\n}\n\nexport function migratePanelSchema(panel) {\n  if (isEmptyPanel(panel)) {\n    delete panel.targets;\n    return panel;\n  }\n\n  const schemaVersion = getSchemaVersion(panel);\n  // panel.schemaVersion = CURRENT_SCHEMA_VERSION;\n\n  if (schemaVersion < 2) {\n    panel.datasources = [panel.datasource];\n    panel.targets = {};\n    panel.targets[panel.datasources[0]] = panel.triggers;\n\n    // delete old props\n    delete panel.triggers;\n    delete panel.datasource;\n  }\n\n  if (schemaVersion < 3) {\n    // delete old props\n    delete panel.lastChangeField;\n    delete panel.infoField;\n    delete panel.scroll;\n    delete panel.hideHostsInMaintenance;\n  }\n\n  if (schemaVersion < 5) {\n    if (panel.targets && !_.isEmpty(panel.targets)) {\n      _.each(panel.targets, (target) => {\n        _.defaultsDeep(target, getDefaultTarget());\n      });\n    }\n  }\n\n  if (schemaVersion < 6) {\n    if (panel.showEvents && panel.showEvents.value === '1') {\n      panel.showEvents.value = 1;\n    }\n  }\n\n  if (schemaVersion < 7) {\n    const updatedTargets = [];\n    for (const targetKey in panel.targets) {\n      const target = panel.targets[targetKey];\n      if (!isEmptyTarget(target) && !isInvalidTarget(target, targetKey)) {\n        updatedTargets.push({\n          ...target,\n          datasource: targetKey,\n        });\n      }\n    }\n    for (const target of updatedTargets) {\n      if (!target.refId) {\n        target.refId = getNextRefIdChar(updatedTargets);\n      }\n    }\n    panel.targets = updatedTargets;\n    delete panel.datasources;\n  }\n\n  if (schemaVersion < 8) {\n    if (panel.targets.length === 1) {\n      if (panel.targets[0].datasource) {\n        panel.datasource = panel.targets[0].datasource;\n        delete panel.targets[0].datasource;\n      }\n    } else if (panel.targets.length > 1) {\n      // Mixed data sources\n      panel.datasource = '-- Mixed --';\n    }\n    for (const target of panel.targets) {\n      // set queryType to PROBLEMS\n      target.queryType = 5;\n      target.showProblems = migrateShowEvents(panel);\n      target.options = migrateOptions(panel);\n\n      _.defaults(target.options, getDefaultTargetOptions());\n      _.defaults(target, { tags: { filter: \"\" } });\n    }\n\n    panel.sortProblems = panel.sortTriggersBy?.value === 'priority' ? 'priority' : 'lastchange';\n\n    delete panel.showEvents;\n    delete panel.showTriggers;\n    delete panel.hostsInMaintenance;\n    delete panel.sortTriggersBy;\n  }\n\n  return panel;\n}\n\nfunction migrateOptions(panel) {\n  let acknowledged = 2;\n  if (panel.showTriggers === 'acknowledged') {\n    acknowledged = 1;\n  } else if (panel.showTriggers === 'unacknowledged') {\n    acknowledged = 0;\n  }\n\n  // Default limit in Zabbix\n  let limit = 1001;\n  if (panel.limit && panel.limit !== 100) {\n    limit = panel.limit;\n  }\n\n  return {\n    hostsInMaintenance: panel.hostsInMaintenance,\n    sortProblems: panel.sortTriggersBy?.value === 'priority' ? 'priority' : 'default',\n    minSeverity: 0,\n    acknowledged: acknowledged,\n    limit: limit,\n  };\n}\n\nfunction migrateShowEvents(panel) {\n  if (panel.showEvents?.value === 1) {\n    return ShowProblemTypes.Problems;\n  } else if (panel.showEvents?.value === 0 || panel.showEvents?.value?.length > 1) {\n    return ShowProblemTypes.History;\n  } else {\n    return ShowProblemTypes.Problems;\n  }\n}\n\nfunction getSchemaVersion(panel) {\n  return panel.schemaVersion || 1;\n}\n\nfunction isEmptyPanel(panel) {\n  return !panel.datasource && !panel.datasources && !panel.triggers && isEmptyTargets(panel.targets);\n}\n\nfunction isEmptyTargets(targets) {\n  return !targets || (_.isArray(targets) && (targets.length === 0 || targets.length === 1 && _.isEmpty(targets[0])));\n}\n\nfunction isEmptyTarget(target) {\n  return !target || !(target.group && target.host && target.application && target.trigger);\n}\n\nfunction isInvalidTarget(target, targetKey) {\n  return target && target.refId === 'A' && targetKey === '0';\n}\n","const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n","const {MAX_LENGTH} = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parse = (version, options) => {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst {re, t} = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","module.exports = __WEBPACK_EXTERNAL_MODULE__30__;","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst {ANY} = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","module.exports = __WEBPACK_EXTERNAL_MODULE__38__;","module.exports = __WEBPACK_EXTERNAL_MODULE__39__;","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","module.exports = __WEBPACK_EXTERNAL_MODULE__43__;","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__45__;","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst { ANY } = require('../classes/comparator.js')\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than that of any > comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","import _ from 'lodash';\nimport { ZabbixMetricsQuery } from './types';\nimport * as c from './constants';\n\n/**\n * Query format migration.\n * This module can detect query format version and make migration.\n */\n\nexport function isGrafana2target(target) {\n  if (!target.mode || target.mode === 0 || target.mode === 2) {\n    if ((target.hostFilter || target.itemFilter || target.downsampleFunction ||\n        (target.host && target.host.host)) &&\n        (target.item.filter === undefined && target.host.filter === undefined)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function migrateFrom2To3version(target: ZabbixMetricsQuery) {\n  target.group.filter = target.group.name === \"*\" ? \"/.*/\" : target.group.name;\n  target.host.filter = target.host.name === \"*\" ? convertToRegex(target.hostFilter) : target.host.name;\n  target.application.filter = target.application.name === \"*\" ? \"\" : target.application.name;\n  target.item.filter = target.item.name === \"All\" ? convertToRegex(target.itemFilter) : target.item.name;\n  return target;\n}\n\nfunction migratePercentileAgg(target) {\n  if (target.functions) {\n    for (const f of target.functions) {\n      if (f.def && f.def.name === 'percentil') {\n        f.def.name = 'percentile';\n      }\n    }\n  }\n}\n\nfunction migrateQueryType(target) {\n  if (target.queryType === undefined) {\n    if (target.mode === 'Metrics') {\n      // Explore mode\n      target.queryType = c.MODE_METRICS;\n    } else if (target.mode !== undefined) {\n      target.queryType = target.mode;\n      delete target.mode;\n    }\n  }\n}\n\nfunction migrateSLA(target) {\n  if (target.queryType === c.MODE_ITSERVICE && !target.slaInterval) {\n    target.slaInterval = 'none';\n  }\n}\n\nfunction migrateProblemSort(target) {\n  if (target.options?.sortProblems === 'priority') {\n    target.options.sortProblems = 'severity';\n  }\n}\n\nexport function migrate(target) {\n  target.resultFormat = target.resultFormat || 'time_series';\n  target = fixTargetGroup(target);\n  if (isGrafana2target(target)) {\n    return migrateFrom2To3version(target);\n  }\n  migratePercentileAgg(target);\n  migrateQueryType(target);\n  migrateSLA(target);\n  migrateProblemSort(target);\n  return target;\n}\n\nfunction fixTargetGroup(target) {\n  if (target.group && Array.isArray(target.group)) {\n    target.group = { 'filter': \"\" };\n  }\n  return target;\n}\n\nfunction convertToRegex(str) {\n  if (str) {\n    return '/' + str + '/';\n  } else {\n    return '/.*/';\n  }\n}\n\nexport const DS_CONFIG_SCHEMA = 2;\nexport function migrateDSConfig(jsonData) {\n  if (!jsonData) {\n    jsonData = {};\n  }\n\n  if (!shouldMigrateDSConfig(jsonData)) {\n    return jsonData;\n  }\n\n  const oldVersion = jsonData.schema || 1;\n  jsonData.schema = DS_CONFIG_SCHEMA;\n\n  if (oldVersion < 2) {\n    const dbConnectionOptions = jsonData.dbConnection || {};\n    jsonData.dbConnectionEnable = dbConnectionOptions.enable || false;\n    jsonData.dbConnectionDatasourceId = dbConnectionOptions.datasourceId || null;\n    delete jsonData.dbConnection;\n  }\n\n  return jsonData;\n}\n\nfunction shouldMigrateDSConfig(jsonData): boolean {\n  if (jsonData.dbConnection && !_.isEmpty(jsonData.dbConnection)) {\n    return true;\n  }\n  if (jsonData.schema && jsonData.schema !== DS_CONFIG_SCHEMA) {\n    return true;\n  }\n  return false;\n}\n","import _ from 'lodash';\nimport { isNumeric } from './utils';\n\nconst index = [];\nconst categories = {\n  Transform: [],\n  Aggregate: [],\n  Filter: [],\n  Trends: [],\n  Time: [],\n  Alias: [],\n  Special: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    categories[funcDef.category].push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Transform\n\naddFuncDef({\n  name: 'groupBy',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string'},\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'float', options: [100, 0.01, 10, -1]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [\n    { name: 'delta', type: 'float', options: [-100, 100]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'delta',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'rate',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'int', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'smoothing', type: 'float', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [0.2],\n});\n\naddFuncDef({\n  name: 'percentile',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'}\n  ],\n  defaultParams: [0],\n});\n\n// Aggregate\n\naddFuncDef({\n  name: 'sumSeries',\n  category: 'Aggregate',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'median',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string'}\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'average',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'percentileAgg',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'min',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'max',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'sum',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'count',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'aggregateBy',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\n// Filter\n\naddFuncDef({\n  name: 'top',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'bottom',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'sortSeries',\n  category: 'Filter',\n  params: [\n    { name: 'direction', type: 'string', options: ['asc', 'desc'] }\n  ],\n  defaultParams: ['asc']\n});\n\n// Trends\n\naddFuncDef({\n  name: 'trendValue',\n  category: 'Trends',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n// Time\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Time',\n  params: [\n    { name: 'interval', type: 'string', options: ['24h', '7d', '1M', '+24h', '-24h']}\n  ],\n  defaultParams: ['24h'],\n});\n\n//Alias\n\naddFuncDef({\n  name: 'setAlias',\n  category: 'Alias',\n  params: [\n    { name: 'alias', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'setAliasByRegex',\n  category: 'Alias',\n  params: [\n    { name: 'aliasByRegex', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'replaceAlias',\n  category: 'Alias',\n  params: [\n    { name: 'regexp', type: 'string' },\n    { name: 'newAlias', type: 'string' }\n  ],\n  defaultParams: ['/(.*)/', '$1']\n});\n\n// Special\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n_.each(categories, (funcList, catName) => {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nclass FuncInstance {\n  def: any;\n  params: any;\n  text: string;\n  added: boolean;\n\n  constructor(funcDef, params) {\n    this.def = funcDef;\n\n    if (params) {\n      this.params = params;\n    } else {\n      // Create with default params\n      this.params = [];\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  bindFunction(metricFunctions) {\n    const func = metricFunctions[this.def.name];\n    if (func) {\n\n      // Bind function arguments\n      let bindedFunc = func;\n      let param;\n      for (let i = 0; i < this.params.length; i++) {\n        param = this.params[i];\n\n        // Convert numeric params\n        if (this.def.params[i].type === 'int' ||\n            this.def.params[i].type === 'float') {\n          param = Number(param);\n        }\n        bindedFunc = _.partial(bindedFunc, param);\n      }\n      return bindedFunc;\n    } else {\n      throw { message: 'Method not found ' + this.def.name };\n    }\n  }\n\n  render(metricExp) {\n    const str = this.def.name + '(';\n    const parameters = _.map(this.params, (value, index) => {\n      const paramType = this.def.params[index].type;\n      if (paramType === 'int' ||\n          paramType === 'float' ||\n          paramType === 'value_or_series' ||\n          paramType === 'boolean') {\n        return value;\n      } else if (paramType === 'int_or_interval' && isNumeric(value)) {\n        return value;\n      }\n\n      return \"'\" + value + \"'\";\n\n    });\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue, index) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    return this.def.params[index + 1] && this.def.params[index + 1].optional;\n  }\n\n  updateParam(strValue, index) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), (partVal, idx) => {\n        this.updateParam(partVal.trim(), idx);\n      });\n      return;\n    }\n\n    if (strValue === '' && this.def.params[index].optional) {\n      this.params.splice(index, 1);\n    }else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    let text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nexport function createFuncInstance(funcDef, params?) {\n  if (_.isString(funcDef)) {\n    if (!index[funcDef]) {\n      throw { message: 'Method not found ' + name };\n    }\n    funcDef = index[funcDef];\n  }\n  return new FuncInstance(funcDef, params);\n}\n\nexport function getFuncDef(name) {\n  return index[name];\n}\n\nexport function getCategories() {\n  return categories;\n}\n","/**\n * timeseries.js\n *\n * This module contains functions for working with time series.\n *\n * datapoints - array of points where point is [value, timestamp]. In almost all cases (if other wasn't\n * explicitly said) we assume datapoints are sorted by timestamp. Timestamp is the number of milliseconds\n * since 1 January 1970 00:00:00 UTC.\n *\n */\n\nimport _ from 'lodash';\nimport * as utils from './utils';\nimport * as c from './constants';\n\nconst POINT_VALUE = 0;\nconst POINT_TIMESTAMP = 1;\n\n/**\n * Downsample time series by using given function (avg, min, max).\n */\nfunction downsample(datapoints, time_to, ms_interval, func) {\n  const downsampledSeries = [];\n  const timeWindow = {\n    from: time_to * 1000 - ms_interval,\n    to: time_to * 1000\n  };\n\n  let points_sum = 0;\n  let points_num = 0;\n  let value_avg = 0;\n  let frame = [];\n\n  for (let i = datapoints.length - 1; i >= 0; i -= 1) {\n    if (timeWindow.from < datapoints[i][1] && datapoints[i][1] <= timeWindow.to) {\n      points_sum += datapoints[i][0];\n      points_num++;\n      frame.push(datapoints[i][0]);\n    } else {\n      value_avg = points_num ? points_sum / points_num : 0;\n\n      if (func === \"max\") {\n        downsampledSeries.push([_.max(frame), timeWindow.to]);\n      } else if (func === \"min\") {\n        downsampledSeries.push([_.min(frame), timeWindow.to]);\n      } else {\n        downsampledSeries.push([value_avg, timeWindow.to]);\n      }\n\n      // Shift time window\n      timeWindow.to = timeWindow.from;\n      timeWindow.from -= ms_interval;\n\n      points_sum = 0;\n      points_num = 0;\n      frame = [];\n\n      // Process point again\n      i++;\n    }\n  }\n  return downsampledSeries.reverse();\n}\n\n/**\n * Group points by given time interval\n * datapoints: [[<value>, <unixtime>], ...]\n */\nfunction groupBy(datapoints, interval, groupByCallback) {\n  const ms_interval = utils.parseInterval(interval);\n\n  // Calculate frame timestamps\n  const frames = _.groupBy(datapoints, point => {\n    // Calculate time for group of points\n    return Math.floor(point[1] / ms_interval) * ms_interval;\n  });\n\n  // frame: { '<unixtime>': [[<value>, <unixtime>], ...] }\n  // return [{ '<unixtime>': <value> }, { '<unixtime>': <value> }, ...]\n  const grouped = _.mapValues(frames, frame => {\n    const points = _.map(frame, point => {\n      return point[0];\n    });\n    return groupByCallback(points);\n  });\n\n  // Convert points to Grafana format\n  return sortByTime(_.map(grouped, (value, timestamp) => {\n    return [Number(value), Number(timestamp)];\n  }));\n}\n\nexport function groupBy_perf(datapoints, interval, groupByCallback) {\n  if (datapoints.length === 0) {\n    return [];\n  }\n\n  if (interval === c.RANGE_VARIABLE_VALUE) {\n    return groupByRange(datapoints, groupByCallback);\n  }\n\n  const ms_interval = utils.parseInterval(interval);\n  const grouped_series = [];\n  let frame_values = [];\n  let frame_value;\n  let frame_ts = datapoints.length ? getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], ms_interval) : 0;\n  let point_frame_ts = frame_ts;\n  let point;\n\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], ms_interval);\n    if (point_frame_ts === frame_ts) {\n      frame_values.push(point[POINT_VALUE]);\n    } else if (point_frame_ts > frame_ts) {\n      frame_value = groupByCallback(frame_values);\n      grouped_series.push([frame_value, frame_ts]);\n\n      // Move frame window to next non-empty interval and fill empty by null\n      frame_ts += ms_interval;\n      while (frame_ts < point_frame_ts) {\n        grouped_series.push([null, frame_ts]);\n        frame_ts += ms_interval;\n      }\n      frame_values = [point[POINT_VALUE]];\n    }\n  }\n\n  frame_value = groupByCallback(frame_values);\n  grouped_series.push([frame_value, frame_ts]);\n\n  return grouped_series;\n}\n\nexport function groupByRange(datapoints, groupByCallback) {\n  const frame_values = [];\n  const frame_start = datapoints[0][POINT_TIMESTAMP];\n  const frame_end = datapoints[datapoints.length - 1][POINT_TIMESTAMP];\n  let point;\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    frame_values.push(point[POINT_VALUE]);\n  }\n  const frame_value = groupByCallback(frame_values);\n  return [[frame_value, frame_start], [frame_value, frame_end]];\n}\n\n/**\n * Summarize set of time series into one.\n * @param {datapoints[]} timeseries array of time series\n */\nfunction sumSeries(timeseries) {\n\n  // Calculate new points for interpolation\n  let new_timestamps = _.uniq(_.map(_.flatten(timeseries), point => {\n    return point[1];\n  }));\n  new_timestamps = _.sortBy(new_timestamps);\n\n  const interpolated_timeseries = _.map(timeseries, series => {\n    series = fillZeroes(series, new_timestamps);\n    const timestamps = _.map(series, point => {\n      return point[1];\n    });\n    const new_points = _.map(_.difference(new_timestamps, timestamps), timestamp => {\n      return [null, timestamp];\n    });\n    const new_series = series.concat(new_points);\n    return sortByTime(new_series);\n  });\n\n  _.each(interpolated_timeseries, interpolateSeries);\n\n  const new_timeseries = [];\n  let sum;\n  for (let i = new_timestamps.length - 1; i >= 0; i--) {\n    sum = 0;\n    for (let j = interpolated_timeseries.length - 1; j >= 0; j--) {\n      sum += interpolated_timeseries[j][i][0];\n    }\n    new_timeseries.push([sum, new_timestamps[i]]);\n  }\n\n  return sortByTime(new_timeseries);\n}\n\nfunction scale(datapoints, factor) {\n  return _.map(datapoints, point => {\n    return [\n      point[0] * factor,\n      point[1]\n    ];\n  });\n}\n\nfunction scale_perf(datapoints, factor) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] * factor,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\nfunction offset(datapoints, delta) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] + delta,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\n/**\n * Simple delta. Calculate value delta between points.\n * @param {*} datapoints\n */\nfunction delta(datapoints) {\n  const newSeries = [];\n  let deltaValue;\n  for (let i = 1; i < datapoints.length; i++) {\n    deltaValue = datapoints[i][0] - datapoints[i - 1][0];\n    newSeries.push([deltaValue, datapoints[i][1]]);\n  }\n  return newSeries;\n}\n\n/**\n * Calculates rate per second. Resistant to counter reset.\n * @param {*} datapoints\n */\nfunction rate(datapoints) {\n  const newSeries = [];\n  let point, point_prev;\n  let valueDelta = 0;\n  let timeDelta = 0;\n  for (let i = 1; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_prev = datapoints[i - 1];\n\n    // Convert ms to seconds\n    timeDelta = (point[POINT_TIMESTAMP] - point_prev[POINT_TIMESTAMP]) / 1000;\n\n    // Handle counter reset - use previous value\n    if (point[POINT_VALUE] >= point_prev[POINT_VALUE]) {\n      valueDelta = (point[POINT_VALUE] - point_prev[POINT_VALUE]) / timeDelta;\n    }\n\n    newSeries.push([valueDelta, point[POINT_TIMESTAMP]]);\n  }\n  return newSeries;\n}\n\nfunction simpleMovingAverage(datapoints, n) {\n  const sma = [];\n  let w_sum;\n  let w_avg = null;\n  let w_count = 0;\n\n  // Initial window\n  for (let j = n; j > 0; j--) {\n    if (datapoints[n - j][POINT_VALUE] !== null) {\n      w_avg += datapoints[n - j][POINT_VALUE];\n      w_count++;\n    }\n  }\n  if (w_count > 0) {\n    w_avg = w_avg / w_count;\n  } else {\n    w_avg = null;\n  }\n  sma.push([w_avg, datapoints[n - 1][POINT_TIMESTAMP]]);\n\n  for (let i = n; i < datapoints.length; i++) {\n    // Insert next value\n    if (datapoints[i][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      w_avg = (w_sum + datapoints[i][POINT_VALUE]) / (w_count + 1);\n      w_count++;\n    }\n    // Remove left side point\n    if (datapoints[i - n][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      if (w_count > 1) {\n        w_avg = (w_sum - datapoints[i - n][POINT_VALUE]) / (w_count - 1);\n        w_count--;\n      } else {\n        w_avg = null;\n        w_count = 0;\n      }\n    }\n    sma.push([w_avg, datapoints[i][POINT_TIMESTAMP]]);\n  }\n  return sma;\n}\n\nfunction expMovingAverage(datapoints, n) {\n  let ema = [datapoints[0]];\n  let ema_prev = datapoints[0][POINT_VALUE];\n  let ema_cur;\n  let a;\n\n  if (n > 1) {\n    // Calculate a from window size\n    a = 2 / (n + 1);\n\n    // Initial window, use simple moving average\n    let w_avg = null;\n    let w_count = 0;\n    for (let j = n; j > 0; j--) {\n      if (datapoints[n - j][POINT_VALUE] !== null) {\n        w_avg += datapoints[n - j][POINT_VALUE];\n        w_count++;\n      }\n    }\n    if (w_count > 0) {\n      w_avg = w_avg / w_count;\n      // Actually, we should set timestamp from datapoints[n-1] and start calculation of EMA from n.\n      // But in order to start EMA from first point (not from Nth) we should expand time range and request N additional\n      // points outside left side of range. We can't do that, so this trick is used for pretty view of first N points.\n      // We calculate AVG for first N points, but then start from 2nd point, not from Nth. In general, it means we\n      // assume that previous N values (0-N, 0-(N-1), ..., 0-1) have the same average value as a first N values.\n      ema = [[w_avg, datapoints[0][POINT_TIMESTAMP]]];\n      ema_prev = w_avg;\n      n = 1;\n    }\n  } else {\n    // Use predefined a and start from 1st point (use it as initial EMA value)\n    a = n;\n    n = 1;\n  }\n\n  for (let i = n; i < datapoints.length; i++) {\n    if (datapoints[i][POINT_VALUE] !== null) {\n      ema_cur = a * datapoints[i][POINT_VALUE] + (1 - a) * ema_prev;\n      ema_prev = ema_cur;\n      ema.push([ema_cur, datapoints[i][POINT_TIMESTAMP]]);\n    } else {\n      ema.push([null, datapoints[i][POINT_TIMESTAMP]]);\n    }\n  }\n  return ema;\n}\n\nfunction PERCENTILE(n, values) {\n  const sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length * n / 100)];\n}\n\nfunction COUNT(values) {\n  return values.length;\n}\n\nfunction SUM(values) {\n  let sum = null;\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n\nfunction AVERAGE(values) {\n  const values_non_null = getNonNullValues(values);\n  if (values_non_null.length === 0) {\n    return null;\n  }\n  return SUM(values_non_null) / values_non_null.length;\n}\n\nfunction getNonNullValues(values) {\n  const values_non_null = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      values_non_null.push(values[i]);\n    }\n  }\n  return values_non_null;\n}\n\nfunction MIN(values) {\n  return _.min(values);\n}\n\nfunction MAX(values) {\n  return _.max(values);\n}\n\nfunction MEDIAN(values) {\n  const sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length / 2)];\n}\n\n///////////////////////\n// Utility functions //\n///////////////////////\n\n/**\n * For given point calculate corresponding time frame.\n *\n * |__*_|_*__|___*| -> |*___|*___|*___|\n *\n * @param {*} timestamp\n * @param {*} ms_interval\n */\nfunction getPointTimeFrame(timestamp, ms_interval) {\n  return Math.floor(timestamp / ms_interval) * ms_interval;\n}\n\nfunction sortByTime(series) {\n  return _.sortBy(series, point => {\n    return point[1];\n  });\n}\n\n/**\n * Fill empty front and end of series by zeroes.\n *\n * |   ***   |    |   ***   |\n * |___   ___| -> |***   ***|\n * @param {*} series\n * @param {*} timestamps\n */\nfunction fillZeroes(series, timestamps) {\n  const prepend = [];\n  const append = [];\n  let new_point;\n  for (let i = 0; i < timestamps.length; i++) {\n    if (timestamps[i] < series[0][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      prepend.push(new_point);\n    } else if (timestamps[i] > series[series.length - 1][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      append.push(new_point);\n    }\n  }\n  return _.concat(_.concat(prepend, series), append);\n}\n\n/**\n * Interpolate series with gaps\n */\nfunction interpolateSeries(series) {\n  let left, right;\n\n  // Interpolate series\n  for (let i = series.length - 1; i >= 0; i--) {\n    if (!series[i][0]) {\n      left = findNearestLeft(series, i);\n      right = findNearestRight(series, i);\n      if (!left) {\n        left = right;\n      }\n      if (!right) {\n        right = left;\n      }\n      series[i][0] = linearInterpolation(series[i][1], left, right);\n    }\n  }\n  return series;\n}\n\nfunction linearInterpolation(timestamp, left, right) {\n  if (left[1] === right[1]) {\n    return (left[0] + right[0]) / 2;\n  } else {\n    return (left[0] + (right[0] - left[0]) / (right[1] - left[1]) * (timestamp - left[1]));\n  }\n}\n\nfunction findNearestRight(series, pointIndex) {\n  for (let i = pointIndex; i < series.length; i++) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction findNearestLeft(series, pointIndex) {\n  for (let i = pointIndex; i > 0; i--) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction flattenDatapoints(datapoints) {\n  const depth = utils.getArrayDepth(datapoints);\n  if (depth <= 2) {\n    // Don't process if datapoints already flattened\n    return datapoints;\n  }\n  return _.flatten(datapoints);\n}\n\n////////////\n// Export //\n////////////\n\nconst exportedFunctions = {\n  downsample,\n  groupBy,\n  groupBy_perf,\n  groupByRange,\n  sumSeries,\n  scale,\n  offset,\n  scale_perf,\n  delta,\n  rate,\n  simpleMovingAverage,\n  expMovingAverage,\n  SUM,\n  COUNT,\n  AVERAGE,\n  MIN,\n  MAX,\n  MEDIAN,\n  PERCENTILE,\n  sortByTime,\n  flattenDatapoints,\n};\n\nexport default exportedFunctions;\n","import _ from 'lodash';\n// Available in 7.0\n// import { getTemplateSrv } from '@grafana/runtime';\nimport * as utils from './utils';\nimport ts, { groupBy_perf as groupBy } from './timeseries';\n\nconst SUM = ts.SUM;\nconst COUNT = ts.COUNT;\nconst AVERAGE = ts.AVERAGE;\nconst MIN = ts.MIN;\nconst MAX = ts.MAX;\nconst MEDIAN = ts.MEDIAN;\nconst PERCENTILE = ts.PERCENTILE;\n\nconst downsampleSeries = ts.downsample;\nconst groupBy_exported = (interval, groupFunc, datapoints) => groupBy(datapoints, interval, groupFunc);\nconst sumSeries = ts.sumSeries;\nconst delta = ts.delta;\nconst rate = ts.rate;\nconst scale = (factor, datapoints) => ts.scale_perf(datapoints, factor);\nconst offset = (delta, datapoints) => ts.offset(datapoints, delta);\nconst simpleMovingAverage = (n, datapoints) => ts.simpleMovingAverage(datapoints, n);\nconst expMovingAverage = (a, datapoints) => ts.expMovingAverage(datapoints, a);\nconst percentile = (interval, n, datapoints) => groupBy(datapoints, interval, _.partial(PERCENTILE, n));\n\nfunction limit(order, n, orderByFunc, timeseries) {\n  const orderByCallback = aggregationFunctions[orderByFunc];\n  const sortByIteratee = (ts) => {\n    const values = _.map(ts.datapoints, (point) => {\n      return point[0];\n    });\n    return orderByCallback(values);\n  };\n  const sortedTimeseries = _.sortBy(timeseries, sortByIteratee);\n  if (order === 'bottom') {\n    return sortedTimeseries.slice(0, n);\n  } else {\n    return sortedTimeseries.slice(-n);\n  }\n}\n\nfunction removeAboveValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] > n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction removeBelowValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] < n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction transformNull(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] !== null) ? point[0] : n,\n      point[1]\n    ];\n  });\n}\n\nfunction sortSeries(direction, timeseries: any[]) {\n  return _.orderBy(timeseries, [ts => {\n    return ts.target.toLowerCase();\n  }], direction);\n}\n\nfunction setAlias(alias, timeseries) {\n  // TODO: use getTemplateSrv() when available (since 7.0)\n  if (this.templateSrv && timeseries && timeseries.scopedVars) {\n    alias = this.templateSrv.replace(alias, timeseries.scopedVars);\n  }\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction replaceAlias(regexp, newAlias, timeseries) {\n  let pattern;\n  if (utils.isRegex(regexp)) {\n    pattern = utils.buildRegex(regexp);\n  } else {\n    pattern = regexp;\n  }\n\n  let alias = timeseries.target.replace(pattern, newAlias);\n  // TODO: use getTemplateSrv() when available (since 7.0)\n  if (this.templateSrv && timeseries && timeseries.scopedVars) {\n    alias = this.templateSrv.replace(alias, timeseries.scopedVars);\n  }\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction setAliasByRegex(alias, timeseries) {\n  timeseries.target = extractText(timeseries.target, alias);\n  return timeseries;\n}\n\nfunction extractText(str, pattern) {\n  const extractPattern = new RegExp(pattern);\n  const extractedValue = extractPattern.exec(str);\n  return extractedValue[0];\n}\n\nfunction groupByWrapper(interval, groupFunc, datapoints) {\n  const groupByCallback = aggregationFunctions[groupFunc];\n  return groupBy(datapoints, interval, groupByCallback);\n}\n\nfunction aggregateByWrapper(interval, aggregateFunc, datapoints) {\n  // Flatten all points in frame and then just use groupBy()\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  const groupByCallback = aggregationFunctions[aggregateFunc];\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction aggregateWrapper(groupByCallback, interval, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction percentileAgg(interval, n, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  const groupByCallback = _.partial(PERCENTILE, n);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction timeShift(interval, range) {\n  const shift = utils.parseTimeShiftInterval(interval) / 1000;\n  return _.map(range, time => {\n    return time - shift;\n  });\n}\n\nfunction unShiftTimeSeries(interval, datapoints) {\n  const unshift = utils.parseTimeShiftInterval(interval);\n  return _.map(datapoints, dp => {\n    return [\n      dp[0],\n      dp[1] + unshift\n    ];\n  });\n}\n\nconst metricFunctions = {\n  groupBy: groupByWrapper,\n  scale: scale,\n  offset: offset,\n  delta: delta,\n  rate: rate,\n  movingAverage: simpleMovingAverage,\n  exponentialMovingAverage: expMovingAverage,\n  percentile: percentile,\n  transformNull: transformNull,\n  aggregateBy: aggregateByWrapper,\n  // Predefined aggs\n  percentileAgg: percentileAgg,\n  average: _.partial(aggregateWrapper, AVERAGE),\n  min: _.partial(aggregateWrapper, MIN),\n  max: _.partial(aggregateWrapper, MAX),\n  median: _.partial(aggregateWrapper, MEDIAN),\n  sum: _.partial(aggregateWrapper, SUM),\n  count: _.partial(aggregateWrapper, COUNT),\n  sumSeries: sumSeries,\n  removeAboveValue: removeAboveValue,\n  removeBelowValue: removeBelowValue,\n  top: _.partial(limit, 'top'),\n  bottom: _.partial(limit, 'bottom'),\n  sortSeries: sortSeries,\n  timeShift: timeShift,\n  setAlias: setAlias,\n  setAliasByRegex: setAliasByRegex,\n  replaceAlias: replaceAlias\n};\n\nconst aggregationFunctions = {\n  avg: AVERAGE,\n  min: MIN,\n  max: MAX,\n  median: MEDIAN,\n  sum: SUM,\n  count: COUNT\n};\n\nexport default {\n  downsampleSeries: downsampleSeries,\n  groupBy: groupBy_exported,\n  AVERAGE: AVERAGE,\n  MIN: MIN,\n  MAX: MAX,\n  MEDIAN: MEDIAN,\n  SUM: SUM,\n  COUNT: COUNT,\n  unShiftTimeSeries: unShiftTimeSeries,\n\n  get aggregationFunctions() {\n    return aggregationFunctions;\n  },\n\n  get metricFunctions() {\n    return metricFunctions;\n  }\n};\n","import _ from 'lodash';\nimport TableModel from 'grafana/app/core/table_model';\nimport * as c from './constants';\n\n/**\n * Convert Zabbix API history.get response to Grafana format\n *\n * @return {Array}            Array of timeseries in Grafana format\n *                            {\n *                               target: \"Metric name\",\n *                               datapoints: [[<value>, <unixtime>], ...]\n *                            }\n */\nfunction convertHistory(history, items, addHostName, convertPointCallback) {\n  /**\n   * Response should be in the format:\n   * data: [\n   *          {\n   *             target: \"Metric name\",\n   *             datapoints: [[<value>, <unixtime>], ...]\n   *          }, ...\n   *       ]\n   */\n\n  // Group history by itemid\n  const grouped_history = _.groupBy(history, 'itemid');\n  const hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');  //uniqBy is needed to deduplicate\n\n  return _.map(grouped_history, (hist, itemid) => {\n    const item = _.find(items, {'itemid': itemid}) as any;\n    let alias = item.name;\n\n    // Add scopedVars for using in alias functions\n    const scopedVars: any = {\n      '__zbx_item': { value: item.name },\n      '__zbx_item_name': { value: item.name },\n      '__zbx_item_key': { value: item.key_ },\n    };\n\n    if (_.keys(hosts).length > 0) {\n      const host = _.find(hosts, {'hostid': item.hostid});\n      scopedVars['__zbx_host'] = { value: host.host };\n      scopedVars['__zbx_host_name'] = { value: host.name };\n\n      // Only add host when multiple hosts selected\n      if (_.keys(hosts).length > 1 && addHostName) {\n        alias = host.name + \": \" + alias;\n      }\n    }\n\n    return {\n      target: alias,\n      datapoints: _.map(hist, convertPointCallback),\n      scopedVars,\n    };\n  });\n}\n\nfunction sortTimeseries(timeseries) {\n  // Sort trend data, issue #202\n  _.forEach(timeseries, series => {\n    series.datapoints = _.sortBy(series.datapoints, point => point[c.DATAPOINT_TS]);\n  });\n  return timeseries;\n}\n\nfunction handleHistory(history, items, addHostName = true) {\n  return convertHistory(history, items, addHostName, convertHistoryPoint);\n}\n\nfunction handleTrends(history, items, valueType, addHostName = true) {\n  const convertPointCallback = _.partial(convertTrendPoint, valueType);\n  return convertHistory(history, items, addHostName, convertPointCallback);\n}\n\nfunction handleText(history, items, target, addHostName = true) {\n  const convertTextCallback = _.partial(convertText, target);\n  return convertHistory(history, items, addHostName, convertTextCallback);\n}\n\nfunction handleHistoryAsTable(history, items, target) {\n  const table: any = new TableModel();\n  table.addColumn({text: 'Host'});\n  table.addColumn({text: 'Item'});\n  table.addColumn({text: 'Key'});\n  table.addColumn({text: 'Last value'});\n\n  const grouped_history = _.groupBy(history, 'itemid');\n  _.each(items, (item) => {\n    const itemHistory = grouped_history[item.itemid] || [];\n    const lastPoint = _.last(itemHistory);\n    let lastValue = lastPoint ? lastPoint.value : null;\n\n    if (target.options.skipEmptyValues && (!lastValue || lastValue === '')) {\n      return;\n    }\n\n    // Regex-based extractor\n    if (target.textFilter) {\n      lastValue = extractText(lastValue, target.textFilter, target.useCaptureGroups);\n    }\n\n    let host: any = _.first(item.hosts);\n    host = host ? host.name : \"\";\n\n    table.rows.push([\n      host, item.name, item.key_, lastValue\n    ]);\n  });\n\n  return table;\n}\n\nfunction convertText(target, point) {\n  let value = point.value;\n\n  // Regex-based extractor\n  if (target.textFilter) {\n    value = extractText(point.value, target.textFilter, target.useCaptureGroups);\n  }\n\n  return [\n    value,\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction extractText(str, pattern, useCaptureGroups) {\n  const extractPattern = new RegExp(pattern);\n  const extractedValue = extractPattern.exec(str);\n  if (extractedValue) {\n    if (useCaptureGroups) {\n      return extractedValue[1];\n    } else {\n      return extractedValue[0];\n    }\n  }\n  return \"\";\n}\n\nfunction handleSLAResponse(itservice, slaProperty, slaObject) {\n  const targetSLA = slaObject[itservice.serviceid].sla;\n  if (slaProperty.property === 'status') {\n    const targetStatus = parseInt(slaObject[itservice.serviceid].status, 10);\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: [\n        [targetStatus, targetSLA[0].to * 1000]\n      ]\n    };\n  } else {\n    let i;\n    const slaArr = [];\n    for (i = 0; i < targetSLA.length; i++) {\n      if (i === 0) {\n        slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].from * 1000]);\n      }\n      slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].to * 1000]);\n    }\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: slaArr\n    };\n  }\n}\n\nfunction handleTriggersResponse(triggers, groups, timeRange) {\n  if (!_.isArray(triggers)) {\n    let triggersCount = null;\n    try {\n      triggersCount = Number(triggers);\n    } catch (err) {\n      console.log(\"Error when handling triggers count: \", err);\n    }\n    return {\n      target: \"triggers count\",\n      datapoints: [\n        [triggersCount, timeRange[1] * 1000]\n      ]\n    };\n  } else {\n    const stats = getTriggerStats(triggers);\n    const groupNames = _.map(groups, 'name');\n    const table: any = new TableModel();\n    table.addColumn({text: 'Host group'});\n    _.each(_.orderBy(c.TRIGGER_SEVERITY, ['val'], ['desc']), (severity) => {\n      table.addColumn({text: severity.text});\n    });\n    _.each(stats, (severity_stats, group) => {\n      if (_.includes(groupNames, group)) {\n        let row = _.map(_.orderBy(_.toPairs(severity_stats), (s) => s[0], ['desc']), (s) => s[1]);\n        row = _.concat([group], ...row);\n        table.rows.push(row);\n      }\n    });\n    return table;\n  }\n}\n\nfunction getTriggerStats(triggers) {\n  const groups = _.uniq(_.flattenDeep(_.map(triggers, (trigger) => _.map(trigger.groups, 'name'))));\n  // let severity = _.map(c.TRIGGER_SEVERITY, 'text');\n  const stats = {};\n  _.each(groups, (group) => {\n    stats[group] = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0}; // severity:count\n  });\n  _.each(triggers, (trigger) => {\n    _.each(trigger.groups, (group) => {\n      stats[group.name][trigger.priority]++;\n    });\n  });\n  return stats;\n}\n\nfunction convertHistoryPoint(point) {\n  // Value must be a number for properly work\n  return [\n    Number(point.value),\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction convertTrendPoint(valueType, point) {\n  let value;\n  switch (valueType) {\n    case \"min\":\n      value = point.value_min;\n      break;\n    case \"max\":\n      value = point.value_max;\n      break;\n    case \"avg\":\n      value = point.value_avg;\n      break;\n    case \"sum\":\n      value = point.value_sum;\n      break;\n    case \"count\":\n      value = point.value_count;\n      break;\n    default:\n      value = point.value_avg;\n  }\n\n  return [\n    Number(value),\n    point.clock * 1000\n  ];\n}\n\nexport default {\n  handleHistory,\n  convertHistory,\n  handleTrends,\n  handleText,\n  handleHistoryAsTable,\n  handleSLAResponse,\n  handleTriggersResponse,\n  sortTimeseries\n};\n","import _ from 'lodash';\nimport * as utils from '../datasource-zabbix/utils';\nimport { DataFrame, Field, FieldType, ArrayVector } from '@grafana/data';\nimport { ZBXProblem, ZBXTrigger, ProblemDTO, ZBXEvent } from './types';\n\nexport function joinTriggersWithProblems(problems: ZBXProblem[], triggers: ZBXTrigger[]): ProblemDTO[] {\n  const problemDTOList: ProblemDTO[] = [];\n\n  for (let i = 0; i < problems.length; i++) {\n    const p = problems[i];\n    const triggerId = Number(p.objectid);\n    const t = triggers[triggerId];\n\n    if (t) {\n      const problemDTO: ProblemDTO = {\n        timestamp: Number(p.clock),\n        triggerid: p.objectid,\n        eventid: p.eventid,\n        name: p.name,\n        severity: p.severity,\n        acknowledged: p.acknowledged,\n        acknowledges: p.acknowledges,\n        tags: p.tags,\n        suppressed: p.suppressed,\n        suppression_data: p.suppression_data,\n        description: t.description,\n        comments: t.comments,\n        value: t.value,\n        groups: t.groups,\n        hosts: t.hosts,\n        items: t.items,\n        alerts: t.alerts,\n        url: t.url,\n        expression: t.expression,\n        correlation_mode: t.correlation_mode,\n        correlation_tag: t.correlation_tag,\n        manual_close: t.manual_close,\n        state: t.state,\n        error: t.error,\n      };\n\n      problemDTOList.push(problemDTO);\n    }\n\n  }\n\n  return problemDTOList;\n}\n\ninterface JoinOptions {\n  valueFromEvent?: boolean;\n}\n\nexport function joinTriggersWithEvents(events: ZBXEvent[], triggers: ZBXTrigger[], options?: JoinOptions): ProblemDTO[] {\n  const { valueFromEvent } = options;\n  const problemDTOList: ProblemDTO[] = [];\n\n  for (let i = 0; i < events.length; i++) {\n    const e = events[i];\n    const triggerId = Number(e.objectid);\n    const t = triggers[triggerId];\n\n    if (t) {\n      const problemDTO: ProblemDTO = {\n        value: valueFromEvent ? e.value : t.value,\n        timestamp: Number(e.clock),\n        triggerid: e.objectid,\n        eventid: e.eventid,\n        name: e.name,\n        severity: e.severity,\n        acknowledged: e.acknowledged,\n        acknowledges: e.acknowledges,\n        tags: e.tags,\n        suppressed: e.suppressed,\n        description: t.description,\n        comments: t.comments,\n        groups: t.groups,\n        hosts: t.hosts,\n        items: t.items,\n        alerts: t.alerts,\n        url: t.url,\n        expression: t.expression,\n        correlation_mode: t.correlation_mode,\n        correlation_tag: t.correlation_tag,\n        manual_close: t.manual_close,\n        state: t.state,\n        error: t.error,\n      };\n\n      problemDTOList.push(problemDTO);\n    }\n\n  }\n\n  return problemDTOList;\n}\n\nexport function setMaintenanceStatus(triggers) {\n  _.each(triggers, (trigger) => {\n    const maintenance_status = _.some(trigger.hosts, (host) => host.maintenance_status === '1');\n    trigger.maintenance = maintenance_status;\n  });\n  return triggers;\n}\n\nexport function setAckButtonStatus(triggers, showAckButton) {\n  _.each(triggers, (trigger) => {\n    trigger.showAckButton = showAckButton;\n  });\n  return triggers;\n}\n\nexport function addTriggerDataSource(triggers, target) {\n  _.each(triggers, (trigger) => {\n    trigger.datasource = target.datasource;\n  });\n  return triggers;\n}\n\nexport function addTriggerHostProxy(triggers, proxies) {\n  triggers.forEach(trigger => {\n    if (trigger.hosts && trigger.hosts.length) {\n      const host = trigger.hosts[0];\n      if (host.proxy_hostid !== '0') {\n        const hostProxy = proxies[host.proxy_hostid];\n        host.proxy = hostProxy ? hostProxy.host : '';\n      }\n    }\n  });\n  return triggers;\n}\n\nexport function filterTriggersPre(triggerList, replacedTarget) {\n  // Filter triggers by description\n  const triggerFilter = replacedTarget.trigger.filter;\n  if (triggerFilter) {\n    triggerList = filterTriggers(triggerList, triggerFilter);\n  }\n\n  // Filter by maintenance status\n  if (!replacedTarget.options.hostsInMaintenance) {\n    triggerList = _.filter(triggerList, (trigger) => !trigger.maintenance);\n  }\n\n  return triggerList;\n}\n\nfunction filterTriggers(triggers, triggerFilter) {\n  if (utils.isRegex(triggerFilter)) {\n    return _.filter(triggers, trigger => {\n      return utils.buildRegex(triggerFilter).test(trigger.description);\n    });\n  } else {\n    return _.filter(triggers, trigger => {\n      return trigger.description === triggerFilter;\n    });\n  }\n}\n\nexport function sortProblems(problems: ProblemDTO[], target) {\n  if (target.options?.sortProblems === 'severity') {\n    problems = _.orderBy(problems, ['severity', 'eventid'], ['desc', 'desc']);\n  } else if (target.options?.sortProblems === 'lastchange') {\n    problems = _.orderBy(problems, ['timestamp', 'eventid'], ['desc', 'desc']);\n  }\n  return problems;\n}\n\nexport function toDataFrame(problems: any[]): DataFrame {\n  const problemsField: Field<any> = {\n    name: 'Problems',\n    type: FieldType.other,\n    values: new ArrayVector(problems),\n    config: {},\n  };\n\n  const response: DataFrame = {\n    name: 'problems',\n    fields: [problemsField],\n    length: problems.length,\n  };\n\n  return response;\n}\n\nconst problemsHandler = {\n  addTriggerDataSource,\n  addTriggerHostProxy,\n  setMaintenanceStatus,\n  setAckButtonStatus,\n  filterTriggersPre,\n  sortProblems,\n  toDataFrame,\n  joinTriggersWithProblems,\n  joinTriggersWithEvents,\n};\n\nexport default problemsHandler;\n","/**\n * This module allows to deduplicate function calls with the same params and\n * cache result of function call.\n */\n\nexport class CachingProxy {\n  cacheEnabled: boolean;\n  ttl: number;\n  cache: any;\n  promises: any;\n\n  constructor(cacheOptions) {\n    this.cacheEnabled = cacheOptions.enabled;\n    this.ttl          = cacheOptions.ttl || 600000; // 10 minutes by default\n\n    // Internal objects for data storing\n    this.cache = {};\n    this.promises = {};\n  }\n\n  /**\n   * Check that result is present in the cache and is up to date or send request otherwise.\n   */\n  cacheRequest(func, funcName, funcScope) {\n    return cacheRequest(func, funcName, funcScope, this);\n  }\n\n  /**\n   * Wrap request to prevent multiple calls with same params when request is waiting for response.\n   */\n  proxify(func, funcName, funcScope) {\n    if (!this.promises[funcName]) {\n      this.promises[funcName] = {};\n    }\n    const promiseKeeper = this.promises[funcName];\n    return callOnce(func, promiseKeeper, funcScope);\n  }\n\n  proxifyWithCache(func, funcName, funcScope) {\n    const proxified = this.proxify(func, funcName, funcScope);\n    return this.cacheRequest(proxified, funcName, funcScope);\n  }\n\n  _isExpired(cacheObject) {\n    if (cacheObject) {\n      const object_age = Date.now() - cacheObject.timestamp;\n      return !(cacheObject.timestamp && object_age < this.ttl);\n    } else {\n      return true;\n    }\n  }\n}\n\n/**\n * Wrap request to prevent multiple calls\n * with same params when waiting for result.\n */\nfunction callOnce(func, promiseKeeper, funcScope) {\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    const hash = getRequestHash(arguments);\n    if (!promiseKeeper[hash]) {\n      promiseKeeper[hash] = Promise.resolve(\n        func.apply(funcScope, arguments)\n        .then(result => {\n          promiseKeeper[hash] = null;\n          return result;\n        }).catch(err => {\n          promiseKeeper[hash] = null;\n          throw err;\n        })\n      );\n    }\n    return promiseKeeper[hash];\n  };\n}\n\nfunction cacheRequest(func, funcName, funcScope, self) {\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    if (!self.cache[funcName]) {\n      self.cache[funcName] = {};\n    }\n\n    const cacheObject = self.cache[funcName];\n    const hash = getRequestHash(arguments);\n    if (self.cacheEnabled && !self._isExpired(cacheObject[hash])) {\n      return Promise.resolve(cacheObject[hash].value);\n    } else {\n      return func.apply(funcScope, arguments)\n      .then(result => {\n        if (result !== undefined) {\n          cacheObject[hash] = {\n            value: result,\n            timestamp: Date.now()\n          };\n        }\n        return result;\n      });\n    }\n  };\n}\n\nfunction getRequestHash(args) {\n  const argsJson = JSON.stringify(args);\n  return getHash(argsJson);\n}\n\nfunction getHash(str: string): number {\n  let hash = 0, i, chr, len;\n  if (str.length !== 0) {\n    for (i = 0, len = str.length; i < len; i++) {\n      chr   = str.charCodeAt(i);\n      hash  = ((hash << 5) - hash) + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n  }\n  return hash;\n}\n","import _ from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\n\nexport const DEFAULT_QUERY_LIMIT = 10000;\nexport const HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nexport const TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nexport const consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport const consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max',\n  'sum': 'num*value_avg' // sum of sums inside the one-hour trend period\n};\n\n/**\n * Base class for external history database connectors. Subclasses should implement `getHistory()`, `getTrends()` and\n * `testDataSource()` methods, which describe how to fetch data from source other than Zabbix API.\n */\nexport class DBConnector {\n  constructor(options) {\n    this.datasourceId = options.datasourceId;\n    this.datasourceName = options.datasourceName;\n    this.datasourceTypeId = null;\n    this.datasourceTypeName = null;\n  }\n\n  static loadDatasource(dsId, dsName) {\n    if (!dsName && dsId !== undefined) {\n      let ds = _.find(getDataSourceSrv().getAll(), {'id': dsId});\n      if (!ds) {\n        return Promise.reject(`Data Source with ID ${dsId} not found`);\n      }\n      dsName = ds.name;\n    }\n    if (dsName) {\n      return getDataSourceSrv().loadDatasource(dsName);\n    } else {\n      return Promise.reject(`Data Source name should be specified`);\n    }\n  }\n\n  loadDBDataSource() {\n    return DBConnector.loadDatasource(this.datasourceId, this.datasourceName)\n    .then(ds => {\n      this.datasourceTypeId = ds.meta.id;\n      this.datasourceTypeName = ds.meta.name;\n      if (!this.datasourceName) {\n        this.datasourceName = ds.name;\n      }\n      if (!this.datasourceId) {\n        this.datasourceId = ds.id;\n      }\n      return ds;\n    });\n  }\n\n  /**\n   * Send test request to datasource in order to ensure it's working.\n   */\n  testDataSource() {\n    throw new ZabbixNotImplemented('testDataSource()');\n  }\n\n  /**\n   * Get history data from external sources.\n   */\n  getHistory() {\n    throw new ZabbixNotImplemented('getHistory()');\n  }\n\n  /**\n   * Get trends data from external sources.\n   */\n  getTrends() {\n    throw new ZabbixNotImplemented('getTrends()');\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n}\n\n// Define Zabbix DB Connector exception type for non-implemented methods\nexport class ZabbixNotImplemented {\n  constructor(methodName) {\n    this.code = null;\n    this.name = 'ZabbixNotImplemented';\n    this.message = `Zabbix DB Connector Error: method ${methodName || ''} should be implemented in subclass of DBConnector`;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n\n/**\n * Converts time series returned by the data source into format that Grafana expects\n * time_series is Array of series:\n * ```\n * [{\n *     name: string,\n *     points: Array<[value: number, timestamp: number]>\n * }]\n * ```\n */\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  //uniqBy is needed to deduplicate\n  const hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');\n  let grafanaSeries = _.map(_.compact(time_series), series => {\n    const itemid = series.name;\n    const item = _.find(items, {'itemid': itemid});\n    let alias = item.name;\n\n    // Add scopedVars for using in alias functions\n    const scopedVars = {\n      '__zbx_item': { value: item.name },\n      '__zbx_item_name': { value: item.name },\n      '__zbx_item_key': { value: item.key_ },\n    };\n\n    if (_.keys(hosts).length > 0) {\n      const host = _.find(hosts, {'hostid': item.hostid});\n      scopedVars['__zbx_host'] = { value: host.host };\n      scopedVars['__zbx_host_name'] = { value: host.name };\n\n      // Only add host when multiple hosts selected\n      if (_.keys(hosts).length > 1 && addHostName) {\n        alias = host.name + \": \" + alias;\n      }\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    const datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints,\n      scopedVars,\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nconst defaults = {\n  DBConnector,\n  DEFAULT_QUERY_LIMIT,\n  HISTORY_TO_TABLE_MAP,\n  TREND_TO_TABLE_MAP,\n  consolidateByFunc,\n  consolidateByTrendColumns\n};\n\nexport default defaults;\n","import _ from 'lodash';\nimport semver from 'semver';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as utils from '../../../utils';\nimport { ZBX_ACK_ACTION_NONE, ZBX_ACK_ACTION_ADD_MESSAGE, MIN_SLA_INTERVAL } from '../../../constants';\nimport { ShowProblemTypes, ZBXProblem } from '../../../types';\nimport { GFHTTPRequest, JSONRPCError, ZBXScript, APIExecuteScriptResponse } from './types';\nimport { getBackendSrv } from '@grafana/runtime';\n\nconst DEFAULT_ZABBIX_VERSION = '3.0.0';\n\n/**\n * Zabbix API Wrapper.\n * Creates Zabbix API instance with given parameters (url, credentials and other).\n * Wraps API calls and provides high-level methods.\n */\nexport class ZabbixAPIConnector {\n  backendAPIUrl: string;\n  requestOptions: { basicAuth: any; withCredentials: boolean; };\n  getTrend: (items: any, timeFrom: any, timeTill: any) => Promise<any[]>;\n  version: string;\n  getVersionPromise: Promise<string>;\n  datasourceId: number;\n\n  constructor(basicAuth: any, withCredentials: boolean, datasourceId: number) {\n    this.datasourceId = datasourceId;\n    this.backendAPIUrl = `/api/datasources/${this.datasourceId}/resources/zabbix-api`;\n\n    this.requestOptions = {\n      basicAuth: basicAuth,\n      withCredentials: withCredentials\n    };\n\n    this.getTrend = this.getTrend_ZBXNEXT1193;\n    //getTrend = getTrend_30;\n\n    this.initVersion();\n  }\n\n  //////////////////////////\n  // Core method wrappers //\n  //////////////////////////\n\n  request(method: string, params?: any) {\n    return this.backendAPIRequest(method, params).then(response => {\n      return response?.data?.result;\n    });\n  }\n\n  backendAPIRequest(method: string, params: any = {}) {\n    const requestOptions: GFHTTPRequest = {\n      url: this.backendAPIUrl,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      data: {\n        datasourceId: this.datasourceId,\n        method,\n        params,\n      },\n    };\n\n    // Set request options for basic auth\n    if (this.requestOptions.basicAuth || this.requestOptions.withCredentials) {\n      requestOptions.withCredentials = true;\n    }\n    if (this.requestOptions.basicAuth) {\n      requestOptions.headers.Authorization = this.requestOptions.basicAuth;\n    }\n\n    return getBackendSrv().datasourceRequest(requestOptions);\n  }\n\n  /**\n   * Get Zabbix API version\n   */\n  getVersion() {\n    return this.request('apiinfo.version');\n  }\n\n  initVersion(): Promise<string> {\n    if (!this.getVersionPromise) {\n      this.getVersionPromise = Promise.resolve(\n        this.getVersion().then(version => {\n          if (version) {\n            console.log(`Zabbix version detected: ${version}`);\n          } else {\n            console.log(`Failed to detect Zabbix version, use default ${DEFAULT_ZABBIX_VERSION}`);\n          }\n\n          this.version = version || DEFAULT_ZABBIX_VERSION;\n          this.getVersionPromise = null;\n          return version;\n        })\n      );\n    }\n    return this.getVersionPromise;\n  }\n\n  ////////////////////////////////\n  // Zabbix API method wrappers //\n  ////////////////////////////////\n\n  acknowledgeEvent(eventid: string, message: string, action?: number, severity?: number) {\n    if (!action) {\n      action = semver.gte(this.version, '4.0.0') ? ZBX_ACK_ACTION_ADD_MESSAGE : ZBX_ACK_ACTION_NONE;\n    }\n\n    const params: any = {\n      eventids: eventid,\n      message: message,\n      action: action\n    };\n\n    if (severity) {\n      params.severity = severity;\n    }\n\n    return this.request('event.acknowledge', params);\n  }\n\n  getGroups() {\n    const params = {\n      output: ['name'],\n      sortfield: 'name',\n      real_hosts: true\n    };\n\n    return this.request('hostgroup.get', params);\n  }\n\n  getHosts(groupids) {\n    const params: any = {\n      output: ['name', 'host'],\n      sortfield: 'name'\n    };\n    if (groupids) {\n      params.groupids = groupids;\n    }\n\n    return this.request('host.get', params);\n  }\n\n  getApps(hostids): Promise<any[]> {\n    const params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('application.get', params);\n  }\n\n  /**\n   * Get Zabbix items\n   * @param  {[type]} hostids  host ids\n   * @param  {[type]} appids   application ids\n   * @param  {String} itemtype 'num' or 'text'\n   * @return {[type]}          array of items\n   */\n  getItems(hostids, appids, itemtype) {\n    const params: any = {\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      sortfield: 'name',\n      webitems: true,\n      filter: {},\n      selectHosts: ['hostid', 'name', 'host']\n    };\n    if (hostids) {\n      params.hostids = hostids;\n    }\n    if (appids) {\n      params.applicationids = appids;\n    }\n    if (itemtype === 'num') {\n      // Return only numeric metrics\n      params.filter.value_type = [0, 3];\n    }\n    if (itemtype === 'text') {\n      // Return only text metrics\n      params.filter.value_type = [1, 2, 4];\n    }\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getItemsByIDs(itemids) {\n    const params = {\n      itemids: itemids,\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      webitems: true,\n      selectHosts: ['hostid', 'name']\n    };\n\n    return this.request('item.get', params)\n    .then(items => utils.expandItems(items));\n  }\n\n  getMacros(hostids) {\n    const params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getGlobalMacros() {\n    const params = {\n      output: 'extend',\n      globalmacro: true\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getLastValue(itemid) {\n    const params = {\n      output: ['lastvalue'],\n      itemids: itemid\n    };\n    return this.request('item.get', params)\n    .then(items => items.length ? items[0].lastvalue : null);\n  }\n\n  /**\n   * Perform history query from Zabbix API\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} timeFrom   Time in seconds\n   * @param  {Number} timeTill   Time in seconds\n   * @return {Array}  Array of Zabbix history objects\n   */\n  getHistory(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const params: any = {\n        output: 'extend',\n        history: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('history.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  /**\n   * Perform trends query from Zabbix API\n   * Use trends api extension from ZBXNEXT-1193 patch.\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} time_from   Time in seconds\n   * @param  {Number} time_till   Time in seconds\n   * @return {Array}  Array of Zabbix trend objects\n   */\n  getTrend_ZBXNEXT1193(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const params: any = {\n        output: 'extend',\n        trend: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('trend.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  getTrend_30(items, time_from, time_till, value_type) {\n    const self = this;\n    const itemids = _.map(items, 'itemid');\n\n    const params: any = {\n      output: [\"itemid\",\n        \"clock\",\n        value_type\n      ],\n      itemids: itemids,\n      time_from: time_from\n    };\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (time_till) {\n      params.time_till = time_till;\n    }\n\n    return self.request('trend.get', params);\n  }\n\n  getITService(serviceids?) {\n    const params = {\n      output: 'extend',\n      serviceids: serviceids\n    };\n    return this.request('service.get', params);\n  }\n\n  getSLA(serviceids, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    let intervals = [{ from: timeFrom, to: timeTo }];\n    if (options.slaInterval === 'auto') {\n      const interval = getSLAInterval(options.intervalMs);\n      intervals = buildSLAIntervals(timeRange, interval);\n    } else if (options.slaInterval !== 'none') {\n      const interval = utils.parseInterval(options.slaInterval) / 1000;\n      intervals = buildSLAIntervals(timeRange, interval);\n    }\n\n    const params: any = {\n      serviceids,\n      intervals\n    };\n\n    return this.request('service.getsla', params);\n  }\n\n  getProblems(groupids, hostids, applicationids, options): Promise<ZBXProblem[]> {\n    const { timeFrom, timeTo, recent, severities, limit, acknowledged, tags } = options;\n\n    const params: any = {\n      output: 'extend',\n      selectAcknowledges: 'extend',\n      selectSuppressionData: 'extend',\n      selectTags: 'extend',\n      source: '0',\n      object: '0',\n      sortfield: ['eventid'],\n      sortorder: 'DESC',\n      evaltype: '0',\n      // preservekeys: '1',\n      groupids,\n      hostids,\n      applicationids,\n      recent,\n    };\n\n    if (severities) {\n      params.severities = severities;\n    }\n\n    if (acknowledged !== undefined) {\n      params.acknowledged = acknowledged;\n    }\n\n    if (tags) {\n      params.tags = tags;\n    }\n\n    if (limit) {\n      params.limit = limit;\n    }\n\n    if (timeFrom || timeTo) {\n      params.time_from = timeFrom;\n      params.time_till = timeTo;\n    }\n\n    return this.request('problem.get', params).then(utils.mustArray);\n  }\n\n  getTriggersByIds(triggerids: string[]) {\n    const params: any = {\n      output: 'extend',\n      triggerids: triggerids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      // selectLastEvent: 'extend',\n      // selectTags: 'extend',\n      preservekeys: '1',\n    };\n\n    return this.request('trigger.get', params).then(utils.mustArray);\n  }\n\n  getTriggers(groupids, hostids, applicationids, options) {\n    const {showTriggers, maintenance, timeFrom, timeTo} = options;\n\n    const params: any = {\n      output: 'extend',\n      groupids: groupids,\n      hostids: hostids,\n      applicationids: applicationids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      filter: {\n        value: 1\n      },\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      selectLastEvent: 'extend',\n      selectTags: 'extend'\n    };\n\n    if (showTriggers === ShowProblemTypes.Problems) {\n      params.filter.value = 1;\n    } else if (showTriggers === ShowProblemTypes.Recent || showTriggers === ShowProblemTypes.History) {\n      params.filter.value = [0, 1];\n    }\n\n    if (maintenance) {\n      params.maintenance = true;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getEvents(objectids, timeFrom, timeTo, showEvents, limit) {\n    const params: any = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      objectids: objectids,\n      select_acknowledges: 'extend',\n      selectHosts: 'extend',\n      value: showEvents,\n    };\n\n    if (limit) {\n      params.limit = limit;\n      params.sortfield = 'clock';\n      params.sortorder = 'DESC';\n    }\n\n    return this.request('event.get', params).then(utils.mustArray);\n  }\n\n  getEventsHistory(groupids, hostids, applicationids, options) {\n    const { timeFrom, timeTo, severities, limit, value } = options;\n\n    const params: any = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      value: '1',\n      source: '0',\n      object: '0',\n      evaltype: '0',\n      sortfield: ['eventid'],\n      sortorder: 'DESC',\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      selectSuppressionData: ['maintenanceid', 'suppress_until'],\n      groupids,\n      hostids,\n      applicationids,\n    };\n\n    if (limit) {\n      params.limit = limit;\n    }\n\n    if (severities) {\n      params.severities = severities;\n    }\n\n    if (value) {\n      params.value = value;\n    }\n\n    return this.request('event.get', params).then(utils.mustArray);\n  }\n\n  getExtendedEventData(eventids) {\n    const params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params);\n  }\n\n  getEventAlerts(eventids) {\n    const params = {\n      eventids: eventids,\n      output: [\n        'eventid',\n        'message',\n        'clock',\n        'error'\n      ],\n      selectUsers: true,\n    };\n\n    return this.request('alert.get', params);\n  }\n\n  getAcknowledges(eventids) {\n    const params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params)\n    .then(events => {\n      return _.filter(events, (event) => event.acknowledges.length);\n    });\n  }\n\n  getAlerts(itemids, timeFrom, timeTo) {\n    const params: any = {\n      output: 'extend',\n      itemids: itemids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      // filter: {\n      //   value: 1\n      // },\n      selectLastEvent: 'extend'\n    };\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getHostAlerts(hostids, applicationids, options) {\n    const {minSeverity, acknowledged, count, timeFrom, timeTo} = options;\n    const params: any = {\n      output: 'extend',\n      hostids: hostids,\n      min_severity: minSeverity,\n      filter: { value: 1 },\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectLastEvent: 'extend',\n      selectGroups: 'extend',\n      selectHosts: ['host', 'name']\n    };\n\n    if (count && acknowledged !== 0 && acknowledged !== 1) {\n      params.countOutput = true;\n    }\n\n    if (applicationids && applicationids.length) {\n      params.applicationids = applicationids;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params)\n    .then((triggers) => {\n      if (!count || acknowledged === 0 || acknowledged === 1) {\n        triggers = filterTriggersByAcknowledge(triggers, acknowledged);\n        if (count) {\n          triggers = triggers.length;\n        }\n      }\n      return triggers;\n    });\n  }\n\n  getProxies() {\n    const params = {\n      output: ['proxyid', 'host'],\n    };\n\n    return this.request('proxy.get', params);\n  }\n\n  getScripts(hostids: string[], options?: any): Promise<ZBXScript[]> {\n    const params: any = {\n      output: 'extend',\n      hostids,\n    };\n\n    return this.request('script.get', params).then(utils.mustArray);\n  }\n\n  executeScript(hostid: string, scriptid: string): Promise<APIExecuteScriptResponse> {\n    const params: any = {\n      hostid,\n      scriptid,\n    };\n\n    return this.request('script.execute', params);\n  }\n}\n\nfunction filterTriggersByAcknowledge(triggers, acknowledged) {\n  if (acknowledged === 0) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"0\");\n  } else if (acknowledged === 1) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"1\");\n  } else {\n    return triggers;\n  }\n}\n\nfunction getSLAInterval(intervalMs) {\n  // Too many intervals may cause significant load on the database, so decrease number of resulting points\n  const resolutionRatio = 100;\n  const interval = kbn.round_interval(intervalMs * resolutionRatio) / 1000;\n  return Math.max(interval, MIN_SLA_INTERVAL);\n}\n\nfunction buildSLAIntervals(timeRange, interval) {\n  let [timeFrom, timeTo] = timeRange;\n  const intervals = [];\n\n  // Align time range with calculated interval\n  timeFrom = Math.floor(timeFrom / interval) * interval;\n  timeTo = Math.ceil(timeTo / interval) * interval;\n\n  for (let i = timeFrom; i <= timeTo - interval; i += interval) {\n    intervals.push({\n      from : i,\n      to : (i + interval)\n    });\n\n  }\n\n  return intervals;\n}\n\n// Define zabbix API exception type\nexport class ZabbixAPIError {\n  code: number;\n  name: string;\n  data: string;\n  message: string;\n\n  constructor(error: JSONRPCError) {\n    this.code = error.code || null;\n    this.name = error.message || \"\";\n    this.data = error.data || \"\";\n    this.message = \"Zabbix API Error: \" + this.name + \" \" + this.data;\n  }\n\n  toString() {\n    return this.name + \" \" + this.data;\n  }\n}\n","/**\n * MySQL queries\n */\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, MIN(clock) AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY (clock-${timeFrom}) DIV ${intervalSec}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, MIN(clock) AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY (clock-${timeFrom}) DIV ${intervalSec}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `SELECT CAST(itemid AS CHAR) AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst mysql = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default mysql;\n","/**\n * Postgres queries\n */\n\nconst ITEMID_FORMAT = 'FM99999999999999999999';\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `\n  SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst postgres = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default postgres;\n","import _ from 'lodash';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { compactQuery } from '../../../utils';\nimport mysql from './mysql';\nimport postgres from './postgres';\nimport dbConnector, { DBConnector, DEFAULT_QUERY_LIMIT, HISTORY_TO_TABLE_MAP, TREND_TO_TABLE_MAP } from '../dbConnector';\n\nconst supportedDatabases = {\n  mysql: 'mysql',\n  postgres: 'postgres'\n};\n\nexport class SQLConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n\n    this.limit = options.limit || DEFAULT_QUERY_LIMIT;\n    this.sqlDialect = null;\n\n    super.loadDBDataSource()\n    .then(() => {\n      this.loadSQLDialect();\n    });\n  }\n\n  loadSQLDialect() {\n    if (this.datasourceTypeId === supportedDatabases.postgres) {\n      this.sqlDialect = postgres;\n    } else {\n      this.sqlDialect = mysql;\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    let testQuery = this.sqlDialect.testQuery();\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    // The interval must match the time range exactly n times, otherwise\n    // the resulting first and last data points will yield invalid values in the\n    // calculated average value in downsampleSeries - when using consolidateBy(avg)\n    let numOfIntervals = Math.ceil((timeTill - timeFrom) / intervalSec);\n    intervalSec = (timeTill - timeFrom) / numOfIntervals;\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n      let query = this.sqlDialect.historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy } = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    // The interval must match the time range exactly n times, otherwise\n    // the resulting first and last data points will yield invalid values in the\n    // calculated average value in downsampleSeries - when using consolidateBy(avg)\n    let numOfIntervals = Math.ceil((timeTill - timeFrom) / intervalSec);\n    intervalSec = (timeTill - timeFrom) / numOfIntervals;\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max', 'sum'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = dbConnector.consolidateByTrendColumns[valueColumn];\n      let query = this.sqlDialect.trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.datasourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return getBackendSrv().datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n","import _ from 'lodash';\nimport { compactQuery } from '../../../utils';\nimport { DBConnector, HISTORY_TO_TABLE_MAP, consolidateByTrendColumns } from '../dbConnector';\n\nconst consolidateByFunc = {\n  'avg': 'MEAN',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport class InfluxDBConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n    this.retentionPolicy = options.retentionPolicy;\n    super.loadDBDataSource().then(ds => {\n      this.influxDS = ds;\n      return ds;\n    });\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    return this.influxDS.testDatasource().then(result => {\n      if (result.status && result.status === 'error') {\n        return Promise.reject({ data: {\n          message: `InfluxDB connection error: ${result.message}`\n        }});\n      }\n      return result;\n    });\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy, retentionPolicy } = options;\n    const intervalSec = Math.ceil(intervalMs / 1000);\n\n    const range = { timeFrom, timeTill };\n    consolidateBy = consolidateBy || 'avg';\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const table = HISTORY_TO_TABLE_MAP[value_type];\n      const query = this.buildHistoryQuery(itemids, table, range, intervalSec, consolidateBy, retentionPolicy);\n      return this.invokeInfluxDBQuery(query);\n    });\n\n    return Promise.all(promises)\n    .then(_.flatten)\n    .then(results => {\n      return handleInfluxHistoryResponse(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    options.retentionPolicy = this.retentionPolicy;\n    return this.getHistory(items, timeFrom, timeTill, options);\n  }\n\n  buildHistoryQuery(itemids, table, range, intervalSec, aggFunction, retentionPolicy) {\n    const { timeFrom, timeTill } = range;\n    const measurement = retentionPolicy ? `\"${retentionPolicy}\".\"${table}\"` : `\"${table}\"`;\n    let value = 'value';\n    if (retentionPolicy) {\n      value = consolidateByTrendColumns[aggFunction] || 'value_avg';\n    }\n    const aggregation = consolidateByFunc[aggFunction] || aggFunction;\n    const where_clause = this.buildWhereClause(itemids);\n    const query = `SELECT ${aggregation}(\"${value}\") FROM ${measurement}\n      WHERE ${where_clause} AND \"time\" >= ${timeFrom}s AND \"time\" <= ${timeTill}s\n      GROUP BY time(${intervalSec}s), \"itemid\" fill(none)`;\n    return compactQuery(query);\n  }\n\n  buildWhereClause(itemids) {\n    const itemidsWhere = itemids.map(itemid => `\"itemid\" = '${itemid}'`).join(' OR ');\n    return `(${itemidsWhere})`;\n  }\n\n  invokeInfluxDBQuery(query) {\n    return this.influxDS._seriesQuery(query)\n    .then(data => data && data.results ? data.results : []);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction handleInfluxHistoryResponse(results) {\n  if (!results) {\n    return [];\n  }\n\n  const seriesList = [];\n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n\n    if (result.error) {\n      const error = `InfluxDB error: ${result.error}`;\n      return Promise.reject(new Error(error));\n    }\n\n    if (!result || !result.series) {\n      continue;\n    }\n\n    const influxSeriesList = results[i].series;\n\n    for (let y = 0; y < influxSeriesList.length; y++) {\n      const influxSeries = influxSeriesList[y];\n      const datapoints = [];\n      if (influxSeries.values) {\n        for (i = 0; i < influxSeries.values.length; i++) {\n          datapoints[i] = [influxSeries.values[i][1], influxSeries.values[i][0]];\n        }\n      }\n      const timeSeries = {\n        name: influxSeries.tags.itemid,\n        points: datapoints\n      };\n      seriesList.push(timeSeries);\n    }\n  }\n\n  return seriesList;\n}\n","import _ from 'lodash';\nimport moment from 'moment';\nimport * as utils from '../utils';\nimport responseHandler from '../responseHandler';\nimport { CachingProxy } from './proxy/cachingProxy';\n// import { ZabbixNotImplemented } from './connectors/dbConnector';\nimport { DBConnector } from './connectors/dbConnector';\nimport { ZabbixAPIConnector } from './connectors/zabbix_api/zabbixAPIConnector';\nimport { SQLConnector } from './connectors/sql/sqlConnector';\nimport { InfluxDBConnector } from './connectors/influxdb/influxdbConnector';\nimport { ZabbixConnector } from './types';\nimport { joinTriggersWithProblems, joinTriggersWithEvents } from '../problemsHandler';\nimport { ProblemDTO } from '../types';\n\ninterface AppsResponse extends Array<any> {\n  appFilterEmpty?: boolean;\n  hostids?: any[];\n}\n\nconst REQUESTS_TO_PROXYFY = [\n  'getHistory', 'getTrend', 'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs',\n  'getEvents', 'getAlerts', 'getHostAlerts', 'getAcknowledges', 'getITService', 'getSLA', 'getVersion', 'getProxies',\n  'getEventAlerts', 'getExtendedEventData', 'getProblems', 'getEventsHistory', 'getTriggersByIds', 'getScripts'\n];\n\nconst REQUESTS_TO_CACHE = [\n  'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs', 'getITService', 'getProxies'\n];\n\nconst REQUESTS_TO_BIND = [\n  'getHistory', 'getTrend', 'getMacros', 'getItemsByIDs', 'getEvents', 'getAlerts', 'getHostAlerts',\n  'getAcknowledges', 'getITService', 'getVersion', 'acknowledgeEvent', 'getProxies', 'getEventAlerts',\n  'getExtendedEventData', 'getScripts', 'executeScript',\n];\n\nexport class Zabbix implements ZabbixConnector {\n  enableDirectDBConnection: boolean;\n  cachingProxy: CachingProxy;\n  zabbixAPI: ZabbixAPIConnector;\n  getHistoryDB: any;\n  dbConnector: any;\n  getTrendsDB: any;\n\n  getHistory: (items, timeFrom, timeTill) => Promise<any>;\n  getTrend: (items, timeFrom, timeTill) => Promise<any>;\n  getItemsByIDs: (itemids) => Promise<any>;\n  getEvents: (objectids, timeFrom, timeTo, showEvents, limit?) => Promise<any>;\n  getAlerts: (itemids, timeFrom?, timeTo?) => Promise<any>;\n  getHostAlerts: (hostids, applicationids, options?) => Promise<any>;\n  getAcknowledges: (eventids) => Promise<any>;\n  getITService: (serviceids?) => Promise<any>;\n  acknowledgeEvent: (eventid, message) => Promise<any>;\n  getProxies: () => Promise<any>;\n  getEventAlerts: (eventids) => Promise<any>;\n  getExtendedEventData: (eventids) => Promise<any>;\n  getMacros: (hostids: any[]) => Promise<any>;\n  getVersion: () => Promise<string>;\n\n  constructor(options) {\n    const {\n      basicAuth,\n      withCredentials,\n      cacheTTL,\n      enableDirectDBConnection,\n      dbConnectionDatasourceId,\n      dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy,\n      datasourceId,\n    } = options;\n\n    this.enableDirectDBConnection = enableDirectDBConnection;\n\n    // Initialize caching proxy for requests\n    const cacheOptions = {\n      enabled: true,\n      ttl: cacheTTL\n    };\n    this.cachingProxy = new CachingProxy(cacheOptions);\n\n    this.zabbixAPI = new ZabbixAPIConnector(basicAuth, withCredentials, datasourceId);\n\n    this.proxifyRequests();\n    this.cacheRequests();\n    this.bindRequests();\n\n    if (enableDirectDBConnection) {\n      const connectorOptions: any = { dbConnectionRetentionPolicy };\n      this.initDBConnector(dbConnectionDatasourceId, dbConnectionDatasourceName, connectorOptions)\n      .then(() => {\n        this.getHistoryDB = this.cachingProxy.proxifyWithCache(this.dbConnector.getHistory, 'getHistory', this.dbConnector);\n        this.getTrendsDB = this.cachingProxy.proxifyWithCache(this.dbConnector.getTrends, 'getTrends', this.dbConnector);\n      });\n    }\n  }\n\n  initDBConnector(datasourceId, datasourceName, options) {\n    return DBConnector.loadDatasource(datasourceId, datasourceName)\n    .then(ds => {\n      const connectorOptions: any = { datasourceId, datasourceName };\n      if (ds.type === 'influxdb') {\n        connectorOptions.retentionPolicy = options.dbConnectionRetentionPolicy;\n        this.dbConnector = new InfluxDBConnector(connectorOptions);\n      } else {\n        this.dbConnector = new SQLConnector(connectorOptions);\n      }\n      return this.dbConnector;\n    });\n  }\n\n  proxifyRequests() {\n    for (const request of REQUESTS_TO_PROXYFY) {\n      this.zabbixAPI[request] = this.cachingProxy.proxify(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  cacheRequests() {\n    for (const request of REQUESTS_TO_CACHE) {\n      this.zabbixAPI[request] = this.cachingProxy.cacheRequest(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  bindRequests() {\n    for (const request of REQUESTS_TO_BIND) {\n      this[request] = this.zabbixAPI[request].bind(this.zabbixAPI);\n    }\n  }\n\n  /**\n   * Perform test query for Zabbix API and external history DB.\n   * @return {object} test result object:\n   * ```\n   *    {\n   *      zabbixVersion,\n   *      dbConnectorStatus: {\n   *        dsType,\n   *        dsName\n   *      }\n   *    }\n   * ```\n   */\n  testDataSource() {\n    let zabbixVersion;\n    let dbConnectorStatus;\n    return this.getVersion()\n    .then(version => {\n      zabbixVersion = version;\n      return this.getAllGroups();\n    })\n    .then(() => {\n      if (this.enableDirectDBConnection) {\n        return this.dbConnector.testDataSource();\n      } else {\n        return Promise.resolve();\n      }\n    })\n    .catch(error => {\n      return Promise.reject(error);\n    })\n    .then(testResult => {\n      if (testResult) {\n        dbConnectorStatus = {\n          dsType: this.dbConnector.datasourceTypeName,\n          dsName: this.dbConnector.datasourceName\n        };\n      }\n      return { zabbixVersion, dbConnectorStatus };\n    });\n  }\n\n  getItemsFromTarget(target, options) {\n    const parts = ['group', 'host', 'application', 'item'];\n    const filters = _.map(parts, p => target[p].filter);\n    return this.getItems(...filters, options);\n  }\n\n  getHostsFromTarget(target) {\n    const parts = ['group', 'host', 'application'];\n    const filters = _.map(parts, p => target[p].filter);\n    return Promise.all([\n      this.getHosts(...filters),\n      this.getApps(...filters),\n    ]).then(results => {\n      const hosts = results[0];\n      let apps: AppsResponse = results[1];\n      if (apps.appFilterEmpty) {\n        apps = [];\n      }\n      return [hosts, apps];\n    });\n  }\n\n  getAllGroups() {\n    return this.zabbixAPI.getGroups();\n  }\n\n  getGroups(groupFilter) {\n    return this.getAllGroups()\n    .then(groups => findByFilter(groups, groupFilter));\n  }\n\n  /**\n   * Get list of host belonging to given groups.\n   */\n  getAllHosts(groupFilter) {\n    return this.getGroups(groupFilter)\n    .then(groups => {\n      const groupids = _.map(groups, 'groupid');\n      return this.zabbixAPI.getHosts(groupids);\n    });\n  }\n\n  getHosts(groupFilter?, hostFilter?) {\n    return this.getAllHosts(groupFilter)\n    .then(hosts => findByFilter(hosts, hostFilter));\n  }\n\n  /**\n   * Get list of applications belonging to given groups and hosts.\n   */\n  getAllApps(groupFilter, hostFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      const hostids = _.map(hosts, 'hostid');\n      return this.zabbixAPI.getApps(hostids);\n    });\n  }\n\n  getApps(groupFilter?, hostFilter?, appFilter?): Promise<AppsResponse> {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      const hostids = _.map(hosts, 'hostid');\n      if (appFilter) {\n        return this.zabbixAPI.getApps(hostids)\n        .then(apps => filterByQuery(apps, appFilter));\n      } else {\n        const appsResponse: AppsResponse = hostids;\n        appsResponse.hostids = hostids;\n        appsResponse.appFilterEmpty = true;\n        return Promise.resolve(appsResponse);\n      }\n    });\n  }\n\n  getAllItems(groupFilter, hostFilter, appFilter, options: any = {}) {\n    return this.getApps(groupFilter, hostFilter, appFilter)\n    .then(apps => {\n      if (apps.appFilterEmpty) {\n        return this.zabbixAPI.getItems(apps.hostids, undefined, options.itemtype);\n      } else {\n        const appids = _.map(apps, 'applicationid');\n        return this.zabbixAPI.getItems(undefined, appids, options.itemtype);\n      }\n    })\n    .then(items => {\n      if (!options.showDisabledItems) {\n        items = _.filter(items, {'status': '0'});\n      }\n\n      return items;\n    })\n    .then(this.expandUserMacro.bind(this));\n  }\n\n  expandUserMacro(items, isTriggerItem) {\n    const hostids = getHostIds(items);\n    return this.getMacros(hostids)\n    .then(macros => {\n      _.forEach(items, item => {\n        if (utils.containsMacro(isTriggerItem ? item.url : item.name)) {\n          if (isTriggerItem) {\n            item.url = utils.replaceMacro(item, macros, isTriggerItem);\n          } else {\n            item.name = utils.replaceMacro(item, macros);\n          }\n        }\n      });\n      return items;\n    });\n  }\n\n  getItems(groupFilter?, hostFilter?, appFilter?, itemFilter?, options = {}) {\n    return this.getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => filterByQuery(items, itemFilter));\n  }\n\n  getItemValues(groupFilter?, hostFilter?, appFilter?, itemFilter?, options: any = {}) {\n    return this.getItems(groupFilter, hostFilter, appFilter, itemFilter, options).then(items => {\n      let timeRange = [moment().subtract(2, 'h').unix(), moment().unix()];\n      if (options.range) {\n        timeRange = [options.range.from.unix(), options.range.to.unix()];\n      }\n      const [timeFrom, timeTo] = timeRange;\n\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo).then(history => {\n        if (history) {\n          const values = _.uniq(history.map(v => v.value));\n          return values.map(value => ({ name: value }));\n        } else {\n          return [];\n        }\n      });\n    });\n  }\n\n  getITServices(itServiceFilter) {\n    return this.zabbixAPI.getITService()\n    .then(itServices => findByFilter(itServices, itServiceFilter));\n  }\n\n  getProblems(groupFilter, hostFilter, appFilter, proxyFilter?, options?): Promise<ProblemDTO[]> {\n    const promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      const [filteredGroups, filteredHosts, filteredApps] = results;\n      const query: any = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter && hostFilter !== '/.*/') {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getProblems(query.groupids, query.hostids, query.applicationids, options))\n    .then(problems => {\n      const triggerids = problems?.map(problem => problem.objectid);\n      return Promise.all([\n        Promise.resolve(problems),\n        this.zabbixAPI.getTriggersByIds(triggerids)\n      ]);\n    })\n    .then(([problems, triggers]) => joinTriggersWithProblems(problems, triggers))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter));\n    // .then(triggers => this.expandUserMacro.bind(this)(triggers, true));\n  }\n\n  getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter?, options?): Promise<ProblemDTO[]> {\n    const { valueFromEvent } = options;\n\n    const promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      const [filteredGroups, filteredHosts, filteredApps] = results;\n      const query: any = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter) {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getEventsHistory(query.groupids, query.hostids, query.applicationids, options))\n    .then(problems => {\n      const triggerids = problems?.map(problem => problem.objectid);\n      return Promise.all([Promise.resolve(problems), this.zabbixAPI.getTriggersByIds(triggerids)]);\n    })\n    .then(([problems, triggers]) => joinTriggersWithEvents(problems, triggers, { valueFromEvent }))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter));\n    // .then(triggers => this.expandUserMacro.bind(this)(triggers, true));\n  }\n\n  filterTriggersByProxy(triggers, proxyFilter) {\n    return this.getFilteredProxies(proxyFilter)\n    .then(proxies => {\n      if (proxyFilter && proxyFilter !== '/.*/' && triggers) {\n        const proxy_ids = proxies.map(proxy => proxy.proxyid);\n        triggers = triggers.filter(trigger => {\n          for (let i = 0; i < trigger.hosts.length; i++) {\n            const host = trigger.hosts[i];\n            if (proxy_ids.includes(host.proxy_hostid)) {\n              return true;\n            }\n          }\n          return false;\n        });\n      }\n      return triggers;\n    });\n  }\n\n  getFilteredProxies(proxyFilter) {\n    return this.zabbixAPI.getProxies()\n    .then(proxies => {\n      proxies.forEach(proxy => proxy.name = proxy.host);\n      return findByFilter(proxies, proxyFilter);\n    });\n  }\n\n  getHistoryTS(items, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getHistoryDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleHistory(history, items));\n    }\n  }\n\n  getTrends(items, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getTrendsDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      const valueType = options.consolidateBy || options.valueType;\n      return this.zabbixAPI.getTrend(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleTrends(history, items, valueType))\n      .then(responseHandler.sortTimeseries); // Sort trend data, issue #202\n    }\n  }\n\n  getHistoryText(items, timeRange, target) {\n    const [timeFrom, timeTo] = timeRange;\n    if (items.length) {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => {\n        if (target.resultFormat === 'table') {\n          return responseHandler.handleHistoryAsTable(history, items, target);\n        } else {\n          return responseHandler.handleText(history, items, target);\n        }\n      });\n    } else {\n      return Promise.resolve([]);\n    }\n  }\n\n  getSLA(itservices, timeRange, target, options) {\n    const itServiceIds = _.map(itservices, 'serviceid');\n    return this.zabbixAPI.getSLA(itServiceIds, timeRange, options)\n    .then(slaResponse => {\n      return _.map(itServiceIds, serviceid => {\n        const itservice = _.find(itservices, {'serviceid': serviceid});\n        return responseHandler.handleSLAResponse(itservice, target.slaProperty, slaResponse);\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Find group, host, app or item by given name.\n * @param  list list of groups, apps or other\n * @param  name visible name\n * @return      array with finded element or empty array\n */\nfunction findByName(list, name) {\n  const finded = _.find(list, {'name': name});\n  if (finded) {\n    return [finded];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Different hosts can contains applications and items with same name.\n * For this reason use _.filter, which return all elements instead _.find,\n * which return only first finded.\n * @param  {[type]} list list of elements\n * @param  {[type]} name app name\n * @return {[type]}      array with finded element or empty array\n */\nfunction filterByName(list, name) {\n  const finded = _.filter(list, {'name': name});\n  if (finded) {\n    return finded;\n  } else {\n    return [];\n  }\n}\n\nfunction filterByRegex(list, regex) {\n  const filterPattern = utils.buildRegex(regex);\n  return _.filter(list, (zbx_obj) => {\n    return filterPattern.test(zbx_obj.name);\n  });\n}\n\nfunction findByFilter(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return findByName(list, filter);\n  }\n}\n\nfunction filterByQuery(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return filterByName(list, filter);\n  }\n}\n\nfunction getHostIds(items) {\n  const hostIds = _.map(items, item => {\n    return _.map(item.hosts, 'hostid');\n  });\n  return _.uniq(_.flatten(hostIds));\n}\n","import _ from 'lodash';\nimport config from 'grafana/app/core/config';\nimport { contextSrv } from 'grafana/app/core/core';\nimport * as dateMath from 'grafana/app/core/utils/datemath';\nimport * as utils from './utils';\nimport * as migrations from './migrations';\nimport * as metricFunctions from './metricFunctions';\nimport * as c from './constants';\nimport dataProcessor from './dataProcessor';\nimport responseHandler from './responseHandler';\nimport problemsHandler from './problemsHandler';\nimport { Zabbix } from './zabbix/zabbix';\nimport { ZabbixAPIError } from './zabbix/connectors/zabbix_api/zabbixAPIConnector';\nimport { ZabbixMetricsQuery, ZabbixDSOptions, VariableQueryTypes, ShowProblemTypes, ProblemDTO } from './types';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { DataSourceApi, DataSourceInstanceSettings } from '@grafana/data';\n\nexport class ZabbixDatasource extends DataSourceApi<ZabbixMetricsQuery, ZabbixDSOptions> {\n  name: string;\n  basicAuth: any;\n  withCredentials: any;\n\n  trends: boolean;\n  trendsFrom: string;\n  trendsRange: string;\n  cacheTTL: any;\n  disableReadOnlyUsersAck: boolean;\n  enableDirectDBConnection: boolean;\n  dbConnectionDatasourceId: number;\n  dbConnectionDatasourceName: string;\n  dbConnectionRetentionPolicy: string;\n  enableDebugLog: boolean;\n  datasourceId: number;\n  zabbix: Zabbix;\n\n  replaceTemplateVars: (target: any, scopedVars?: any) => any;\n\n  /** @ngInject */\n  constructor(instanceSettings: DataSourceInstanceSettings<ZabbixDSOptions>, private templateSrv) {\n    super(instanceSettings);\n\n    this.templateSrv = templateSrv;\n    this.enableDebugLog = config.buildInfo.env === 'development';\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = _.partial(replaceTemplateVars, this.templateSrv);\n\n    // General data source settings\n    this.datasourceId     = instanceSettings.id;\n    this.name             = instanceSettings.name;\n    this.basicAuth        = instanceSettings.basicAuth;\n    this.withCredentials  = instanceSettings.withCredentials;\n\n    const jsonData = migrations.migrateDSConfig(instanceSettings.jsonData);\n\n    // Use trends instead history since specified time\n    this.trends           = jsonData.trends;\n    this.trendsFrom       = jsonData.trendsFrom || '7d';\n    this.trendsRange      = jsonData.trendsRange || '4d';\n\n    // Set cache update interval\n    const ttl = jsonData.cacheTTL || '1h';\n    this.cacheTTL = utils.parseInterval(ttl);\n\n    // Other options\n    this.disableReadOnlyUsersAck = jsonData.disableReadOnlyUsersAck;\n\n    // Direct DB Connection options\n    this.enableDirectDBConnection = jsonData.dbConnectionEnable || false;\n    this.dbConnectionDatasourceId = jsonData.dbConnectionDatasourceId;\n    this.dbConnectionDatasourceName = jsonData.dbConnectionDatasourceName;\n    this.dbConnectionRetentionPolicy = jsonData.dbConnectionRetentionPolicy;\n\n    const zabbixOptions = {\n      basicAuth: this.basicAuth,\n      withCredentials: this.withCredentials,\n      cacheTTL: this.cacheTTL,\n      enableDirectDBConnection: this.enableDirectDBConnection,\n      dbConnectionDatasourceId: this.dbConnectionDatasourceId,\n      dbConnectionDatasourceName: this.dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy: this.dbConnectionRetentionPolicy,\n      datasourceId: this.datasourceId,\n    };\n\n    this.zabbix = new Zabbix(zabbixOptions);\n  }\n\n  ////////////////////////\n  // Datasource methods //\n  ////////////////////////\n\n  /**\n   * Query panel data. Calls for each panel in dashboard.\n   * @param  {Object} options   Contains time range, targets and other info.\n   * @return {Object} Grafana metrics object with timeseries data for each target.\n   */\n  query(options) {\n    // Create request for each target\n    const promises = _.map(options.targets, t => {\n      // Don't request for hidden targets\n      if (t.hide) {\n        return [];\n      }\n\n      let timeFrom = Math.ceil(dateMath.parse(options.range.from) / 1000);\n      let timeTo = Math.ceil(dateMath.parse(options.range.to) / 1000);\n\n      // Add range variables\n      options.scopedVars = Object.assign({}, options.scopedVars, utils.getRangeScopedVars(options.range));\n\n      // Prevent changes of original object\n      let target = _.cloneDeep(t);\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n\n      // Apply Time-related functions (timeShift(), etc)\n      const timeFunctions = bindFunctionDefs(target.functions, 'Time');\n      if (timeFunctions.length) {\n        const [time_from, time_to] = utils.sequence(timeFunctions)([timeFrom, timeTo]);\n        timeFrom = time_from;\n        timeTo = time_to;\n      }\n      const timeRange = [timeFrom, timeTo];\n\n      const useTrends = this.isUseTrends(timeRange);\n\n      // Metrics or Text query\n      if (!target.queryType || target.queryType === c.MODE_METRICS || target.queryType === c.MODE_TEXT) {\n        // Don't request undefined targets\n        if (!target.group || !target.host || !target.item) {\n          return [];\n        }\n\n        if (!target.queryType || target.queryType === c.MODE_METRICS) {\n          return this.queryNumericData(target, timeRange, useTrends, options);\n        } else if (target.queryType === c.MODE_TEXT) {\n          return this.queryTextData(target, timeRange);\n        } else {\n          return [];\n        }\n      } else if (target.queryType === c.MODE_ITEMID) {\n        // Item ID query\n        if (!target.itemids) {\n          return [];\n        }\n        return this.queryItemIdData(target, timeRange, useTrends, options);\n      } else if (target.queryType === c.MODE_ITSERVICE) {\n        // IT services query\n        return this.queryITServiceData(target, timeRange, options);\n      } else if (target.queryType === c.MODE_TRIGGERS) {\n        // Triggers query\n        return this.queryTriggersData(target, timeRange);\n      } else if (target.queryType === c.MODE_PROBLEMS) {\n        // Problems query\n        return this.queryProblems(target, timeRange, options);\n      } else {\n        return [];\n      }\n    });\n\n    // Data for panel (all targets)\n    return Promise.all(_.flatten(promises))\n      .then(_.flatten)\n      .then(data => {\n        return { data: data };\n      });\n  }\n\n  doTsdbRequest(options) {\n    const tsdbRequestData: any = {\n      queries: options.targets.map(target => {\n        target.datasourceId = this.datasourceId;\n        target.queryType = 'zabbixAPI';\n        return target;\n      }),\n    };\n\n    if (options.range) {\n      tsdbRequestData.from = options.range.from.valueOf().toString();\n      tsdbRequestData.to = options.range.to.valueOf().toString();\n    }\n\n    return getBackendSrv().post('/api/tsdb/query', tsdbRequestData);\n  }\n\n  /**\n   * @returns {Promise<TSDBResponse>}\n   */\n  doTSDBConnectionTest() {\n    /**\n     * @type {{ queries: ZabbixConnectionTestQuery[] }}\n     */\n    const tsdbRequestData = {\n      queries: [\n        {\n          datasourceId: this.datasourceId,\n          queryType: 'connectionTest'\n        }\n      ]\n    };\n\n    return getBackendSrv().post('/api/tsdb/query', tsdbRequestData);\n  }\n\n  /**\n   * Query target data for Metrics\n   */\n  queryNumericData(target, timeRange, useTrends, options) {\n    let queryStart, queryEnd;\n    const getItemOptions = {\n      itemtype: 'num'\n    };\n    return this.zabbix.getItemsFromTarget(target, getItemOptions)\n    .then(items => {\n      queryStart = new Date().getTime();\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    }).then(result => {\n      queryEnd = new Date().getTime();\n      if (this.enableDebugLog) {\n        console.log(`Datasource::Performance Query Time (${this.name}): ${queryEnd - queryStart}`);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * Query history for numeric items\n   */\n  queryNumericDataForItems(items, target, timeRange, useTrends, options) {\n    let getHistoryPromise;\n    options.valueType = this.getTrendValueType(target);\n    options.consolidateBy = getConsolidateBy(target) || options.valueType;\n\n    if (useTrends) {\n      getHistoryPromise = this.zabbix.getTrends(items, timeRange, options);\n    } else {\n      getHistoryPromise = this.zabbix.getHistoryTS(items, timeRange, options);\n    }\n\n    return getHistoryPromise\n    .then(timeseries => this.applyDataProcessingFunctions(timeseries, target))\n    .then(timeseries => downsampleSeries(timeseries, options));\n  }\n\n  getTrendValueType(target) {\n    // Find trendValue() function and get specified trend value\n    const trendFunctions = _.map(metricFunctions.getCategories()['Trends'], 'name');\n    const trendValueFunc = _.find(target.functions, func => {\n      return _.includes(trendFunctions, func.def.name);\n    });\n    return trendValueFunc ? trendValueFunc.params[0] : \"avg\";\n  }\n\n  applyDataProcessingFunctions(timeseries_data, target) {\n    const transformFunctions   = bindFunctionDefs(target.functions, 'Transform');\n    const aggregationFunctions = bindFunctionDefs(target.functions, 'Aggregate');\n    const filterFunctions      = bindFunctionDefs(target.functions, 'Filter');\n    const aliasFunctions       = bindFunctionDefs(target.functions, 'Alias');\n\n    // Apply transformation functions\n    timeseries_data = _.cloneDeep(_.map(timeseries_data, timeseries => {\n      timeseries.datapoints = utils.sequence(transformFunctions)(timeseries.datapoints);\n      return timeseries;\n    }));\n\n    // Apply filter functions\n    if (filterFunctions.length) {\n      timeseries_data = utils.sequence(filterFunctions)(timeseries_data);\n    }\n\n    // Apply aggregations\n    if (aggregationFunctions.length) {\n      let dp = _.map(timeseries_data, 'datapoints');\n      dp = utils.sequence(aggregationFunctions)(dp);\n\n      const aggFuncNames = _.map(metricFunctions.getCategories()['Aggregate'], 'name');\n      const lastAgg = _.findLast(target.functions, func => {\n        return _.includes(aggFuncNames, func.def.name);\n      });\n\n      timeseries_data = [{\n        target: lastAgg.text,\n        datapoints: dp\n      }];\n    }\n\n    // Apply alias functions\n    _.forEach(timeseries_data, utils.sequence(aliasFunctions).bind(this));\n\n    // Apply Time-related functions (timeShift(), etc)\n    // Find timeShift() function and get specified trend value\n    this.applyTimeShiftFunction(timeseries_data, target);\n\n    return timeseries_data;\n  }\n\n  applyTimeShiftFunction(timeseries_data, target) {\n    // Find timeShift() function and get specified interval\n    const timeShiftFunc = _.find(target.functions, (func) => {\n      return func.def.name === 'timeShift';\n    });\n    if (timeShiftFunc) {\n      const shift = timeShiftFunc.params[0];\n      _.forEach(timeseries_data, (series) => {\n        series.datapoints = dataProcessor.unShiftTimeSeries(shift, series.datapoints);\n      });\n    }\n  }\n\n  /**\n   * Query target data for Text\n   */\n  queryTextData(target, timeRange) {\n    const options = {\n      itemtype: 'text'\n    };\n    return this.zabbix.getItemsFromTarget(target, options)\n    .then(items => {\n      return this.zabbix.getHistoryText(items, timeRange, target);\n    });\n  }\n\n  /**\n   * Query target data for Item ID\n   */\n  queryItemIdData(target, timeRange, useTrends, options) {\n    let itemids = target.itemids;\n    itemids = this.templateSrv.replace(itemids, options.scopedVars, zabbixItemIdsTemplateFormat);\n    itemids = _.map(itemids.split(','), itemid => itemid.trim());\n\n    if (!itemids) {\n      return [];\n    }\n\n    return this.zabbix.getItemsByIDs(itemids)\n    .then(items => {\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    });\n  }\n\n  /**\n   * Query target data for IT Services\n   */\n  queryITServiceData(target, timeRange, options) {\n    // Don't show undefined and hidden targets\n    if (target.hide || (!target.itservice && !target.itServiceFilter) || !target.slaProperty) {\n      return [];\n    }\n\n    let itServiceFilter;\n    options.isOldVersion = target.itservice && !target.itServiceFilter;\n\n    if (options.isOldVersion) {\n      // Backward compatibility\n      itServiceFilter = '/.*/';\n    } else {\n      itServiceFilter = this.replaceTemplateVars(target.itServiceFilter, options.scopedVars);\n    }\n\n    options.slaInterval = target.slaInterval;\n\n    return this.zabbix.getITServices(itServiceFilter)\n    .then(itservices => {\n      if (options.isOldVersion) {\n        itservices = _.filter(itservices, {'serviceid': target.itservice?.serviceid});\n      }\n      return this.zabbix.getSLA(itservices, timeRange, target, options);})\n    .then(itservicesdp => this.applyDataProcessingFunctions(itservicesdp, target));\n  }\n\n  queryTriggersData(target, timeRange) {\n    const [timeFrom, timeTo] = timeRange;\n    return this.zabbix.getHostsFromTarget(target)\n    .then(results => {\n      const [hosts, apps] = results;\n      if (hosts.length) {\n        const hostids = _.map(hosts, 'hostid');\n        const appids = _.map(apps, 'applicationid');\n        const options = {\n          minSeverity: target.triggers.minSeverity,\n          acknowledged: target.triggers.acknowledged,\n          count: target.triggers.count,\n          timeFrom: timeFrom,\n          timeTo: timeTo\n        };\n        const groupFilter = target.group.filter;\n        return Promise.all([\n          this.zabbix.getHostAlerts(hostids, appids, options),\n          this.zabbix.getGroups(groupFilter)\n        ])\n        .then(([triggers, groups]) => {\n          return responseHandler.handleTriggersResponse(triggers, groups, timeRange);\n        });\n      } else {\n        return Promise.resolve([]);\n      }\n    });\n  }\n\n  queryProblems(target, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    const userIsEditor = contextSrv.isEditor || contextSrv.isGrafanaAdmin;\n\n    let proxies;\n    let showAckButton = true;\n\n    const showProblems = target.showProblems || ShowProblemTypes.Problems;\n    const showProxy = target.options.hostProxy;\n\n    const getProxiesPromise = showProxy ? this.zabbix.getProxies() : () => [];\n    showAckButton = !this.disableReadOnlyUsersAck || userIsEditor;\n\n    // Replace template variables\n    const groupFilter = this.replaceTemplateVars(target.group?.filter, options.scopedVars);\n    const hostFilter = this.replaceTemplateVars(target.host?.filter, options.scopedVars);\n    const appFilter = this.replaceTemplateVars(target.application?.filter, options.scopedVars);\n    const proxyFilter = this.replaceTemplateVars(target.proxy?.filter, options.scopedVars);\n\n    const triggerFilter = this.replaceTemplateVars(target.trigger?.filter, options.scopedVars);\n    const tagsFilter = this.replaceTemplateVars(target.tags?.filter, options.scopedVars);\n\n    const replacedTarget = {\n      ...target,\n      trigger: { filter: triggerFilter },\n      tags: { filter: tagsFilter },\n    };\n\n    // replaceTemplateVars() builds regex-like string, so we should trim it.\n    const tagsFilterStr = tagsFilter.replace('/^', '').replace('$/', '');\n    const tags = utils.parseTags(tagsFilterStr);\n    tags.forEach(tag => {\n      // Zabbix uses {\"tag\": \"<tag>\", \"value\": \"<value>\", \"operator\": \"<operator>\"} format, where 1 means Equal\n      tag.operator = 1;\n    });\n\n    const problemsOptions: any = {\n      recent: showProblems === ShowProblemTypes.Recent,\n      minSeverity: target.options?.minSeverity,\n      limit: target.options?.limit,\n    };\n\n    if (tags && tags.length) {\n      problemsOptions.tags = tags;\n    }\n\n    if (target.options?.acknowledged === 0 || target.options?.acknowledged === 1) {\n      problemsOptions.acknowledged = target.options?.acknowledged ? true : false;\n    }\n\n    if (target.options?.minSeverity) {\n      let severities = [0, 1, 2, 3, 4, 5].filter(v => v >= target.options?.minSeverity);\n      if (target.options?.severities) {\n        severities = severities.filter(v => target.options?.severities.includes(v));\n      }\n      problemsOptions.severities = severities;\n    }\n\n    let getProblemsPromise: Promise<ProblemDTO[]>;\n    if (showProblems === ShowProblemTypes.History) {\n      problemsOptions.timeFrom = timeFrom;\n      problemsOptions.timeTo = timeTo;\n      getProblemsPromise = this.zabbix.getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions);\n    } else {\n      getProblemsPromise = this.zabbix.getProblems(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions);\n    }\n\n    const problemsPromises = Promise.all([\n      getProblemsPromise,\n      getProxiesPromise\n    ])\n    .then(([problems, sourceProxies]) => {\n      proxies = _.keyBy(sourceProxies, 'proxyid');\n      return problems;\n    })\n    .then(problems => problemsHandler.setMaintenanceStatus(problems))\n    .then(problems => problemsHandler.setAckButtonStatus(problems, showAckButton))\n    .then(problems => problemsHandler.filterTriggersPre(problems, replacedTarget))\n    .then(problems => problemsHandler.sortProblems(problems, target))\n    .then(problems => problemsHandler.addTriggerDataSource(problems, target))\n    .then(problems => problemsHandler.addTriggerHostProxy(problems, proxies));\n\n    return problemsPromises.then(problems => {\n      const problemsDataFrame = problemsHandler.toDataFrame(problems);\n      return problemsDataFrame;\n    });\n  }\n\n  /**\n   * Test connection to Zabbix API and external history DB.\n   */\n  async testDatasource() {\n    try {\n      const { zabbixVersion, dbConnectorStatus } = await this.zabbix.testDataSource();\n      let message = `Zabbix API version: ${zabbixVersion}`;\n      if (dbConnectorStatus) {\n        message += `, DB connector type: ${dbConnectorStatus.dsType}`;\n      }\n      return {\n        status: \"success\",\n        title: \"Success\",\n        message: message\n      };\n    } catch (error) {\n      if (error instanceof ZabbixAPIError) {\n        return {\n          status: \"error\",\n          title: error.message,\n          message: error.message\n        };\n      } else if (error.data && error.data.message) {\n        return {\n          status: \"error\",\n          title: \"Zabbix Client Error\",\n          message: error.data.message\n        };\n      } else if (typeof (error) === 'string') {\n        return {\n          status: \"error\",\n          title: \"Unknown Error\",\n          message: error\n        };\n      } else {\n        console.log(error);\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Could not connect to given url\"\n        };\n      }\n    }\n  }\n\n  ////////////////\n  // Templating //\n  ////////////////\n\n  /**\n   * Find metrics from templated request.\n   *\n   * @param  {string} query Query from Templating\n   * @return {string}       Metric name - group, host, app or item or list\n   *                        of metrics in \"{metric1,metcic2,...,metricN}\" format.\n   */\n  metricFindQuery(query, options) {\n    let resultPromise;\n    let queryModel = _.cloneDeep(query);\n\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    if (typeof query === 'string') {\n      // Backward compatibility\n      queryModel = utils.parseLegacyVariableQuery(query);\n    }\n\n    for (const prop of ['group', 'host', 'application', 'item']) {\n      queryModel[prop] = this.replaceTemplateVars(queryModel[prop], {});\n    }\n\n    const { group, host, application, item } = queryModel;\n\n    switch (queryModel.queryType) {\n      case VariableQueryTypes.Group:\n        resultPromise = this.zabbix.getGroups(queryModel.group);\n        break;\n      case VariableQueryTypes.Host:\n        resultPromise = this.zabbix.getHosts(queryModel.group, queryModel.host);\n        break;\n      case VariableQueryTypes.Application:\n        resultPromise = this.zabbix.getApps(queryModel.group, queryModel.host, queryModel.application);\n        break;\n      case VariableQueryTypes.Item:\n        resultPromise = this.zabbix.getItems(queryModel.group, queryModel.host, queryModel.application, queryModel.item);\n        break;\n      case VariableQueryTypes.ItemValues:\n        const range = options?.range;\n        resultPromise = this.zabbix.getItemValues(group, host, application, item, { range });\n        break;\n      default:\n        resultPromise = Promise.resolve([]);\n        break;\n    }\n\n    return resultPromise.then(metrics => {\n      return _.map(metrics, formatMetric);\n    });\n  }\n\n  /////////////////\n  // Annotations //\n  /////////////////\n\n  annotationQuery(options) {\n    const timeRange = options.range || options.rangeRaw;\n    const timeFrom = Math.ceil(dateMath.parse(timeRange.from) / 1000);\n    const timeTo = Math.ceil(dateMath.parse(timeRange.to) / 1000);\n    const annotation = options.annotation;\n\n    // Show all triggers\n    const problemsOptions: any = {\n      value: annotation.showOkEvents ? ['0', '1'] : '1',\n      valueFromEvent: true,\n      timeFrom,\n      timeTo,\n    };\n\n    if (annotation.minseverity) {\n      const severities = [0, 1, 2, 3, 4, 5].filter(v => v >= Number(annotation.minseverity));\n      problemsOptions.severities = severities;\n    }\n\n    const groupFilter = this.replaceTemplateVars(annotation.group, {});\n    const hostFilter = this.replaceTemplateVars(annotation.host, {});\n    const appFilter = this.replaceTemplateVars(annotation.application, {});\n    const proxyFilter = undefined;\n\n    return this.zabbix.getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions)\n    .then(problems => {\n      // Filter triggers by description\n      const problemName = this.replaceTemplateVars(annotation.trigger, {});\n      if (utils.isRegex(problemName)) {\n        problems = _.filter(problems, p => {\n          return utils.buildRegex(problemName).test(p.description);\n        });\n      } else if (problemName) {\n        problems = _.filter(problems, p => {\n          return p.description === problemName;\n        });\n      }\n\n      // Hide acknowledged events if option enabled\n      if (annotation.hideAcknowledged) {\n        problems = _.filter(problems, p => {\n          return !p.acknowledges?.length;\n        });\n      }\n\n      return _.map(problems, p => {\n        const formattedAcknowledges = utils.formatAcknowledges(p.acknowledges);\n\n        let annotationTags: string[] = [];\n        if (annotation.showHostname) {\n          annotationTags = _.map(p.hosts, 'name');\n        }\n\n        return {\n          title: p.value === '1' ? 'Problem' : 'OK',\n          time: p.timestamp * 1000,\n          annotation: annotation,\n          text: p.name + formattedAcknowledges,\n          tags: annotationTags,\n        };\n      });\n    });\n  }\n\n  // Replace template variables\n  replaceTargetVariables(target, options) {\n    const parts = ['group', 'host', 'application', 'item'];\n    _.forEach(parts, p => {\n      if (target[p] && target[p].filter) {\n        target[p].filter = this.replaceTemplateVars(target[p].filter, options.scopedVars);\n      }\n    });\n    target.textFilter = this.replaceTemplateVars(target.textFilter, options.scopedVars);\n\n    _.forEach(target.functions, func => {\n      func.params = _.map(func.params, param => {\n        if (typeof param === 'number') {\n          return +this.templateSrv.replace(param.toString(), options.scopedVars);\n        } else {\n          return this.templateSrv.replace(param, options.scopedVars);\n        }\n      });\n    });\n  }\n\n  isUseTrends(timeRange) {\n    const [timeFrom, timeTo] = timeRange;\n    const useTrendsFrom = Math.ceil(dateMath.parse('now-' + this.trendsFrom) / 1000);\n    const useTrendsRange = Math.ceil(utils.parseInterval(this.trendsRange) / 1000);\n    const useTrends = this.trends && (\n      (timeFrom < useTrendsFrom) ||\n      (timeTo - timeFrom > useTrendsRange)\n    );\n    return useTrends;\n  }\n}\n\nfunction bindFunctionDefs(functionDefs, category) {\n  const aggregationFunctions = _.map(metricFunctions.getCategories()[category], 'name');\n  const aggFuncDefs = _.filter(functionDefs, func => {\n    return _.includes(aggregationFunctions, func.def.name);\n  });\n\n  return _.map(aggFuncDefs, func => {\n    const funcInstance = metricFunctions.createFuncInstance(func.def, func.params);\n    return funcInstance.bindFunction(dataProcessor.metricFunctions);\n  });\n}\n\nfunction getConsolidateBy(target) {\n  let consolidateBy;\n  const funcDef = _.find(target.functions, func => {\n    return func.def.name === 'consolidateBy';\n  });\n  if (funcDef && funcDef.params && funcDef.params.length) {\n    consolidateBy = funcDef.params[0];\n  }\n  return consolidateBy;\n}\n\nfunction downsampleSeries(timeseries_data, options) {\n  const defaultAgg = dataProcessor.aggregationFunctions['avg'];\n  const consolidateByFunc = dataProcessor.aggregationFunctions[options.consolidateBy] || defaultAgg;\n  return _.map(timeseries_data, timeseries => {\n    if (timeseries.datapoints.length > options.maxDataPoints) {\n      timeseries.datapoints = dataProcessor\n        .groupBy(options.interval, consolidateByFunc, timeseries.datapoints);\n    }\n    return timeseries;\n  });\n}\n\nfunction formatMetric(metricObj) {\n  return {\n    text: metricObj.name,\n    expandable: false\n  };\n}\n\n/**\n * Custom formatter for template variables.\n * Default Grafana \"regex\" formatter returns\n * value1|value2\n * This formatter returns\n * (value1|value2)\n * This format needed for using in complex regex with\n * template variables, for example\n * /CPU $cpu_item.*time/ where $cpu_item is system,user,iowait\n */\nexport function zabbixTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return utils.escapeRegex(value);\n  }\n\n  const escapedValues = _.map(value, utils.escapeRegex);\n  return '(' + escapedValues.join('|') + ')';\n}\n\nfunction zabbixItemIdsTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return value.join(',');\n}\n\n/**\n * If template variables are used in request, replace it using regex format\n * and wrap with '/' for proper multi-value work. Example:\n * $variable selected as a, b, c\n * We use filter $variable\n * $variable    -> a|b|c    -> /a|b|c/\n * /$variable/  -> /a|b|c/  -> /a|b|c/\n */\nfunction replaceTemplateVars(templateSrv, target, scopedVars) {\n  let replacedTarget = templateSrv.replace(target, scopedVars, zabbixTemplateFormat);\n  if (target !== replacedTarget && !utils.isRegex(replacedTarget)) {\n    replacedTarget = '/^' + replacedTarget + '$/';\n  }\n  return replacedTarget;\n}\n\nfunction filterEnabledTargets(targets) {\n  return _.filter(targets, target => {\n    return !(target.hide || !target.group || !target.host || !target.item);\n  });\n}\n","import React, { FC } from 'react';\nimport { css, cx } from 'emotion';\nimport { EventsWithValidation, ValidationEvents, useTheme } from '@grafana/ui';\nimport { GrafanaTheme } from '@grafana/data';\nimport { isRegex, variableRegex } from '../utils';\n\nimport * as grafanaUi from '@grafana/ui';\nconst Input = (grafanaUi as any).LegacyForms?.Input || (grafanaUi as any).Input;\n\nconst variablePattern = RegExp(`^${variableRegex.source}`);\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  inputRegex: css`\n    color: ${theme.palette.orange}\n  `,\n  inputVariable: css`\n    color: ${theme.colors.textBlue}\n  `,\n});\n\nconst zabbixInputValidationEvents: ValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    {\n      rule: value => {\n        if (!value) {\n          return true;\n        }\n        if (value.length > 1 && value[0] === '/') {\n          if (value[value.length - 1] !== '/') {\n            return false;\n          }\n        }\n        return true;\n      },\n      errorMessage: 'Not a valid regex',\n    },\n    {\n      rule: value => {\n        if (value === '*') {\n          return false;\n        }\n        return true;\n      },\n      errorMessage: 'Wildcards not supported. Use /.*/ instead',\n    },\n  ],\n};\n\nexport const ZabbixInput: FC<any> = ({ value, ref, validationEvents, ...restProps }) => {\n  const theme = useTheme();\n  const styles = getStyles(theme);\n\n  let inputClass = styles.inputRegex;\n  if (variablePattern.test(value as string)) {\n    inputClass = styles.inputVariable;\n  } else if (isRegex(value)) {\n    inputClass = styles.inputRegex;\n  }\n\n  return (\n    <Input\n      className={inputClass}\n      value={value}\n      validationEvents={zabbixInputValidationEvents}\n      {...restProps}\n    />\n  );\n};\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\nimport * as c from './constants';\nimport * as utils from './utils';\nimport * as metricFunctions from './metricFunctions';\nimport * as migrations from './migrations';\nimport { ShowProblemTypes } from './types';\nimport { CURRENT_SCHEMA_VERSION } from '../panel-triggers/migrations';\n\n\nfunction getTargetDefaults() {\n  return {\n    queryType: c.MODE_METRICS,\n    group: { 'filter': \"\" },\n    host: { 'filter': \"\" },\n    application: { 'filter': \"\" },\n    item: { 'filter': \"\" },\n    functions: [],\n    triggers: {\n      'count': true,\n      'minSeverity': 3,\n      'acknowledged': 2\n    },\n    trigger: {filter: \"\"},\n    tags: {filter: \"\"},\n    proxy: {filter: \"\"},\n    options: {\n      showDisabledItems: false,\n      skipEmptyValues: false,\n    },\n    table: {\n      'skipEmptyValues': false\n    },\n  };\n}\n\nfunction getSLATargetDefaults() {\n  return {\n    slaProperty: { name: \"SLA\", property: \"sla\" },\n    slaInterval: 'none',\n  };\n}\n\nfunction getProblemsTargetDefaults() {\n  return {\n    showProblems: ShowProblemTypes.Problems,\n    options: {\n      minSeverity: 0,\n      sortProblems: 'default',\n      acknowledged: 2,\n      hostsInMaintenance: false,\n      hostProxy: false,\n      limit: c.DEFAULT_ZABBIX_PROBLEMS_LIMIT,\n    },\n  };\n}\n\nfunction getSeverityOptions() {\n  return c.TRIGGER_SEVERITY;\n}\n\nfunction mapSeverityOptionsFromPanel(severityOptions: any[]) {\n  if (!severityOptions) {\n    return [0, 1, 2, 3, 4, 5];\n  }\n\n  const severities = [];\n  for (const sevOption of severityOptions) {\n    if (sevOption.show) {\n      severities.push(sevOption.priority);\n    }\n  }\n  return severities;\n}\n\nexport class ZabbixQueryController extends QueryCtrl {\n  static templateUrl: string;\n\n  zabbix: any;\n  replaceTemplateVars: any;\n  templateSrv: any;\n  editorModes: Array<{ value: string; text: string; queryType: number; }>;\n  slaPropertyList: Array<{ name: string; property: string; }>;\n  slaIntervals: Array<{ text: string; value: string; }>;\n  ackFilters: Array<{ text: string; value: number; }>;\n  problemAckFilters: string[];\n  sortByFields: Array<{ text: string; value: string; }>;\n  showEventsFields: Array<{ text: string; value: number[]; } | { text: string; value: number; }>;\n  showProblemsOptions: Array<{ text: string; value: string; }>;\n  resultFormats: Array<{ text: string; value: string; }>;\n  severityOptions: Array<{ val: number; text: string; }>;\n  getGroupNames: (...args: any[]) => any;\n  getHostNames: (...args: any[]) => any;\n  getApplicationNames: (...args: any[]) => any;\n  getItemNames: (...args: any[]) => any;\n  getITServices: (...args: any[]) => any;\n  getProxyNames: (...args: any[]) => any;\n  getVariables: (...args: any[]) => any;\n  init: () => void;\n  queryOptionsText: string;\n  metric: any;\n  showQueryOptions: boolean;\n\n  /** @ngInject */\n  constructor($scope, $injector, $rootScope, $sce, templateSrv) {\n    super($scope, $injector);\n    this.zabbix = this.datasource.zabbix;\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = this.datasource.replaceTemplateVars;\n    this.templateSrv = templateSrv;\n\n    this.editorModes = [\n      {value: 'num',       text: 'Metrics',     queryType: c.MODE_METRICS},\n      {value: 'text',      text: 'Text',        queryType: c.MODE_TEXT},\n      {value: 'itservice', text: 'IT Services', queryType: c.MODE_ITSERVICE},\n      {value: 'itemid',    text: 'Item ID',     queryType: c.MODE_ITEMID},\n      {value: 'triggers',  text: 'Triggers',    queryType: c.MODE_TRIGGERS},\n      {value: 'problems',  text: 'Problems',    queryType: c.MODE_PROBLEMS},\n    ];\n\n    this.$scope.editorMode = {\n      METRICS: c.MODE_METRICS,\n      TEXT: c.MODE_TEXT,\n      ITSERVICE: c.MODE_ITSERVICE,\n      ITEMID: c.MODE_ITEMID,\n      TRIGGERS: c.MODE_TRIGGERS,\n      PROBLEMS: c.MODE_PROBLEMS,\n    };\n\n    this.slaPropertyList = [\n      {name: \"Status\", property: \"status\"},\n      {name: \"SLA\", property: \"sla\"},\n      {name: \"OK time\", property: \"okTime\"},\n      {name: \"Problem time\", property: \"problemTime\"},\n      {name: \"Down time\", property: \"downtimeTime\"}\n    ];\n\n    this.slaIntervals = [\n      { text: 'No interval', value: 'none' },\n      { text: 'Auto', value: 'auto' },\n      { text: '1 hour', value: '1h' },\n      { text: '12 hours', value: '12h' },\n      { text: '24 hours', value: '1d' },\n      { text: '1 week', value: '1w' },\n      { text: '1 month', value: '1M' },\n    ];\n\n    this.ackFilters = [\n      {text: 'all triggers', value: 2},\n      {text: 'unacknowledged', value: 0},\n      {text: 'acknowledged', value: 1},\n    ];\n\n    this.problemAckFilters = [\n      'all triggers',\n      'unacknowledged',\n      'acknowledged'\n    ];\n\n    this.sortByFields = [\n      { text: 'Default', value: 'default' },\n      { text: 'Last change', value: 'lastchange' },\n      { text: 'Severity',    value: 'severity' },\n    ];\n\n    this.showEventsFields = [\n      { text: 'All',      value: [0,1] },\n      { text: 'OK',       value: [0] },\n      { text: 'Problems', value: 1 }\n    ];\n\n    this.showProblemsOptions = [\n      { text: 'Problems', value: 'problems' },\n      { text: 'Recent problems', value: 'recent' },\n      { text: 'History', value: 'history' },\n    ];\n\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n\n    this.severityOptions = getSeverityOptions();\n\n    // Map functions for bs-typeahead\n    this.getGroupNames = _.bind(this.getMetricNames, this, 'groupList');\n    this.getHostNames = _.bind(this.getMetricNames, this, 'hostList', true);\n    this.getApplicationNames = _.bind(this.getMetricNames, this, 'appList');\n    this.getItemNames = _.bind(this.getMetricNames, this, 'itemList');\n    this.getITServices = _.bind(this.getMetricNames, this, 'itServiceList');\n    this.getProxyNames = _.bind(this.getMetricNames, this, 'proxyList');\n    this.getVariables = _.bind(this.getTemplateVariables, this);\n\n    // Update metric suggestion when template variable was changed\n    $rootScope.$on('template-variable-value-updated', () => this.onVariableChange());\n\n    // Update metrics when item selected from dropdown\n    $scope.$on('typeahead-updated', () => {\n      this.onTargetBlur();\n    });\n\n    this.init = function() {\n      let target = this.target;\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n\n      const scopeDefaults = {\n        metric: {},\n        oldTarget: _.cloneDeep(this.target),\n        queryOptionsText: this.renderQueryOptionsText()\n      };\n      _.defaults(this, scopeDefaults);\n\n      // Load default values\n      const targetDefaults = getTargetDefaults();\n      _.defaultsDeep(target, targetDefaults);\n\n      if (this.panel.type === c.ZABBIX_PROBLEMS_PANEL_ID) {\n        target.queryType = c.MODE_PROBLEMS;\n        target.options.severities = mapSeverityOptionsFromPanel(this.panel.triggerSeverity);\n      }\n\n      // Create function instances from saved JSON\n      target.functions = _.map(target.functions, func => {\n        return metricFunctions.createFuncInstance(func.def, func.params);\n      });\n\n      if (target.queryType === c.MODE_ITSERVICE) {\n        _.defaultsDeep(target, getSLATargetDefaults());\n      }\n\n      if (target.queryType === c.MODE_PROBLEMS) {\n        _.defaultsDeep(target, getProblemsTargetDefaults());\n      }\n\n      if (target.queryType === c.MODE_METRICS ||\n          target.queryType === c.MODE_TEXT ||\n          target.queryType === c.MODE_TRIGGERS ||\n          target.queryType === c.MODE_PROBLEMS) {\n        this.initFilters();\n      } else if (target.queryType === c.MODE_ITSERVICE) {\n        this.suggestITServices();\n      }\n    };\n\n    // Update panel schema version to prevent unnecessary migrations\n    if (this.panel.type === c.ZABBIX_PROBLEMS_PANEL_ID) {\n      this.panel.schemaVersion = CURRENT_SCHEMA_VERSION;\n    }\n\n    this.init();\n    this.queryOptionsText = this.renderQueryOptionsText();\n  }\n\n  initFilters() {\n    const mode = _.find(this.editorModes, {'queryType': this.target.queryType});\n    const itemtype = mode ? mode.value : null;\n    const promises = [\n      this.suggestGroups(),\n      this.suggestHosts(),\n      this.suggestApps(),\n    ];\n\n    if (this.target.queryType === c.MODE_METRICS || this.target.queryType === c.MODE_TEXT) {\n      promises.push(this.suggestItems(itemtype));\n    }\n\n    if (this.target.queryType === c.MODE_PROBLEMS) {\n      promises.push(this.suggestProxies());\n    }\n\n    return Promise.all(promises);\n  }\n\n  // Get list of metric names for bs-typeahead directive\n  getMetricNames(metricList, addAllValue) {\n    const metrics = _.uniq(_.map(this.metric[metricList], 'name'));\n\n    // Add template variables\n    _.forEach(this.templateSrv.variables, variable => {\n      metrics.unshift('$' + variable.name);\n    });\n\n    if (addAllValue) {\n      metrics.unshift('/.*/');\n    }\n\n    return metrics;\n  }\n\n  getTemplateVariables() {\n    return _.map(this.templateSrv.variables, variable => {\n      return '$' + variable.name;\n    });\n  }\n\n  suggestGroups() {\n    return this.zabbix.getAllGroups()\n    .then(groups => {\n      this.metric.groupList = groups;\n      return groups;\n    });\n  }\n\n  suggestHosts() {\n    const groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    return this.zabbix.getAllHosts(groupFilter)\n    .then(hosts => {\n      this.metric.hostList = hosts;\n      return hosts;\n    });\n  }\n\n  suggestApps() {\n    const groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    const hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    return this.zabbix.getAllApps(groupFilter, hostFilter)\n    .then(apps => {\n      this.metric.appList = apps;\n      return apps;\n    });\n  }\n\n  suggestItems(itemtype = 'num') {\n    const groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    const hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    const appFilter = this.replaceTemplateVars(this.target.application.filter);\n    const options = {\n      itemtype: itemtype,\n      showDisabledItems: this.target.options.showDisabledItems\n    };\n\n    return this.zabbix\n    .getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => {\n      this.metric.itemList = items;\n      return items;\n    });\n  }\n\n  suggestITServices() {\n    return this.zabbix.getITService()\n    .then(itservices => {\n      this.metric.itServiceList = itservices;\n      return itservices;\n    });\n  }\n\n  suggestProxies() {\n    return this.zabbix.getProxies()\n    .then(response => {\n      const proxies = _.map(response, 'host');\n      this.metric.proxyList = proxies;\n      return proxies;\n    });\n  }\n\n  isRegex(str) {\n    return utils.isRegex(str);\n  }\n\n  isVariable(str) {\n    return utils.isTemplateVariable(str, this.templateSrv.variables);\n  }\n\n  onTargetBlur() {\n    const newTarget = _.cloneDeep(this.target);\n    if (!_.isEqual(this.oldTarget, this.target)) {\n      this.oldTarget = newTarget;\n      this.targetChanged();\n    }\n  }\n  oldTarget(oldTarget: any, target: any) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  onVariableChange() {\n    if (this.isContainsVariables()) {\n      this.targetChanged();\n    }\n  }\n\n  /**\n   * Check query for template variables\n   */\n  isContainsVariables() {\n    return _.some(['group', 'host', 'application'], field => {\n      if (this.target[field] && this.target[field].filter) {\n        return utils.isTemplateVariable(this.target[field].filter, this.templateSrv.variables);\n      } else {\n        return false;\n      }\n    });\n  }\n\n  parseTarget() {\n    // Parse target\n  }\n\n  // Validate target and set validation info\n  validateTarget() {\n    // validate\n  }\n\n  targetChanged() {\n    this.initFilters();\n    this.parseTarget();\n    this.panelCtrl.refresh();\n  }\n\n  addFunction(funcDef) {\n    const newFunc = metricFunctions.createFuncInstance(funcDef);\n    newFunc.added = true;\n    this.target.functions.push(newFunc);\n\n    this.moveAliasFuncLast();\n\n    if (newFunc.params.length && newFunc.added ||\n        newFunc.def.params.length === 0) {\n      this.targetChanged();\n    }\n  }\n\n  removeFunction(func) {\n    this.target.functions = _.without(this.target.functions, func);\n    this.targetChanged();\n  }\n\n  moveFunction(func, offset) {\n    const index = this.target.functions.indexOf(func);\n    // @ts-ignore\n    _.move(this.target.functions, index, index + offset);\n    this.targetChanged();\n  }\n\n  moveAliasFuncLast() {\n    const aliasFunc = _.find(this.target.functions, func => {\n      return func.def.category === 'Alias';\n    });\n\n    if (aliasFunc) {\n      this.target.functions = _.without(this.target.functions, aliasFunc);\n      this.target.functions.push(aliasFunc);\n    }\n  }\n\n  toggleQueryOptions() {\n    this.showQueryOptions = !this.showQueryOptions;\n  }\n\n  onQueryOptionChange() {\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.onTargetBlur();\n  }\n\n  renderQueryOptionsText() {\n    const metricOptionsMap = {\n      showDisabledItems: \"Show disabled items\",\n    };\n\n    const problemsOptionsMap = {\n      sortProblems: \"Sort problems\",\n      acknowledged: \"Acknowledged\",\n      skipEmptyValues: \"Skip empty values\",\n      hostsInMaintenance: \"Show hosts in maintenance\",\n      limit: \"Limit problems\",\n      hostProxy: \"Show proxy\",\n    };\n\n    let optionsMap = {};\n\n    if (this.target.queryType === c.MODE_METRICS) {\n      optionsMap = metricOptionsMap;\n    } else if (this.target.queryType === c.MODE_PROBLEMS || this.target.queryType === c.MODE_TRIGGERS) {\n      optionsMap = problemsOptionsMap;\n    }\n\n    const options = [];\n    _.forOwn(this.target.options, (value, key) => {\n      if (value && optionsMap[key]) {\n        if (value === true) {\n          // Show only option name (if enabled) for boolean options\n          options.push(optionsMap[key]);\n        } else {\n          // Show \"option = value\" for another options\n          let optionValue = value;\n          if (value && value.text) {\n            optionValue = value.text;\n          } else if (value && value.value) {\n            optionValue = value.value;\n          }\n          options.push(optionsMap[key] + \" = \" + optionValue);\n        }\n      }\n    });\n    return \"Options: \" + options.join(', ');\n  }\n\n  /**\n   * Switch query editor to specified mode.\n   * Modes:\n   *  0 - items\n   *  1 - IT services\n   *  2 - Text metrics\n   */\n  switchEditorMode(mode) {\n    this.target.queryType = mode;\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.init();\n    this.targetChanged();\n  }\n}\n","import React, { PureComponent } from 'react';\nimport { parseLegacyVariableQuery } from '../utils';\nimport { SelectableValue } from '@grafana/data';\nimport { VariableQuery, VariableQueryTypes, VariableQueryProps, VariableQueryData } from '../types';\nimport { ZabbixInput } from './ZabbixInput';\nimport { InlineFormLabel, Select, Input } from '@grafana/ui';\n\nexport class ZabbixVariableQueryEditor extends PureComponent<VariableQueryProps, VariableQueryData> {\n  queryTypes: Array<SelectableValue<VariableQueryTypes>> = [\n    { value: VariableQueryTypes.Group, label: 'Group'},\n    { value: VariableQueryTypes.Host, label: 'Host' },\n    { value: VariableQueryTypes.Application, label: 'Application' },\n    { value: VariableQueryTypes.Item, label: 'Item' },\n    { value: VariableQueryTypes.ItemValues, label: 'Item values' },\n  ];\n\n  defaults: VariableQueryData = {\n    selectedQueryType: { value: VariableQueryTypes.Group, label: 'Group' },\n    queryType: VariableQueryTypes.Group,\n    group: '/.*/',\n    host: '',\n    application: '',\n    item: '',\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n\n    if (this.props.query && typeof this.props.query === 'string') {\n      // Backward compatibility\n      const query = parseLegacyVariableQuery(this.props.query);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        selectedQueryType,\n        legacyQuery: this.props.query,\n        ...query\n      };\n    } else if (this.props.query) {\n      const query = (this.props.query as VariableQuery);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        ...this.defaults,\n        ...query,\n        selectedQueryType,\n      };\n    } else {\n      this.state = this.defaults;\n    }\n  }\n\n  getSelectedQueryType(queryType: VariableQueryTypes) {\n    return this.queryTypes.find(q => q.value === queryType);\n  }\n\n  handleQueryUpdate = (evt: React.ChangeEvent<HTMLInputElement>, prop: string) => {\n    const value = evt.currentTarget.value;\n    this.setState((prevState: VariableQueryData) => {\n      const newQuery = {\n        ...prevState,\n      };\n      newQuery[prop] = value;\n\n      return {\n        ...newQuery,\n      };\n    });\n  }\n\n  handleQueryChange = () => {\n    const { queryType, group, host, application, item } = this.state;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  handleQueryTypeChange = (selectedItem: SelectableValue<VariableQueryTypes>) => {\n    this.setState({\n      ...this.state,\n      selectedQueryType: selectedItem,\n      queryType: selectedItem.value,\n    });\n\n    const { group, host, application, item } = this.state;\n    const queryType = selectedItem.value;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  render() {\n    const { selectedQueryType, legacyQuery, group, host, application, item } = this.state;\n\n    return (\n      <>\n        <div className=\"gf-form max-width-21\">\n          <InlineFormLabel width={10}>Query Type</InlineFormLabel>\n          <Select\n            width={11}\n            value={selectedQueryType}\n            options={this.queryTypes}\n            onChange={this.handleQueryTypeChange}\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <InlineFormLabel width={10}>Group</InlineFormLabel>\n            <ZabbixInput\n              value={group}\n              onChange={evt => this.handleQueryUpdate(evt, 'group')}\n              onBlur={this.handleQueryChange}\n            />\n          </div>\n          {selectedQueryType.value !== VariableQueryTypes.Group &&\n            <div className=\"gf-form max-width-30\">\n              <InlineFormLabel width={10}>Host</InlineFormLabel>\n              <ZabbixInput\n                value={host}\n                onChange={evt => this.handleQueryUpdate(evt, 'host')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n          }\n        </div>\n        {(selectedQueryType.value === VariableQueryTypes.Application ||\n          selectedQueryType.value === VariableQueryTypes.Item ||\n          selectedQueryType.value === VariableQueryTypes.ItemValues) &&\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-30\">\n              <InlineFormLabel width={10}>Application</InlineFormLabel>\n              <ZabbixInput\n                value={application}\n                onChange={evt => this.handleQueryUpdate(evt, 'application')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n            {(selectedQueryType.value === VariableQueryTypes.Item ||\n              selectedQueryType.value === VariableQueryTypes.ItemValues) &&\n              <div className=\"gf-form max-width-30\">\n                <InlineFormLabel width={10}>Item</InlineFormLabel>\n                <ZabbixInput\n                  value={item}\n                  onChange={evt => this.handleQueryUpdate(evt, 'item')}\n                  onBlur={this.handleQueryChange}\n                />\n              </div>\n            }\n          </div>\n        }\n\n        {legacyQuery &&\n          <div className=\"gf-form\">\n            <InlineFormLabel width={10} tooltip=\"Original query string, read-only\">Legacy Query</InlineFormLabel>\n            <Input\n              value={legacyQuery}\n              readOnly={true}\n            />\n          </div>\n        }\n      </>\n    );\n  }\n}\n","import React, { useEffect, useState } from 'react';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { DataSourceHttpSettings, LegacyForms, Field, Input, Button, InlineFormLabel, Select } from '@grafana/ui';\nconst { FormField, Switch } = LegacyForms;\nimport { ZabbixDSOptions, ZabbixSecureJSONData } from '../types';\n\nconst SUPPORTED_SQL_DS = ['mysql', 'postgres', 'influxdb'];\n\nexport type Props = DataSourcePluginOptionsEditorProps<ZabbixDSOptions, ZabbixSecureJSONData>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  const [selectedDBDatasource, setSelectedDBDatasource] = useState(null);\n  const [currentDSType, setCurrentDSType] = useState('');\n\n  // Apply some defaults on initial render\n  useEffect(() => {\n    const { jsonData, secureJsonFields } = options;\n\n    // Set secureJsonFields.password to password and then remove it from config\n    const { password, ...restJsonData } = jsonData;\n    if (!secureJsonFields?.password) {\n      if (!options.secureJsonData) {\n        options.secureJsonData = {};\n      }\n      options.secureJsonData.password = password;\n    }\n\n    onOptionsChange({\n      ...options,\n      jsonData: {\n        trends: true,\n        trendsFrom: '',\n        trendsRange: '',\n        cacheTTL: '',\n        ...restJsonData,\n      },\n    });\n\n    if (options.jsonData.dbConnectionEnable) {\n      if (!options.jsonData.dbConnectionDatasourceId) {\n        const dsName = options.jsonData.dbConnectionDatasourceName;\n        getDataSourceSrv().get(dsName)\n        .then(ds => {\n          if (ds) {\n            const selectedDs = getDirectDBDatasources().find(dsOption => dsOption.id === ds.id);\n            setSelectedDBDatasource({ label: selectedDs.name, value: selectedDs.id });\n            setCurrentDSType(selectedDs.type);\n            onOptionsChange({\n              ...options,\n              jsonData: {\n                ...options.jsonData,\n                dbConnectionDatasourceId: ds.id,\n              },\n            });\n          }\n        });\n      } else {\n        const selectedDs = getDirectDBDatasources().find(dsOption => dsOption.id === options.jsonData.dbConnectionDatasourceId);\n        setSelectedDBDatasource({ label: selectedDs.name, value: selectedDs.id });\n        setCurrentDSType(selectedDs.type);\n      }\n    }\n  }, []);\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost/zabbix/api_jsonrpc.php'}\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <h3 className=\"page-heading\">Zabbix API details</h3>\n        <div className=\"gf-form max-width-25\">\n          <FormField\n            labelWidth={7}\n            inputWidth={15}\n            label=\"Username\"\n            value={options.jsonData.username || ''}\n            onChange={jsonDataChangeHandler('username', options, onOptionsChange)}\n            required\n          />\n        </div>\n        <div className=\"gf-form max-width-25\">\n          {options.secureJsonFields?.password ?\n            <>\n              <FormField\n                labelWidth={7}\n                inputWidth={15}\n                label=\"Password\"\n                disabled={true}\n                value=\"\"\n                placeholder=\"Configured\"\n              />\n              <Button onClick={resetSecureJsonField('password', options, onOptionsChange)}>Reset</Button>\n            </>:\n            <FormField\n              labelWidth={7}\n              inputWidth={15}\n              label=\"Password\"\n              type=\"password\"\n              value={options.secureJsonData?.password || options.jsonData.password || ''}\n              onChange={secureJsonDataChangeHandler('password', options, onOptionsChange)}\n              required\n            />\n          }\n        </div>\n        <Switch\n          label=\"Trends\"\n          labelClass=\"width-7\"\n          checked={options.jsonData.trends}\n          onChange={jsonDataSwitchHandler('trends', options, onOptionsChange)}\n        />\n        {options.jsonData.trends &&\n          <>\n            <div className=\"gf-form\">\n              <FormField\n                labelWidth={7}\n                inputWidth={4}\n                label=\"After\"\n                value={options.jsonData.trendsFrom || ''}\n                placeholder=\"7d\"\n                onChange={jsonDataChangeHandler('trendsFrom', options, onOptionsChange)}\n                tooltip=\"Time after which trends will be used.\n                  Best practice is to set this value to your history storage period (7d, 30d, etc).\"\n              />\n            </div>\n            <div className=\"gf-form\">\n              <FormField\n                labelWidth={7}\n                inputWidth={4}\n                label=\"Range\"\n                value={options.jsonData.trendsRange || ''}\n                placeholder=\"4d\"\n                onChange={jsonDataChangeHandler('trendsRange', options, onOptionsChange)}\n                tooltip=\"Time range width after which trends will be used instead of history.\n                  It's better to set this value in range of 4 to 7 days to prevent loading large amount of history data.\"\n              />\n            </div>\n          </>\n        }\n        <div className=\"gf-form\">\n          <FormField\n            labelWidth={7}\n            inputWidth={4}\n            label=\"Cache TTL\"\n            value={options.jsonData.cacheTTL || ''}\n            placeholder=\"1h\"\n            onChange={jsonDataChangeHandler('cacheTTL', options, onOptionsChange)}\n            tooltip=\"Zabbix data source caches metric names in memory. Specify how often data will be updated.\"\n          />\n        </div>\n      </div>\n\n      <div className=\"gf-form-group\">\n        <h3 className=\"page-heading\">Direct DB Connection</h3>\n        <Switch\n          label=\"Enable\"\n          labelClass=\"width-9\"\n          checked={options.jsonData.dbConnectionEnable}\n          onChange={jsonDataSwitchHandler('dbConnectionEnable', options, onOptionsChange)}\n        />\n        {options.jsonData.dbConnectionEnable &&\n          <>\n            <div className=\"gf-form\">\n              <InlineFormLabel width={9}>Data Source</InlineFormLabel>\n              <Select\n                width={32}\n                options={getDirectDBDSOptions()}\n                value={selectedDBDatasource}\n                onChange={directDBDatasourceChanegeHandler(options, onOptionsChange, setSelectedDBDatasource, setCurrentDSType)}\n              />\n            </div>\n            {currentDSType === 'influxdb' &&\n              <div className=\"gf-form\">\n                <FormField\n                  labelWidth={9}\n                  inputWidth={16}\n                  label=\"Retention Policy\"\n                  value={options.jsonData.dbConnectionRetentionPolicy || ''}\n                  placeholder=\"Retention policy name\"\n                  onChange={jsonDataChangeHandler('dbConnectionRetentionPolicy', options, onOptionsChange)}\n                  tooltip=\"Specify retention policy name for fetching long-term stored data (optional).\n                    Leave it blank if only default retention policy used.\"\n                />\n              </div>\n            }\n          </>\n        }\n      </div>\n\n      <div className=\"gf-form-group\">\n        <h3 className=\"page-heading\">Other</h3>\n        <Switch\n          label=\"Disable acknowledges for read-only users\"\n          labelClass=\"width-20\"\n          checked={options.jsonData.disableReadOnlyUsersAck}\n          onChange={jsonDataSwitchHandler('disableReadOnlyUsersAck', options, onOptionsChange)}\n        />\n      </div>\n    </>\n  );\n};\n\nconst jsonDataChangeHandler = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n\nconst jsonDataSwitchHandler = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLInputElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: (event.target as HTMLInputElement).checked,\n    },\n  });\n};\n\nconst secureJsonDataChangeHandler = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n) => {\n  onChange({\n    ...value,\n    secureJsonData: {\n      ...value.secureJsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n\nconst resetSecureJsonField = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLButtonElement>\n) => {\n  onChange({\n    ...value,\n    secureJsonFields: {\n      ...value.secureJsonFields,\n      [key]: false,\n    },\n  });\n};\n\nconst directDBDatasourceChanegeHandler = (\n  options: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange'],\n  setSelectedDS: React.Dispatch<any>,\n  setSelectedDSType: React.Dispatch<any>,\n) => (\n  value: SelectableValue<number>\n) => {\n  const selectedDs = getDirectDBDatasources().find(dsOption => dsOption.id === value.value);\n  setSelectedDS({ label: selectedDs.name, value: selectedDs.id });\n  setSelectedDSType(selectedDs.type);\n  onChange({\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      dbConnectionDatasourceId: value.value\n    },\n  });\n};\n\nconst getDirectDBDatasources = () => {\n  let dsList = (getDataSourceSrv() as any).getAll();\n  dsList = dsList.filter(ds => SUPPORTED_SQL_DS.includes(ds.type));\n  return dsList;\n};\n\nconst getDirectDBDSOptions = () => {\n  const dsList = getDirectDBDatasources();\n  const dsOpts: Array<SelectableValue<number>> = dsList.map(ds => ({ label: ds.name, value: ds.id, description: ds.type }));\n  return dsOpts;\n};\n","import angular from 'angular';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport * as metricFunctions from './metricFunctions';\n\nangular\n  .module('grafana.directives')\n  .directive('addMetricFunction',\n\n  /** @ngInject */\n  function($compile) {\n    var inputTemplate = '<input type=\"text\"'+\n                          ' class=\"gf-form-input\"' +\n                          ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n    var buttonTemplate = '<a  class=\"gf-form-label tight-form-func dropdown-toggle query-part\"' +\n                            ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\n                            '<i class=\"fa fa-plus\"></i></a>';\n\n    return {\n      link: function($scope, elem) {\n        var categories = metricFunctions.getCategories();\n        var allFunctions = getAllFunctionNames(categories);\n\n        $scope.functionMenu = createFunctionDropDownMenu(categories);\n\n        var $input = $(inputTemplate);\n        var $button = $(buttonTemplate);\n        $input.appendTo(elem);\n        $button.appendTo(elem);\n\n        $input.attr('data-provide', 'typeahead');\n        $input.typeahead({\n          source: allFunctions,\n          minLength: 1,\n          items: 10,\n          updater: function (value) {\n            var funcDef = metricFunctions.getFuncDef(value);\n            if (!funcDef) {\n              // try find close match\n              value = value.toLowerCase();\n              funcDef = _.find(allFunctions, function(funcName) {\n                return funcName.toLowerCase().indexOf(value) === 0;\n              });\n\n              if (!funcDef) { return; }\n            }\n\n            $scope.$apply(function() {\n              $scope.ctrl.addFunction(funcDef);\n            });\n\n            $input.trigger('blur');\n            return '';\n          }\n        });\n\n        $button.click(function() {\n          $button.hide();\n          $input.show();\n          $input.focus();\n        });\n\n        $input.keyup(function() {\n          elem.toggleClass('open', $input.val() === '');\n        });\n\n        $input.blur(function() {\n          // clicking the function dropdown menu won't\n          // work if you remove class at once\n          setTimeout(function() {\n            $input.val('');\n            $input.hide();\n            $button.show();\n            elem.removeClass('open');\n          }, 200);\n        });\n\n        $compile(elem.contents())($scope);\n      }\n    };\n  });\n\nfunction getAllFunctionNames(categories) {\n  return _.reduce(categories, function(list, category) {\n    _.each(category, function(func) {\n      list.push(func.name);\n    });\n    return list;\n  }, []);\n}\n\nfunction createFunctionDropDownMenu(categories) {\n  return _.map(categories, function(list, category) {\n    return {\n      text: category,\n      submenu: _.map(list, function(value) {\n        return {\n          text: value.name,\n          click: \"ctrl.addFunction('\" + value.name + \"')\",\n        };\n      })\n    };\n  });\n}\n\n","import coreModule from 'grafana/app/core/core_module';\n\nexport function react2AngularDirective(name: string, component: any, options: any) {\n  coreModule.directive(name, [\n    'reactDirective',\n    reactDirective => {\n      return reactDirective(component, options);\n    },\n  ]);\n}\n","import React from 'react';\n\nconst DOCS_FUNC_REF_URL = 'https://alexanderzobnin.github.io/grafana-zabbix/reference/functions/';\n\nexport interface FunctionDescriptor {\n  text: string;\n  params: string[];\n  def: {\n    category: string;\n    defaultParams: string[];\n    description?: string;\n    fake: boolean;\n    name: string;\n    params: string[];\n  };\n}\n\nexport interface FunctionEditorControlsProps {\n  onMoveLeft: (func: FunctionDescriptor) => void;\n  onMoveRight: (func: FunctionDescriptor) => void;\n  onRemove: (func: FunctionDescriptor) => void;\n}\n\nconst FunctionHelpButton = (props: { description: string; name: string; onDescriptionShow: () => void }) => {\n  if (props.description) {\n    return <span className=\"pointer fa fa-question-circle\" onClick={props.onDescriptionShow} />;\n  }\n\n  return (\n    <span\n      className=\"pointer fa fa-question-circle\"\n      onClick={() => {\n        window.open(\n          DOCS_FUNC_REF_URL + '#' + props.name,\n          '_blank'\n        );\n      }}\n    />\n  );\n};\n\nexport const FunctionEditorControls = (\n  props: FunctionEditorControlsProps & {\n    func: FunctionDescriptor;\n    onDescriptionShow: () => void;\n  }\n) => {\n  const { func, onMoveLeft, onMoveRight, onRemove, onDescriptionShow } = props;\n  return (\n    <div\n      style={{\n        display: 'flex',\n        width: '60px',\n        justifyContent: 'space-between',\n      }}\n    >\n      <span className=\"pointer fa fa-arrow-left\" onClick={() => onMoveLeft(func)} />\n      <FunctionHelpButton\n        name={func.def.name}\n        description={func.def.description}\n        onDescriptionShow={onDescriptionShow}\n      />\n      <span className=\"pointer fa fa-remove\" onClick={() => onRemove(func)} />\n      <span className=\"pointer fa fa-arrow-right\" onClick={() => onMoveRight(func)} />\n    </div>\n  );\n};\n","import React from 'react';\n// import rst2html from 'rst2html';\nimport { FunctionDescriptor, FunctionEditorControlsProps, FunctionEditorControls } from './FunctionEditorControls';\n\n// @ts-ignore\nimport { PopoverController, Popover } from '@grafana/ui';\n\ninterface FunctionEditorProps extends FunctionEditorControlsProps {\n  func: FunctionDescriptor;\n}\n\ninterface FunctionEditorState {\n  showingDescription: boolean;\n}\n\nclass FunctionEditor extends React.PureComponent<FunctionEditorProps, FunctionEditorState> {\n  private triggerRef = React.createRef<HTMLSpanElement>();\n\n  constructor(props: FunctionEditorProps) {\n    super(props);\n\n    this.state = {\n      showingDescription: false,\n    };\n  }\n\n  renderContent = ({ updatePopperPosition }) => {\n    const {\n      onMoveLeft,\n      onMoveRight,\n      func: {\n        def: { name, description },\n      },\n    } = this.props;\n    const { showingDescription } = this.state;\n\n    if (showingDescription) {\n      return (\n        <div style={{ overflow: 'auto', maxHeight: '30rem', textAlign: 'left', fontWeight: 'normal' }}>\n          <h4 style={{ color: 'white' }}> {name} </h4>\n          <div>{description}</div>\n        </div>\n      );\n    }\n\n    return (\n      <FunctionEditorControls\n        {...this.props}\n        onMoveLeft={() => {\n          onMoveLeft(this.props.func);\n          updatePopperPosition();\n        }}\n        onMoveRight={() => {\n          onMoveRight(this.props.func);\n          updatePopperPosition();\n        }}\n        onDescriptionShow={() => {\n          this.setState({ showingDescription: true }, () => {\n            updatePopperPosition();\n          });\n        }}\n      />\n    );\n  };\n\n  render() {\n    return (\n      <PopoverController content={this.renderContent} placement=\"top\" hideAfter={300}>\n        {(showPopper, hidePopper, popperProps) => {\n          return (\n            <>\n              {this.triggerRef && (\n                <Popover\n                  {...popperProps}\n                  referenceElement={this.triggerRef.current}\n                  wrapperClassName=\"popper\"\n                  className=\"popper__background\"\n                  onMouseLeave={() => {\n                    this.setState({ showingDescription: false });\n                    hidePopper();\n                  }}\n                  onMouseEnter={showPopper}\n                  renderArrow={({ arrowProps, placement }) => (\n                    <div className=\"popper__arrow\" data-placement={placement} {...arrowProps} />\n                  )}\n                />\n              )}\n\n              <span\n                ref={this.triggerRef}\n                onClick={popperProps.show ? hidePopper : showPopper}\n                onMouseLeave={() => {\n                  hidePopper();\n                  this.setState({ showingDescription: false });\n                }}\n                style={{ cursor: 'pointer' }}\n              >\n                {this.props.func.def.name}\n              </span>\n            </>\n          );\n        }}\n      </PopoverController>\n    );\n  }\n}\n\nexport { FunctionEditor };\n","import coreModule from 'grafana/app/core/core_module';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport { react2AngularDirective } from './react2angular';\nimport { FunctionEditor } from './components/FunctionEditor';\n\n/** @ngInject */\nexport function zabbixFunctionEditor($compile, templateSrv) {\n  const funcSpanTemplate = `\n    <zbx-function-editor\n      func=\"func\"\n      onRemove=\"ctrl.handleRemoveFunction\"\n      onMoveLeft=\"ctrl.handleMoveLeft\"\n      onMoveRight=\"ctrl.handleMoveRight\"\n    /><span>(</span>\n  `;\n  const paramTemplate =\n    '<input type=\"text\" style=\"display:none\"' + ' class=\"input-small tight-form-func-param\"></input>';\n\n  return {\n    restrict: 'A',\n    link: function postLink($scope, elem) {\n      const $funcLink = $(funcSpanTemplate);\n      const ctrl = $scope.ctrl;\n      const func = $scope.func;\n      let scheduledRelink = false;\n      let paramCountAtLink = 0;\n      let cancelBlur = null;\n\n      ctrl.handleRemoveFunction = func => {\n        ctrl.removeFunction(func);\n      };\n\n      ctrl.handleMoveLeft = func => {\n        ctrl.moveFunction(func, -1);\n      };\n\n      ctrl.handleMoveRight = func => {\n        ctrl.moveFunction(func, 1);\n      };\n\n      function clickFuncParam(this: any, paramIndex) {\n        /*jshint validthis:true */\n\n        const $link = $(this);\n        const $comma = $link.prev('.comma');\n        const $input = $link.next();\n\n        $input.val(func.params[paramIndex]);\n\n        $comma.removeClass('query-part__last');\n        $link.hide();\n        $input.show();\n        $input.focus();\n        $input.select();\n\n        const typeahead = $input.data('typeahead');\n        if (typeahead) {\n          $input.val('');\n          typeahead.lookup();\n        }\n      }\n\n      function scheduledRelinkIfNeeded() {\n        if (paramCountAtLink === func.params.length) {\n          return;\n        }\n\n        if (!scheduledRelink) {\n          scheduledRelink = true;\n          setTimeout(() => {\n            relink();\n            scheduledRelink = false;\n          }, 200);\n        }\n      }\n\n      function paramDef(index) {\n        if (index < func.def.params.length) {\n          return func.def.params[index];\n        }\n        if ((_.last(func.def.params) as any).multiple) {\n          return _.assign({}, _.last(func.def.params), { optional: true });\n        }\n        return {};\n      }\n\n      function switchToLink(inputElem, paramIndex) {\n        /*jshint validthis:true */\n        const $input = $(inputElem);\n\n        clearTimeout(cancelBlur);\n        cancelBlur = null;\n\n        const $link = $input.prev();\n        const $comma = $link.prev('.comma');\n        const newValue = $input.val();\n\n        // remove optional empty params\n        if (newValue !== '' || paramDef(paramIndex).optional) {\n          func.updateParam(newValue, paramIndex);\n          $link.html(newValue ? templateSrv.highlightVariablesAsHtml(newValue) : '&nbsp;');\n        }\n\n        scheduledRelinkIfNeeded();\n\n        $scope.$apply(() => {\n          ctrl.targetChanged();\n        });\n\n        if ($link.hasClass('query-part__last') && newValue === '') {\n          $comma.addClass('query-part__last');\n        } else {\n          $link.removeClass('query-part__last');\n        }\n\n        $input.hide();\n        $link.show();\n      }\n\n      // this = input element\n      function inputBlur(this: any, paramIndex) {\n        /*jshint validthis:true */\n        const inputElem = this;\n        // happens long before the click event on the typeahead options\n        // need to have long delay because the blur\n        cancelBlur = setTimeout(() => {\n          switchToLink(inputElem, paramIndex);\n        }, 200);\n      }\n\n      function inputKeyPress(this: any, paramIndex, e) {\n        /*jshint validthis:true */\n        if (e.which === 13) {\n          $(this).blur();\n        }\n      }\n\n      function inputKeyDown(this: any) {\n        /*jshint validthis:true */\n        this.style.width = (3 + this.value.length) * 8 + 'px';\n      }\n\n      function addTypeahead($input, paramIndex) {\n        $input.attr('data-provide', 'typeahead');\n\n        let options = paramDef(paramIndex).options;\n        if (paramDef(paramIndex).type === 'int' || paramDef(paramIndex).type === 'float') {\n          options = _.map(options, val => {\n            return val.toString();\n          });\n        }\n\n        $input.typeahead({\n          source: options,\n          minLength: 0,\n          items: 20,\n          updater: value => {\n            $input.val(value);\n            switchToLink($input[0], paramIndex);\n            return value;\n          },\n        });\n\n        const typeahead = $input.data('typeahead');\n        typeahead.lookup = function() {\n          this.query = this.$element.val() || '';\n          return this.process(this.source);\n        };\n      }\n\n      function addElementsAndCompile() {\n        $funcLink.appendTo(elem);\n\n        const defParams: any = _.clone(func.def.params);\n        const lastParam: any = _.last(func.def.params);\n\n        while (func.params.length >= defParams.length && lastParam && lastParam.multiple) {\n          defParams.push(_.assign({}, lastParam, { optional: true }));\n        }\n\n        _.each(defParams, (param: any, index: number) => {\n          if (param.optional && func.params.length < index) {\n            return false;\n          }\n\n          let paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n          const hasValue = paramValue !== null && paramValue !== undefined;\n\n          const last = index >= func.params.length - 1 && param.optional && !hasValue;\n          if (last && param.multiple) {\n            paramValue = '+';\n          }\n\n          if (index > 0) {\n            $('<span class=\"comma' + (last ? ' query-part__last' : '') + '\">, </span>').appendTo(elem);\n          }\n\n          const $paramLink = $(\n            '<a ng-click=\"\" class=\"graphite-func-param-link' +\n              (last ? ' query-part__last' : '') +\n              '\">' +\n              (hasValue ? paramValue : '&nbsp;') +\n              '</a>'\n          );\n          const $input = $(paramTemplate);\n          $input.attr('placeholder', param.name);\n\n          paramCountAtLink++;\n\n          $paramLink.appendTo(elem);\n          $input.appendTo(elem);\n\n          $input.blur(_.partial(inputBlur, index));\n          $input.keyup(inputKeyDown);\n          $input.keypress(_.partial(inputKeyPress, index));\n          $paramLink.click(_.partial(clickFuncParam, index));\n\n          if (param.options) {\n            addTypeahead($input, index);\n          }\n\n          return true;\n        });\n\n        $('<span>)</span>').appendTo(elem);\n\n        $compile(elem.contents())($scope);\n      }\n\n      function ifJustAddedFocusFirstParam() {\n        if ($scope.func.added) {\n          $scope.func.added = false;\n          setTimeout(() => {\n            elem\n              .find('.graphite-func-param-link')\n              .first()\n              .click();\n          }, 10);\n        }\n      }\n\n      function relink() {\n        elem.children().remove();\n        addElementsAndCompile();\n        ifJustAddedFocusFirstParam();\n      }\n\n      relink();\n    },\n  };\n}\n\ncoreModule.directive('zabbixFunctionEditor', zabbixFunctionEditor);\n\nreact2AngularDirective('zbxFunctionEditor', FunctionEditor, ['func', 'onRemove', 'onMoveLeft', 'onMoveRight']);\n","import { DataSourcePlugin } from '@grafana/data';\nimport { loadPluginCss } from '@grafana/runtime';\nimport { ZabbixDatasource } from './datasource';\nimport { ZabbixQueryController } from './query.controller';\nimport { ZabbixVariableQueryEditor } from './components/VariableQueryEditor';\nimport { ConfigEditor } from './components/ConfigEditor';\nimport './add-metric-function.directive';\nimport './metric-function-editor.directive';\n\nclass ZabbixAnnotationsQueryController {\n  static templateUrl = 'datasource-zabbix/partials/annotations.editor.html';\n}\n\nZabbixQueryController.templateUrl = 'datasource-zabbix/partials/query.editor.html';\n\nloadPluginCss({\n  dark: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.dark.css',\n  light: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.light.css'\n});\n\nexport const plugin = new DataSourcePlugin(ZabbixDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryCtrl(ZabbixQueryController)\n  .setAnnotationQueryCtrl(ZabbixAnnotationsQueryController)\n  .setVariableQueryEditor(ZabbixVariableQueryEditor);\n"],"sourceRoot":""}